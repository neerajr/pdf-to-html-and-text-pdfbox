<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>The unix programming environment
</p>
<p>Edition 2.1, Feb 1999
</p>
<p>Mark Burgess
</p>
<p>Centre of Science and Technology
</p>
<p>Faculty of Engineering, Oslo College</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Copyright
</p>
<p>c
</p>
<p>&#13; 1996/7 Mark Burgess
</p>
<p>Permission is granted to make and distribute verbatim copies of this manual provided the
</p>
<p>copyright notice and this permission notice are preserved on all copies.
</p>
<p>Permission is granted to copy and distribute modi&#12;ed versions of this manual under the
</p>
<p>conditions for verbatim copying, provided also that the section entitled &quot;GNU General
</p>
<p>Public License&quot; is included exactly as in the original, and provided that the entire resulting
</p>
<p>derived work is distributed under the terms of a permission notice identical to this one.
</p>
<p>Permission is granted to copy and distribute translations of this manual into another lan-
</p>
<p>guage, under the above conditions for modi&#12;ed versions, except that the section entitled
</p>
<p>&quot;GNU General Public License&quot; may be included in a translation approved by the author
</p>
<p>instead of in the original English.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Foreword 1
</p>
<p>Foreword
</p>
<p>This is a revised version of the UNIX compendium which is available in printed form
</p>
<p>and online via the WWW and info hypertext readers. It forms the basis for a one or two
</p>
<p>semester course in UNIX. The most up-to-date version of this manual can be found at
</p>
<p>http://www.iu.hioslo.no/~mark/unix.html.
</p>
<p>It is a reference guide which contains enough to help you to &#12;nd what you need from
</p>
<p>other sources. It is not (and probably can never be) a complete and self-contained work.
</p>
<p>Certain topics are covered in more detail than others. Some topics are included for future
</p>
<p>reference and are not intended to be part of an introductory course, but will probably be
</p>
<p>useful later. The chapter on X11 programming has been deleted for the time being.
</p>
<p>Comments to Mark.Burgess@iu.hioslo.no
</p>
<p>Oslo, June 1996</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>2 The unix programming environment</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Welcome 3
</p>
<p>Welcome
</p>
<p>If you are coming to unix for the &#12;rst time, from a Windows or MacIntosh environment,
</p>
<p>be prepared for a rather di&#11;erent culture than the one you are used to. Unix is not about
</p>
<p>`products' and o&#11;-the-shelf software, it is about open standards, free software and the ability
</p>
<p>to change just about everything.
</p>
<p>&#15; What you personally might perceive as user friendliness in other systems, others might
</p>
<p>perceive as annoying time wasting. Unix o&#11;ers you just about every level of friendli-
</p>
<p>ness and unfriendliness, if you choose your programs right. In this book, we take the
</p>
<p>programmer's point of view.
</p>
<p>&#15; Unix is about functionality, not about simplicity. Be prepared for powerful, not neces-
</p>
<p>sarily `simple' solutions.
</p>
<p>You should approach Unix the way you should approach any new system: with an open
</p>
<p>mind. The journey begins...</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>4 The unix programming environment</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 1: Overview 5
</p>
<p>1 Overview
</p>
<p>In this manual the word &quot;host&quot; is used to refer to a single computer system { i.e. a
</p>
<p>single machine which has a name termed its &quot;hostname&quot;.
</p>
<p>1.1 What is unix?
</p>
<p>Unix is one of the most important operating system in use today, perhaps even the most
</p>
<p>important. Since its invention around the beginning of the 1970s it has been an object of
</p>
<p>continual research and development. UNIX is not popular because it is the best operating
</p>
<p>system one could imagine, but because it is an extremely &#13;exible system which is easy to
</p>
<p>extend and modify. It is an ideal platform for developing new ideas.
</p>
<p>Much of the success of UNIX may be attributed to the rapid pace of its development
</p>
<p>(a development to which all of its users have been able to contribute) its e&#14;ciency at
</p>
<p>running programs and the many powerful tools which have been written for it over the
</p>
<p>years, such as the C programming language, make, shell, lex and yacc and many others.
</p>
<p>UNIX was written by programmers for programmers. It is popular in situations where
</p>
<p>a lot of computing power is required and for database applications, where timesharing is
</p>
<p>critical. In contrast to some operating systems, UNIX performs equally well on large scale
</p>
<p>computers (with many processors) and small computers which &#12;t in your suitcase!
</p>
<p>All of the basic mechanisms required of a multi-user operating system are present in
</p>
<p>UNIX. During the last few years it has become ever more popular and has formed the basis
</p>
<p>of newer, though less mature, systems like NT. One reason for this that now computers
</p>
<p>have now become powerful enough to run UNIX e&#11;ectively. UNIX places burdens on the
</p>
<p>resources of a computer, since it expects to be able to run potentially many programs
</p>
<p>simultaneously.
</p>
<p>If you are coming to UNIX from DOS you may well be used to using applications software
</p>
<p>or helpful interactive utilities to solve every problem. UNIX is not usually like this: the
</p>
<p>operating system has much greater functionality and provides the possibilities for making
</p>
<p>your own, so it is less common to &#12;nd applications software which implements the same
</p>
<p>things. UNIX has long been in the hands of academics who are used to making their own
</p>
<p>applications or writing their own programs, whereas as the DOS world has been driven by
</p>
<p>businesses who are willing to spend money on software. For that reason commerical UNIX
</p>
<p>software is often very expensive and therefore not available at this college. On the other
</p>
<p>hand, the &#13;exibility of UNIX means that it is easy to write programs and it is possible to
</p>
<p>fetch gigabytes of free software from the internet to suit your needs. It may not look like
</p>
<p>what you are used to on your PC, but then you have to remember that UNIX users are a
</p>
<p>di&#11;erent kind of animal altogether
</p>
<p>Like all operating systems, UNIX has many faults. The biggest problem for any operating
</p>
<p>system is that it evolves without being redesigned. Operating systems evolve as more and
</p>
<p>more patches and hacks are applied to solve day-to-day problems. The result is either a mess
</p>
<p>which works somehow (like UNIX) or a blank refusal to change (like DOS or MacIntosh).
</p>
<p>From a practical perspective, Unix is important and successful because it is a multi-process
</p>
<p>system which
</p>
<p>&#15; has an enormous functionality built in, and the capacity to adapt itself to changing
</p>
<p>technologies,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>6 The unix programming environment
</p>
<p>&#15; is relatively portable,
</p>
<p>&#15; is good at sharing resources (but not so good at security),
</p>
<p>&#15; has tools which are each developed to do one thing well,
</p>
<p>&#15; allows these tools to be combined in every imaginable way, using pipes and channeling
</p>
<p>of data streams,
</p>
<p>&#15; incorporates networking almost trivially, because all the right mechanisms are already
</p>
<p>there for providing services and sharing, building client-server pairs etc,.
</p>
<p>&#15; it is very adaptable and is often used to develop new ideas because of the rich variety
</p>
<p>of tools it possesses.
</p>
<p>Unix has some problems: it is old, it contains a lot of rubbish which no one ever bothered
</p>
<p>to throw away. Although it develops quickly (at light speed compared to either DOS or
</p>
<p>MacIntosh) the user interface has been the slowest thing to change. Unix is not user-
</p>
<p>friendly for beginners, it is user-friendly for advanced users: it is made for users who know
</p>
<p>about computing. It sometimes makes simple things di&#14;cult, but above all it makes things
</p>
<p>possible!
</p>
<p>The aim of this introduction is to
</p>
<p>&#15; introduce the unix system basics and user interface,
</p>
<p>&#15; develop the unix philosophy of using and combining tools,
</p>
<p>&#15; learn how to make new tools and write software,
</p>
<p>&#15; learn how to understand existing software.
</p>
<p>To accomplish this task, we must &#12;rst learn something about the shell (the way in which
</p>
<p>UNIX starts programs). Later we shall learn how to solve more complex problems using
</p>
<p>Perl and C. Each of these is a language which can be used to put UNIX to work. We must
</p>
<p>also learn when to use which tool, so that we do not waste time and e&#11;ort. Typical uses
</p>
<p>for these di&#11;erent interfaces are
</p>
<p>shell Command line interaction, making scripts which perform simple jobs such as
</p>
<p>running programs in batch, installing new software, simple system con&#12;guration
</p>
<p>and administration.
</p>
<p>perl Text interpretation, text formatting, output &#12;lters, mail robots, WWW cgi
</p>
<p>(common gateway interface) scripts in forms, password testing, simple database
</p>
<p>manipulation, simple client-server applications.
</p>
<p>C Nearly all of UNIX is written in C. Any program which cannot be solved quickly
</p>
<p>using shell or perl can be written in C. One advantage is that C is a compiled
</p>
<p>language and many simple errors can be caught at compile time.
</p>
<p>Much of UNIX's recent popularity has been a result of its networking abilities: unix is
</p>
<p>the backbone of the internet. No other widely available system could keep the internet alive
</p>
<p>today.
</p>
<p>Once you have mastered the unix interface and philosophy you will &#12;nd that i) the PC
</p>
<p>and MacIntosh window environments seem to be easy to use, but simplistic and primitive
</p>
<p>by comparison; ii) UNIX is far from being the perfect operating system|it has a whole
</p>
<p>di&#11;erent set of problems and &#13;aws.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 1: Overview 7
</p>
<p>The operating system of the future will not be UNIX as we see it today, nor will is be
</p>
<p>DOS or MacIntosh, but one thing is for certain: it will owe a lot to the UNIX operating
</p>
<p>system and will contain many of the tools and mechanisms we shall describe below.
</p>
<p>1.2 Flavours of unix
</p>
<p>Unix is not a single operating system. It has branched out in many di&#11;erent directions
</p>
<p>since it was introduced by AT&amp;T. The most important `fork()' in its history happened
</p>
<p>early on when the university of Berkeley, California created the BSD (Berkeley Software
</p>
<p>Distribution), adding network support and the C-shell.
</p>
<p>Here are some of the most common implementations of unix.
</p>
<p>BSD: Berkeley, BSD
</p>
<p>SunOS: Sun Microsystems, BSD/sys 5
</p>
<p>Solaris: Sun Microsystems, Sys 5/BSD
</p>
<p>Ultrix: Digital Equipment Corperation, BSD
</p>
<p>OSF 1: Digital Equipment Corperation, BSD/sys 5
</p>
<p>HPUX: Hewlett-Packard, Sys 5
</p>
<p>AIX: IBM, Sys 5 / BSD
</p>
<p>IRIX: Silicon Graphics, Sys 5
</p>
<p>GNU/Linux:
</p>
<p>GNU, BSD/Posix
</p>
<p>1.3 How to use this reference guide
</p>
<p>This programming guide is something between a user manual and a tutorial. The infor-
</p>
<p>mation contained here should be su&#14;cient to get you started with the unix system, but it
</p>
<p>is far from complete.
</p>
<p>To use this programming guide, you will need to work through the basics from each
</p>
<p>chapter. You will &#12;nd that there is much more information here than you need straight
</p>
<p>away, so try not to be overwhelmed by the amount of material. Use the contents and the
</p>
<p>indices at the back to &#12;nd the information you need. If you are following a one-semester
</p>
<p>UNIX course, you should probably concentrate on the following:
</p>
<p>&#15; The remainder of this introduction
</p>
<p>&#15; The detailed knowledge of the C shell
</p>
<p>&#15; An appreciation of the Bourne shell
</p>
<p>&#15; A detailed knowledge of Perl, guided by chapter 6. This chapter provides pointers on
</p>
<p>how to get started in perl. It is not a substitute for the perl book.
</p>
<p>&#15; Everything in chapter 7 about C programming. This chapter is written in note form,
</p>
<p>since it is assumed that you know a lot about C programming already.
</p>
<p>&#15; A sound appreciation of chapter 8 on network programming.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>8 The unix programming environment
</p>
<p>The only way to learn UNIX is to sit down and try it. As with any new thing, it is a
</p>
<p>pain to get started, but once you are started, you will probably come to agree that UNIX
</p>
<p>contains a wealth of possibilities, perhaps more than you had ever though was possible or
</p>
<p>useful!
</p>
<p>One of the advantages of the UNIX system is that the entire UNIX manual is available
</p>
<p>on-line. You should get used to looking for information in the online manual pages. For
</p>
<p>instance, suppose you do not remember how to create a new directory, you could do the
</p>
<p>following:
</p>
<p>nexus% man -k dir
</p>
<p>dir ls (1) - list contents of directories
</p>
<p>dirname dirname (1) - strip non-directory suffix from file name
</p>
<p>dirs bash (1) - bash built-in commands, see bash(1)
</p>
<p>find find (1) - search for files in a directory hierarchy
</p>
<p>ls ls (1) - list contents of directories
</p>
<p>mkdir mkdir (1) - make directories
</p>
<p>pwd pwd (1) - print name of current/working directory
</p>
<p>rmdir rmdir (1) - remove empty directories
</p>
<p>The `man -k' command looks for a keyword in the manual and lists all the references it &#12;nds.
</p>
<p>The command `apropos' is completely equivalent to `man -k'. Having discovered that the
</p>
<p>command to create a directory is `mkdir' you can now look up the speci&#12;c manaul page on
</p>
<p>`mkdir' to &#12;nd out how to use it:
</p>
<p>man mkdir
</p>
<p>Some but no all of the UNIX commands also have a help option which is activated with the
</p>
<p>`-h' or `--help' command-line option.
</p>
<p>dax% mkdir --help
</p>
<p>Usage: mkdir [OPTION] DIRECTORY...
</p>
<p>-p, --parents no error if existing, make parent directories as needed
</p>
<p>-m, --mode=MODE set permission mode (as in chmod), not 0777 - umask
</p>
<p>--help display this help and exit
</p>
<p>--version output version information and exit
</p>
<p>dax%
</p>
<p>1.4 NEVER-DO's in UNIX
</p>
<p>There are some things that you should never do in UNIX. Some of these will cause you
</p>
<p>more serious problems than others. You can make your own list as you discover more.
</p>
<p>&#15; You should NEVER EVER switch o&#11; the power on a Unix computer unless you know
</p>
<p>what you are doing. A Unix machine is not like a PC running DOS. Even when you
</p>
<p>are not doing anything, the system is working in the background. If you switch o&#11; the
</p>
<p>power, you could interrupt the system while it is writing to the disk drive and destroy
</p>
<p>your disk. You must also remember that several users might be using the system even
</p>
<p>though you cannot see them: they do not have to be sitting at the machine, they could
</p>
<p>be logged in over the network. If you switch o&#11; the power, you might ruin their valuable
</p>
<p>work.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 1: Overview 9
</p>
<p>&#15; Once you have deleted a UNIX &#12;le using rm it is impossible to recover it! Don't use
</p>
<p>wildcards with rm without thinking quite carefully about what you are doing! It has
</p>
<p>happened to very many users throughout the history of UNIX that one tries to type
</p>
<p>rm *~
</p>
<p>but instead, by a slip of the hand, one writes
</p>
<p>rm * ~
</p>
<p>Unix then takes these wildcards in turn, so that the &#12;rst command is rm * which deletes
</p>
<p>all of your &#12;les! BE CAREFUL!
</p>
<p>&#15; Don't ever call a program or an important &#12;le `core'. Many scripts go around deleting
</p>
<p>&#12;les called `core' because the, when a program crashes, UNIX dumps the entire kernel
</p>
<p>image to a &#12;le called `core' and these &#12;les use up a lot of disk space. If you call a &#12;le
</p>
<p>`core' it might get deleted!
</p>
<p>&#15; Don't call test programs test. There is a UNIX command which is already called
</p>
<p>test and chances are that when you try to run your program you will start the UNIX
</p>
<p>command instead. This can cause a lot of confusion because the UNIX command
</p>
<p>doesn't seem to do very much at all!
</p>
<p>1.5 What you should know before starting
</p>
<p>1.5.1 One library: several interfaces
</p>
<p>The core of unix is the library of functions (written in C) which access the system.
</p>
<p>Everything you do on a unix system goes through this set of functions. However, you can
</p>
<p>choose your own interface to these library functions. Unix has very many di&#11;erent interfaces
</p>
<p>to its libraries in the form of languages and command interpreters.
</p>
<p>You can use the functions directly in C, or you can use command programs like `ls',
</p>
<p>`cd' etc. These functions just provide a simple user interface to the C calls. You can also
</p>
<p>use a variety of `script' languages: C-shell, Bourne shell, Perl, Tcl, scheme. You choose the
</p>
<p>interface which solves your problem most easily.
</p>
<p>1.5.2 Unix commands are &#12;les
</p>
<p>With the exception of a few simple commands which are built into the command inter-
</p>
<p>preter (shell), all unix commands and programs consist of executable &#12;les. In other words,
</p>
<p>there is a separate executable &#12;le for each command. This makes it extremely simple to
</p>
<p>add new commands to the system. One simply makes a program with the desired name
</p>
<p>and places it in the appropriate directory.
</p>
<p>Unix commands live in special directories (usually called bin for binary &#12;les). The
</p>
<p>location of these directories is recorded in a variable called path or PATH which is used by
</p>
<p>the system to search for binaries. We shall return to this in more detail in later chapters.
</p>
<p>1.5.3 Kernel and Shell
</p>
<p>Since users cannot command the kernel directly, UNIX has a command language known
</p>
<p>as the shell. The word shell implies a layer around the kernel. A shell is a user interface,
</p>
<p>or command interpreter.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>10 The unix programming environment
</p>
<p>There are two main versions of the shell, plus a number of enhancements.
</p>
<p>/bin/sh The Bourne Shell. The shell is most often used for writing system scripts. It is
</p>
<p>part of the original unix system.
</p>
<p>/bin/csh The C-shell. This was added to unix by the Berkeley workers. The commands
</p>
<p>and syntax resemble C code. C-shell is better suited for interactive work than
</p>
<p>the Bourne shell.
</p>
<p>The program tcsh is a public-domain enhancement of the csh and is in common use.
</p>
<p>Two improved versions of the Bourne shell also exist: ksh, the Korn shell and bash, the
</p>
<p>Bourne-again shell.
</p>
<p>Although the shells are mainly tools for typing in commands (which are excutable &#12;les
</p>
<p>to be loaded and run), they contain features such as aliases, a command history, wildcard-
</p>
<p>expansions and job control functions which provide a comfortable user environment.
</p>
<p>1.5.4 The role of C
</p>
<p>Most of the unix kernel and daemons are written in the C programming language
</p>
<p>1
</p>
<p>. Calls
</p>
<p>to the kernel and to services are made through functions in the standard C library. The
</p>
<p>commands like chmod, mkdir and cd are all C functions. The binary &#12;les of the same name
</p>
<p>/bin/chmod, /bin/mkdir etc. are just trivial &quot;wrapper&quot; programs for these C functions.
</p>
<p>Until Solaris 2, the C compiler was a standard part of the UNIX operating system, thus
</p>
<p>C is the most natural language to program in in a UNIX environment. Some tools are
</p>
<p>provided for C programmers:
</p>
<p>dbx A symbolic debugger. Also gdb, xxgdb ddd.
</p>
<p>make A development tool for compiling large programs.
</p>
<p>lex A `lexer'. A program which generates C code to recognize words of text.
</p>
<p>yacc A `parser'. This is a tool which generates C code for checking the syntax of
</p>
<p>groups of textual words.
</p>
<p>rpcgen A protocol compiler which generates C code from a higher level langauge, for
</p>
<p>programming RPC applications.
</p>
<p>1.5.5 Stdin, stdout, stderr
</p>
<p>Unix has three logical streams or &#12;les which are always open and are available to any
</p>
<p>program.
</p>
<p>stdin The standard input - &#12;le descriptor 0.
</p>
<p>stdout The standard output - &#12;le descriptor 1.
</p>
<p>stderr The standard error - &#12;le descriptor 2.
</p>
<p>The names are a part of the C language and are de&#12;ned as pointers of type FILE.
</p>
<p>1
</p>
<p>In particular they are written in Kernighan and Ritchie C, not the newer ANSI standard
</p>
<p>C.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 1: Overview 11
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>/* FILE *stdin, *stdout, *stderr; */
</p>
<p>fprintf(stderr,&quot;This is an error message!\n&quot;);
</p>
<p>The names are `logical' in the sense that they do not refer to a particular device, or a
</p>
<p>particular place for information to come from or go. Their role is analogous to the `.' and
</p>
<p>`..' directories in the &#12;lesystem. Programs can write to these &#12;les without worrying about
</p>
<p>where the information comes from or goes to. The user can personally de&#12;ne these places
</p>
<p>by redirecting standard I/O. This is discussed in the next chapter.
</p>
<p>A separate stream is kept for error messages so that error output does not get mixed up
</p>
<p>with a program's intended output.
</p>
<p>1.6 The superuser (root) and nobody
</p>
<p>When logged onto a UNIX system directly, the user whose name is root has unlimited
</p>
<p>access to the &#12;les on the system. root can also become any other user without having to
</p>
<p>give a password. root is reserved for the system administrator or trusted users.
</p>
<p>Certain commands are forbidden to normal users. For example, a regular user should
</p>
<p>not be able to halt the system, or change the ownership of &#12;les (see next paragraph). These
</p>
<p>things are reserved for the root or superuser.
</p>
<p>In a networked environment, root has no automatic authority on remote machines. This
</p>
<p>is to prevent the system administrator of one machine in Canada from being able to edit
</p>
<p>&#12;les on another in China. He or she must log in directly and supply a password in order to
</p>
<p>gain access privileges. On a network where &#12;les are often accessible in principle to anyone,
</p>
<p>the username root gets mapped to the user nobody, who has no rights at all.
</p>
<p>1.7 The &#12;le hierarchy
</p>
<p>Unix has a hierachical &#12;lesystem, which makes use of directories and sub-directories to
</p>
<p>form a tree. The root of the tree is called the root &#12;lesystem or `/'. Although the details of
</p>
<p>where every &#12;le is located di&#11;er for di&#11;erent versions of unix, some basic features are the
</p>
<p>same. The main sub-directories of the root directory together with the most important &#12;le
</p>
<p>are shown in the &#12;gure. Their contents are as follows.
</p>
<p>`/bin' Executable (binary) programs. On most systems this is a separate directory to
</p>
<p>/usr/bin. In SunOS, this is a pointer (link) to /usr/bin.
</p>
<p>`/etc' Miscellaneous programs and con&#12;guration &#12;les. This directory has become very
</p>
<p>messy over the history of UNIX and has become a dumping ground for almost
</p>
<p>anything. Recent versions of unix have begun to tidy up this directory by
</p>
<p>creating subdirectories `/etc/mail', `/etc/services' etc!
</p>
<p>`/usr' This contains the main meat of UNIX. This is where application software lives,
</p>
<p>together with all of the basic libraries used by the OS.
</p>
<p>`/usr/bin'
</p>
<p>More executables from the OS.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>12 The unix programming environment
</p>
<p>`/usr/local'
</p>
<p>This is where users' custom software is normally added.
</p>
<p>`/sbin' A special area for statically linked system binaries. They are placed here to
</p>
<p>distinguish commands used solely by the system administrator from user com-
</p>
<p>mands and so that they lie on the system root partition where they are guar-
</p>
<p>anteed to be accessible during booting.
</p>
<p>`/sys' This holds the con&#12;guration data which go to build the system kernel. (See
</p>
<p>below.)
</p>
<p>`/export'
</p>
<p>Network servers only use this. This contains the disk space set aside for client
</p>
<p>machines which do not have their own disks. It is like a `virtual disk' for diskless
</p>
<p>clients.
</p>
<p>`/dev, /devices'
</p>
<p>A place where all the `logical devices' are collected. These are called `device
</p>
<p>nodes' in unix and are created by mknod. Logical devices are UNIX's o&#14;cial
</p>
<p>entry points for writing to devices. For instance, /dev/console is a route to the
</p>
<p>system console, while /dev/kmem is a route for reading kernel memory. Device
</p>
<p>nodes enable devices to be treated as though they were &#12;les.
</p>
<p>`/home'
</p>
<p>(Called /users on some systems.) Each user has a separate login directory where
</p>
<p>&#12;les can be kept. These are normally stored under /home by some convention
</p>
<p>decided by the system administrator.
</p>
<p>`/var' System 5 and mixed systems have a separate directory for spooling. Under old
</p>
<p>BSD systems, /usr/spool contains spool queues and system data. /var/spool
</p>
<p>and /var/adm etc are used for holding queues and system log &#12;les.
</p>
<p>`/vmunix' This is the program code for the unix kernel (see below). On HPUX systems
</p>
<p>with &#12;le is called `hp-ux'. On linux it is called `linux'.
</p>
<p>`/kernel' On newer systems the kernel is built up from a number of modules which are
</p>
<p>placed in this directory.
</p>
<p>Every unix directory contains two `virtual' directories marked by a single dot and two dots.
</p>
<p>ls -a
</p>
<p>. ..
</p>
<p>The single dot represents the directory one is already in (the current directory). The double
</p>
<p>dots mean the directory one level up the tree from the current location. Thus, if one writes
</p>
<p>cd /usr/local
</p>
<p>cd ..
</p>
<p>the &#12;nal directory is /usr. The single dot is very useful in C programming if one wishes to
</p>
<p>read `the current directory'. Since this is always called `.' there is no need to keep track of
</p>
<p>what the current directory really is.
</p>
<p>`.' and `..' are `hard links' to the true directories.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 1: Overview 13
</p>
<p>1.8 Symbolic links
</p>
<p>A symbolic link is a pointer or an alias to another &#12;le. The command
</p>
<p>ln -s fromfile /other/directory/tolink
</p>
<p>makes the &#12;le fromfile appear to exist at /other/directory/tolink simultaneously. The
</p>
<p>&#12;le is not copied, it merely appears to be a part of the &#12;le tree in two places. Symbolic
</p>
<p>links can be made to both &#12;les and directories.
</p>
<p>A symbolic link is just a small &#12;le which contains the name of the real &#12;le one is interested
</p>
<p>in. It cannot be opened like an ordinary &#12;le, but may be read with the C call readlink()
</p>
<p>See Section 9.8.3 [lstat and readlink], page 127. If we remove the &#12;le a symbolic link points
</p>
<p>to, the link remains { it just points nowhere.
</p>
<p>1.9 Hard links
</p>
<p>A hard link is a duplicate inode in the &#12;lesystem which is in every way equivalent to the
</p>
<p>original &#12;le inode. If a &#12;le is pointed to by a hard link, it cannot be removed until the link
</p>
<p>is removed. If a &#12;le has n hard links { all of them must be removed before the &#12;le can be
</p>
<p>removed. The number of hard links to a &#12;le is stored in the &#12;lesystem index node for the
</p>
<p>&#12;le.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>14 The unix programming environment</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 2: Getting started 15
</p>
<p>2 Getting started
</p>
<p>If you have never met unix, or another multiuser system before, then you might &#12;nd the
</p>
<p>idea daunting. There are several things you should know.
</p>
<p>2.1 Logging in
</p>
<p>Each time you use unix you must log on to the system by typing a username and a
</p>
<p>password. Your login name is sometimes called an `account' because some unix systems
</p>
<p>implement strict quotas for computer resources which have to be paid for with real money
</p>
<p>1
</p>
<p>.
</p>
<p>&#11; &#8;
</p>
<p>login: mark
</p>
<p>password:
</p>
<p>&#10; &#9;
</p>
<p>Once you have typed in your password, you are `logged on'. What happens then depends
</p>
<p>on what kind of system you are logged onto and how. If you have a colour monitor and
</p>
<p>keyboard in front of you, with a graphical user interface, you will see a number of windows
</p>
<p>appear, perhaps a menu bar. You then use a mouse and keyboard just like any other system.
</p>
<p>This is not the only way to log onto unix. You can also log in remotely, from another
</p>
<p>machine, using the telnet or rlogin programs. If you use these programs, you will normally
</p>
<p>only get a text or command line interface (though graphics can still be arranged).
</p>
<p>Once you have logged in, a short message will be printed (called Message of the Day
</p>
<p>or motd) and you will see the C-shell prompt: the name of the host you are logged onto
</p>
<p>followed by a percent sign, e.g.
</p>
<p>&#11; &#8;
</p>
<p>SunOS Release 5.5 Version Generic [UNIX(R) System V Release 4.0]
</p>
<p>Copyright (c) 1983-1995, Sun Microsystems, Inc.
</p>
<p>Please report problems to sysadm@iu.hioslo.no
</p>
<p>dax%
</p>
<p>&#10; &#9;
</p>
<p>Remember that every unix machine is a separate entity: it is not like logging onto a PC
</p>
<p>system where you log onto the `network' i.e. the PC &#12;le server. Every unix machine is a
</p>
<p>server. The network, in unix-land, has lots of players.
</p>
<p>The &#12;rst thing you should do once you have logged on is to set a reliable password.
</p>
<p>A poor password might be okay on a PC which is not attached to a large network, but
</p>
<p>once you are attached to the internet, you have to remember that the whole world will be
</p>
<p>trying to crack your password. Don't think that no one will bother: some people really
</p>
<p>have nothing better to do. A password should not contain any word that could be in a
</p>
<p>list of words (in any language), or be a simple concatenation of a word and a number (e.g.
</p>
<p>1
</p>
<p>This is seldom true these days.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>16 The unix programming environment
</p>
<p>mark123). It takes seconds to crack such a password. Choose instead something which
</p>
<p>is easy to remember. Feel free to use the PIN number from your bankers card in your
</p>
<p>password! This will leave you with fewer things to remember. e.g. Ma9876rk). Passwords
</p>
<p>can be up to eight characters long.
</p>
<p>Some sites allow you to change your password anywhere. Other sites require you to log
</p>
<p>onto a special machine to change your password:
</p>
<p>&#11; &#8;
</p>
<p>dax%
</p>
<p>dax% passwd
</p>
<p>Change your password on host nexus
</p>
<p>You cannot change it here
</p>
<p>dax% rlogin nexus
</p>
<p>password: ******
</p>
<p>nexus% passwd
</p>
<p>Changing password for mark
</p>
<p>Enter login password: ********
</p>
<p>Enter new password: ********
</p>
<p>Reenter new passwd: ********
</p>
<p>&#10; &#9;
</p>
<p>You will be prompted for your old password and your new password twice. If your network
</p>
<p>is large, it might take the system up to an hour or two to register the change in your
</p>
<p>password, so don't forget the old one right away!
</p>
<p>2.2 Mouse buttons
</p>
<p>Unix has three mouse buttons. On some PC's running GNU/Linux or some other PC
</p>
<p>unix, there are only two, but the middle mouse button can be simulated by pressing both
</p>
<p>mouse buttons simultaneously. The mouse buttons have the following general functions.
</p>
<p>They may also have additional functions in special software.
</p>
<p>index &#12;nger
</p>
<p>This is used to select and click on objects. It is also used to mark out areas
</p>
<p>and copy by dragging. This is the button you normally use.
</p>
<p>middle &#12;nger
</p>
<p>Used to pull down menus. It is also used to paste a marked area somewhere at
</p>
<p>the mouse position.
</p>
<p>outer &#12;nger
</p>
<p>Pulls down menus.
</p>
<p>On a left-handed system right and left are reversed.
</p>
<p>2.3 E-mail
</p>
<p>Reading electronic mail on unix is just like any other system, but there are many pro-
</p>
<p>grams to choose from. There are very old programs from the seventies such as</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 2: Getting started 17
</p>
<p>mail
</p>
<p>and there are fully graphical mail programs such as
</p>
<p>tkrat
</p>
<p>mailtool
</p>
<p>Choose the program you like best. Not all of the programs support modern multimedia
</p>
<p>extensions because of their age. Some programs like tkrat have immediate mail noti&#12;cation
</p>
<p>alerts. To start a mail program you just type its name. If you have an icon-bar, you can
</p>
<p>click on the mail-icon.
</p>
<p>2.4 Simple commands
</p>
<p>Inexperienced computer users often prefer to use &#12;le-manager programs to avoid typing
</p>
<p>anything. With a mouse you can click your way through directories and &#12;les without having
</p>
<p>to type anything (e.g. the fmgr or tkdesk programs). More experienced users generally
</p>
<p>&#12;nd this to be slow and tedious after a while and prefer to use written commands. Unix
</p>
<p>has many short cuts and keyboard features which make typed commands extremely fast
</p>
<p>and much more powerful than use of the mouse.
</p>
<p>If you come from a DOS environment, the unix commands can be a little strange.
</p>
<p>Because they stem from an era when keyboards had to be hit with hammer force, and
</p>
<p>machines were very slow, the command names are generally as short as possible, so they
</p>
<p>seem pretty cryptic. Some familar ones which DOS borrowed from unix include,
</p>
<p>cd
</p>
<p>mkdir
</p>
<p>which change to a new directory and make a new directory respectively. To list the &#12;les in
</p>
<p>the current directory you use,
</p>
<p>ls
</p>
<p>To rename a &#12;le, you `move' it:
</p>
<p>mv old-name new-name
</p>
<p>2.5 Text editing and word processing
</p>
<p>Text editing is one of the things which people spend most time doing on any computer.
</p>
<p>It is important to distingiush text editing from word processing. On a PC or MacIntosh,
</p>
<p>you are perhaps used to Word or WordPerfect for writing documents.
</p>
<p>Unix has a Word-like program called lyx, but for the most part Unix users do not
</p>
<p>use word processors. It is more common in the unix community to write all documents,
</p>
<p>regardless of whether they are letters, books or computer programs, using a non-formatting
</p>
<p>text editor. (Unix word processors like Framemaker do exist, but they are very expensive.
</p>
<p>A version of MS-Word also exists for some unices.) Once you have written a document in
</p>
<p>a normal text editor, you call up a text formatter to make it pretty. You might think this
</p>
<p>strange, but the truth of the matter is that this two-stage process gives you the most power
</p>
<p>and &#13;exibilty|and that is what most unix folks like.
</p>
<p>For writing programs, or anything else, you edit a &#12;le by typing:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>18 The unix programming environment
</p>
<p>emacs myfile
</p>
<p>emacs is one of dozens of text-editors. It is not the simplest or most intuitive, but it is
</p>
<p>the most powerful and if you are going to spend time learning an editor, it wouldn't do
</p>
<p>any harm to make it this one. You could also click on emacs' icon if you are relying on a
</p>
<p>window system. Emacs is almost certainly the most powerful text editor that exists on any
</p>
<p>system. It is not a word-processor, it not for formatting printed documents, but it can be
</p>
<p>linked to almost any other program in order to format and print text. It contains a powerful
</p>
<p>programming language and has many intelligent features. We shall not go into the details
</p>
<p>of document formatting in this book, but only mention that programs like troff and Tex
</p>
<p>or Latex are used for this purpose to obtain typset-quality printing. Text formatting is an
</p>
<p>area where Unix folks do things di&#11;erently to PC folks.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 3: The login environment 19
</p>
<p>3 The login environment
</p>
<p>Unix began as a timesharing mainframe system in the seventies, when the only terminals
</p>
<p>available were text based teletype terminals or tty-s. Later, the Massachusetts Institute of
</p>
<p>Technology (MIT) developed the X-windows interface which is now a standard across UNIX
</p>
<p>platforms. Because of this history, the X-window system works as a front end to the standard
</p>
<p>UNIX shell and interface, so to understand the user environment we must &#12;rst understand
</p>
<p>the shell.
</p>
<p>3.1 Shells
</p>
<p>A shell is a command interpreter. In the early days of unix, a shell was the only way
</p>
<p>of issuing commands to the system. Nowadays many window-based application programs
</p>
<p>provide menus and buttons to perform simple commands, but the UNIX shell remains the
</p>
<p>most powerful and &#13;exible way of interacting with the system.
</p>
<p>After logging in and entering a password, the unix process init starts a shell for the user
</p>
<p>logging in. Unix has several di&#11;erent kinds of shell to choose from, so that each user can
</p>
<p>pick his/her favourite command interface. The type of shell which the system starts at login
</p>
<p>is determined by the user's entry in the passwd database. On most systems, the standard
</p>
<p>login shell is a variant of the C-shell.
</p>
<p>Shells provide facilities and commands which
</p>
<p>&#15; Start and stop processes (programs)
</p>
<p>&#15; Allow two processes to communicate through a pipe
</p>
<p>&#15; Allow the user to redirect the &#13;ow of input or output
</p>
<p>&#15; Allow simple command line editing and command history
</p>
<p>&#15; De&#12;ne aliases to frequently used commands
</p>
<p>&#15; De&#12;ne global &quot;environment&quot; variables which are used to con&#12;gure the default behaviour
</p>
<p>of a variety of programs. These lie in an &quot;associated array&quot; for each process and may
</p>
<p>be seen with the `env' command. Environment variables are inherited by all processes
</p>
<p>which are started from a shell.
</p>
<p>&#15; Provide wildcard expansion (joker notation) of &#12;lenames using `*,?,[]'
</p>
<p>&#15; Provide a simple script language, with tests and loops, so that users can combine system
</p>
<p>programs to create new programs of their own.
</p>
<p>&#15; Change and remember the location of the current working directory, or location within
</p>
<p>the &#12;le hierarchy.
</p>
<p>The shell does not contain any more speci&#12;c functions|all other commands, such as
</p>
<p>programs which list &#12;les or create directories etc., are executable programs which are in-
</p>
<p>dependent of the shell. When you type `ls', the shell looks for the executable &#12;le called
</p>
<p>`ls' in a special list of directories called the command path and attempts to start this pro-
</p>
<p>gram. This allows such programs to be developed and replaced independently of the actual
</p>
<p>command interpreter.
</p>
<p>Each shell which is started can be customized and con&#12;gured by editing a setup &#12;le.
</p>
<p>For the C-shell and its variants this &#12;le is called `.cshrc', and for the Bourne shell and
</p>
<p>its variants it is called `.profile'. (Note that &#12;les which begin with leading dots are</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>20 The unix programming environment
</p>
<p>not normally visible with the `ls' command. Use `ls -a' to view these.) Any commands
</p>
<p>which are placed in these &#12;les are interpreted by the shell before the &#12;rst command prompt
</p>
<p>is issued. These &#12;les are typically used to de&#12;ne a command search path and terminal
</p>
<p>characteristics.
</p>
<p>On each new command line you can use the cursor keys to edit the line. The up-arrow
</p>
<p>browses back through earlier commands. CTRL-a takes you to the start of the line. CTRL-e
</p>
<p>takes you to the end of the line. The
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>can be used to save typing with the `completion'
</p>
<p>facility See Section 5.7 [Command/&#12;lename completion], page 46.
</p>
<p>3.1.1 Shell commands generally
</p>
<p>Shell commands are commands like cp, mv, passwd, cat, more, less, cc, grep, ps etc..
</p>
<p>Very few commands are actually built into the shell command line interpreter, in the
</p>
<p>way that they are in DOS { commands are mostly programs which exist as &#12;les. When we
</p>
<p>type a command, the shell searches for a program with the same name and tries to execute
</p>
<p>it. The &#12;le must be executable, or a Command not found error will result. To see what
</p>
<p>actually happens when you type a command like gcc, try typing in the following C-shell
</p>
<p>commands directly into a C-shell. (We shall discuss these commands soon.)
</p>
<p>foreach dir ( $path ) # for every directory in the list path
</p>
<p>if ( -x $dir/gcc ) then # if the file is executable
</p>
<p>echo Found $dir/gcc # Print message found!
</p>
<p>break # break out of loop
</p>
<p>else
</p>
<p>echo Searching $dir/gcc
</p>
<p>endif
</p>
<p>end
</p>
<p>The output of this command is something like
</p>
<p>Searching /usr/lang/gcc
</p>
<p>Searching /usr/openwin/bin/gcc
</p>
<p>Searching /usr/openwin/bin/xview/gcc
</p>
<p>Searching /physics/lib/framemaker/bin/gcc
</p>
<p>Searching /physics/motif/bin/gcc
</p>
<p>Searching /physics/mutils/bin/gcc
</p>
<p>Searching /physics/common/scripts/gcc
</p>
<p>Found /physics/bin/gcc
</p>
<p>If you type
</p>
<p>echo $path
</p>
<p>you will see the entire list of directories which are searched by the shell. If we had left
</p>
<p>out the `break' command, we might have discovered that UNIX often has several programs
</p>
<p>with the same name, in di&#11;erent directories! For example,
</p>
<p>/bin/mail
</p>
<p>/usr/ucb/mail
</p>
<p>/bin/Mail
</p>
<p>/bin/make
</p>
<p>/usr/local/bin/make.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 3: The login environment 21
</p>
<p>Also, di&#11;erent versions of unix have di&#11;erent conventions for placing the commands in
</p>
<p>directories, so the path list needs to be di&#11;erent for di&#11;erent types of unix machine. In the
</p>
<p>C-shell a few basic commands like cd and kill are built into the shell (as in DOS).
</p>
<p>You can &#12;nd out which directory a command is stored in using the
</p>
<p>which
</p>
<p>command. For example
</p>
<p>nexus% which cd
</p>
<p>cd: shell built-in command.
</p>
<p>nexus% which cp
</p>
<p>/bin/cp
</p>
<p>nexus%
</p>
<p>which only searches the directories in $path and quits after the &#12;rst match, so if there
</p>
<p>are several commands with the same name, you will only see the &#12;rst of them using which.
</p>
<p>Finally, in the C-shell, the which command is built in. In the Bourne shell it is a
</p>
<p>program:
</p>
<p>nexus% which which
</p>
<p>which: shell built-in command.
</p>
<p>nexus% sh
</p>
<p>$ which which
</p>
<p>/bin/which
</p>
<p>$ exit
</p>
<p>nexus%
</p>
<p>Take a look at the script /usr/ucb/which. It is a script written in the C-shell.
</p>
<p>3.1.2 Environment and shell variables
</p>
<p>Environment variables are variables which the shell keeps. They are normally used to
</p>
<p>con&#12;gure the behaviour of utility programs like lpr (which sends a &#12;le to the printer) and
</p>
<p>mail (which reads and sends mail) so that special options do not have to be typed in every
</p>
<p>time you run these programs.
</p>
<p>Any program can read these variables to &#12;nd out how you have con&#12;gured your working
</p>
<p>environment. We shall meet these variables frequently. Here are some important variables
</p>
<p>PATH # The search path for shell commands (sh)
</p>
<p>TERM # The terminal type (sh and csh)
</p>
<p>DISPLAY # X11 - the name of your display
</p>
<p>LD_LIBRARY_PATH # Path to search for object and shared libraries
</p>
<p>HOST # Name of this unix host
</p>
<p>PRINTER # Default printer (lpr)
</p>
<p>HOME # The path to your home directory (sh)
</p>
<p>path # The search path for shell commands (csh)
</p>
<p>term # The terminal type (csh)
</p>
<p>noclobber # See below under redirection
</p>
<p>prompt # The default prompt for csh
</p>
<p>home # The path to your home directory (csh)</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>22 The unix programming environment
</p>
<p>These variables fall into two groups. Traditionally the &#12;rst group always have names
</p>
<p>in uppercase letters and are called environment variables, whereas variables in the second
</p>
<p>group have names with lowercase letters and are called shell variables{ but this is only a
</p>
<p>convention. The uppercase variables are global variables, whereas the lower case variables
</p>
<p>are local variables. Local variables are not de&#12;ned for programs or sub-shells started by the
</p>
<p>current shell, while global variables are inherited by all sub-shells.
</p>
<p>The Bourne-shell and the C-shell use these conventions di&#11;erently and not always con-
</p>
<p>sistently. You will see how to de&#12;ne these below. For now you just have to know that you
</p>
<p>can use the following commands from the C-shell to list these variables. The command env
</p>
<p>can be used in either C-shell or Bourne shell to see all of the de&#12;ned environment variables.
</p>
<p>3.1.3 Wildcards
</p>
<p>Sometimes you want to be able to refer to several &#12;les in one go. For instance, you
</p>
<p>might want to copy all &#12;les ending in `.c' to a new directory. To do this one uses wildcards.
</p>
<p>Wildcards are characters like * ? which stand for any character or group of characters. In
</p>
<p>card games the joker is a `wild card' which can be substituted for any other card. Use of
</p>
<p>wildcards is also called &#12;lename substitution in the unix manuals, in the sections on sh and
</p>
<p>csh.
</p>
<p>The wildcard symbols are,
</p>
<p>`?' Match single character. e.g. ls /etc/rc.????
</p>
<p>`*' Match any number of characters. e.g. ls /etc/rc.*
</p>
<p>`[...]' Match any character in a list enclosed by these brackets. e.g. ls [abc].C
</p>
<p>Here are some examples and explanations.
</p>
<p>`/etc/rc.????'
</p>
<p>Match all &#12;les in /etc whose &#12;rst three characters are rc. and are 7 characters
</p>
<p>long.
</p>
<p>`*.c' Match all &#12;les ending in `.c' i.e. all C programs.
</p>
<p>`*.[Cc]' List all &#12;les ending on `.c' or `.C' i.e. all C and C++ programs.
</p>
<p>`*.[a-z]' Match any &#12;le ending in .a, .b, .c, ... up to .z etc.
</p>
<p>It is important to understand that the shell expands wildcards. When you type a command,
</p>
<p>the program is not invoked with an argument that contains * or ?. The shell expands the
</p>
<p>special characters &#12;rst and invokes commands with the entire list of &#12;les which match the
</p>
<p>patterns. The programs never see the wildcard characters, only the list of &#12;les they stand
</p>
<p>for. To see this in action, you can type
</p>
<p>echo /etc/rc.*
</p>
<p>which gives
</p>
<p>/etc/rc /etc/rc.boot /etc/rc.ip /etc/rc.local /etc/rc.local%
</p>
<p>/etc/rc.local~ /etc/rc.single /etc/rc~</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 3: The login environment 23
</p>
<p>All shell commands are invoked with a command line of this form. This has an important
</p>
<p>corollary. It means that multiple renaming cannot work !
</p>
<p>Unix &#12;les are renamed using the mv command. In many microcomputer operating sys-
</p>
<p>tems one can write
</p>
<p>rename *.x *.y
</p>
<p>which changes the &#12;le extension of all &#12;les ending in `.x' to the same name with a `.y'
</p>
<p>extension. This cannot work in unix, because the shell tries expands everything before
</p>
<p>passing the arguments to the command line.
</p>
<p>The local shell variable noglob switches o&#11; wildcard expansion in the C shell, but you
</p>
<p>still cannot rename multiple &#12;les using mv. Some free-software programs make this possible.
</p>
<p>3.1.4 Regular expressions
</p>
<p>The wildcards belong to the shell. They are used for matching &#12;lenames. UNIX has
</p>
<p>a more general and widely used mechanism for matching strings, this is through regular
</p>
<p>expressions.
</p>
<p>Regular expressions are used by the egrep utility, text editors like ed, vi and emacs
</p>
<p>and sed and awk. They are also used in the C programming language for matching input
</p>
<p>as well as in the Perl programming language and lex tokenizer. Here are some examples
</p>
<p>using the egrep command which print lines from the &#12;le /etc/rc which match certain
</p>
<p>conditions. The contruction is part of egrep. Everything in between these symbols is
</p>
<p>a regular expression. Notice that special shell symbols ! * &amp; have to be preceded with a
</p>
<p>backslash \ in order to prevent the shell from expanding them!
</p>
<p># Print all lines beginning with a comment #
</p>
<p>egrep '(^#)' /etc/rc
</p>
<p># Print all lines which DON'T begin with #
</p>
<p>egrep '(^[^#])' /etc/rc
</p>
<p># Print all lines beginning with e, f or g.
</p>
<p>egrep '(^[efg])' /etc/rc
</p>
<p># Print all lines beginning with uppercase
</p>
<p>egrep '(^[A-Z])' /etc/rc
</p>
<p># Print all lines NOT beginning with uppercase
</p>
<p>egrep '(^[^A-Z])' /etc/rc
</p>
<p># Print all lines containing ! * &amp;
</p>
<p>egrep '([\!\*\&amp;])' /etc/rc</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>24 The unix programming environment
</p>
<p># All lines containing ! * &amp; but not starting #
</p>
<p>egrep '([^#][\!\*\&amp;])' /etc/rc
</p>
<p>Regular expressions are made up of the following `atoms'.
</p>
<p>These examples assume that the &#12;le `/etc/rc' exists. If it doesn't exist on the machine
</p>
<p>you are using, try to &#12;nd the equivalent by, for instance, replacing /etc/rc with /etc/rc*
</p>
<p>which will try to &#12;nd a match beginning with the rc.
</p>
<p>`.' Match any single character except the end of line.
</p>
<p>`^' Match the beginning of a line as the &#12;rst character.
</p>
<p>`$' Match end of line as last character.
</p>
<p>`[..]' Match any character in the list between the square brackets.(see below).
</p>
<p>`*' Match zero or more occurrances of the preceding expression.
</p>
<p>`+' Match one or more occurrences of the preceding expression.
</p>
<p>`?' Match zero or one occurrance of the preceding expression.
</p>
<p>You can &#12;nd a complete list in the unix manual pages. The square brackets above are
</p>
<p>used to de&#12;ne a class of characters to be matched. Here are some examples,
</p>
<p>&#15; If the square brackets contain a list of characters, $[a-z156]$ then a single occurrance
</p>
<p>of any character in the list will match the regular expression: in this case any lowercase
</p>
<p>letter or the numbers 1, 5 and 6.
</p>
<p>&#15; If the &#12;rst character in the brackets is the caret symbol `^' then any character except
</p>
<p>those in the list will be matched.
</p>
<p>&#15; Normally a dash or minus sign `-' means a range of characters. If it is the &#12;rst character
</p>
<p>after the `[' or after `[^' then it is treated literally.
</p>
<p>3.1.5 Nested shell commands and \
</p>
<p>The backwards apostrophes `...` can be used in all shells and also in the programming
</p>
<p>language Perl. When these are encountered in a string the shell tries to execute the com-
</p>
<p>mand inside the quotes and replace the quoted expression by the result of that command.
</p>
<p>For example:
</p>
<p>unix% echo &quot;This system's kernel type is `/bin/file /vmunix`&quot;
</p>
<p>This system's kernel type is /vmunix: sparc executable not stripped
</p>
<p>unix% foreach file ( `ls /etc/rc*` )
</p>
<p>? echo I found a config file $file
</p>
<p>? echo Its type is `/bin/file $file`
</p>
<p>? end
</p>
<p>I found a config file /etc/rc
</p>
<p>Its type is /etc/rc: executable shell script
</p>
<p>I found a config file /etc/rc.boot
</p>
<p>Its type is /etc/rc.boot: executable shell script</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 3: The login environment 25
</p>
<p>I found a config file /etc/rc.ip
</p>
<p>Its type is /etc/rc.ip: executable shell script
</p>
<p>I found a config file /etc/rc.local
</p>
<p>Its type is /etc/rc.local: ascii text
</p>
<p>I found a config file /etc/rc.local~
</p>
<p>Its type is /etc/rc.local~: ascii text
</p>
<p>I found a config file /etc/rc.single
</p>
<p>Its type is /etc/rc.single: executable shell script
</p>
<p>I found a config file /etc/rc~
</p>
<p>Its type is /etc/rc~: executable shell script
</p>
<p>This is how we insert the result of a shell command into a text string or variable.
</p>
<p>3.2 UNIX command overview
</p>
<p>3.2.1 Important keys
</p>
<p>h
</p>
<p>CTRL-A
</p>
<p>i
</p>
<p>Jump to start of line. If `screen' is active, this pre&#12;xes all control key com-
</p>
<p>mands for `screen' and then the normal CTRL-A is replaced by CTRL-a a.
</p>
<p>h
</p>
<p>CTRL-C
</p>
<p>i
</p>
<p>Interrupt or break key. Sends signal 15 to a process.
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>Signi&#12;es `EOF' (end of &#12;le) or shows expansion matches in command/&#12;lename
</p>
<p>completion See Section 5.7 [Command/&#12;lename completion], page 46.
</p>
<p>h
</p>
<p>CTRL-E
</p>
<p>i
</p>
<p>Jump to end of line.
</p>
<p>h
</p>
<p>CTRL-L
</p>
<p>i
</p>
<p>Clear screen in newer shells and in emacs. Same as `clear' in the shell.
</p>
<p>h
</p>
<p>CTRL-Z
</p>
<p>i
</p>
<p>Suspend the present process, but do not destroy it. This sends signal 18 to the
</p>
<p>process.
</p>
<p>3.2.2 Alternative shells
</p>
<p>bash The Bourne Again shell, an improved sh.
</p>
<p>csh The standard C-shell.
</p>
<p>jsh The same as sh, with C-shell style job control.
</p>
<p>ksh The Korn shell, an improved sh.
</p>
<p>sh The original Bourne shell.
</p>
<p>sh5 On ULTRIX systems the standard Bourne shell is quite stupid. sh5 corresponds
</p>
<p>to the normal Bourne shell on these systems.
</p>
<p>tcsh An improved C-shell.
</p>
<p>zsh An improved sh.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>26 The unix programming environment
</p>
<p>3.2.3 Window based terminal emulators
</p>
<p>xterm The standard X11 terminal window.
</p>
<p>shelltool, cmdtool
</p>
<p>Openwindows terminals from Sun Microsystems. These are not completely X11
</p>
<p>compatible during copy/paste operations.
</p>
<p>screen This is not a window in itself, but allows you to emulate having several windows
</p>
<p>inside a single (say) xterm window. The user can switch between di&#11;erent win-
</p>
<p>dows and open new ones, but can only see one window at a time See Section 3.5
</p>
<p>[Multiple screens], page 34.
</p>
<p>3.2.4 Remote shells and logins
</p>
<p>rlogin Login onto a remote unix system.
</p>
<p>rsh Open a shell on a remote system (require access rights).
</p>
<p>telnet Open a connection to a remove system using the telnet protocol.
</p>
<p>3.2.5 Text editors
</p>
<p>ed An ancient line-editor.
</p>
<p>vi Visual interface to ed. This is the only &quot;standard&quot; unix text editor supplied by
</p>
<p>vendors.
</p>
<p>emacs The most powerful UNIX editor. A fully con&#12;gurable, user programmable
</p>
<p>editor which works under X11 and on tty-terminals.
</p>
<p>xemacs A pretty version of emacs for X11 windows.
</p>
<p>pico A tty-terminal only editor, comes as part of the PINE mail package.
</p>
<p>xedit A test X11-only editor supplied with X-windows.
</p>
<p>textedit A simple X11-only editor supplied by Sun Microsystems.
</p>
<p>3.2.6 File handling commands
</p>
<p>ls List &#12;les in speci&#12;ed directory (like dir on other systems).
</p>
<p>cp Copy &#12;les.
</p>
<p>mv Move or rename &#12;les.
</p>
<p>touch Creates an empty new &#12;le if none exists, or updates date and time stamps on
</p>
<p>existing &#12;les.
</p>
<p>rm, unlink
</p>
<p>Remove a &#12;le or link (delete).
</p>
<p>mkdir, rmdir
</p>
<p>Make or remove a directory. A directory must be empty in order to be able to
</p>
<p>remove it.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 3: The login environment 27
</p>
<p>cat Concatenate or join together a number of &#12;les. The output is written to the
</p>
<p>standard output by default. Can also be used to simply print a &#12;le on screen.
</p>
<p>lp, lpr Line printer. Send a &#12;le to the default printer, or the printer de&#12;ned in the
</p>
<p>`PRINTER' evironment variable.
</p>
<p>lpq, lpstat
</p>
<p>Show the status of the print queue.
</p>
<p>3.2.7 File browsing
</p>
<p>more Shows one screen full at a time. Possibility to search for a string and edit the
</p>
<p>&#12;le. This is like `type &#12;le | more' in DOS.
</p>
<p>less An enhanced version of more.
</p>
<p>mc Midnight commander, a free version of the `Norton Commander' PC utility for
</p>
<p>unix. (Only for non-serious UNIX users...)
</p>
<p>fmgr A window based &#12;le manager with icons and all that nonsense.
</p>
<p>3.2.8 Ownership and granting access permission
</p>
<p>chmod Change &#12;le access mode.
</p>
<p>chown, chgrp
</p>
<p>Change owner and group of a &#12;le. The GNU version of chown allows both these
</p>
<p>operations to be performed together using the syntax chown owner.group &#12;le.
</p>
<p>acl On newer Unices, Access control lists allow access to be granted on a per-user
</p>
<p>basis rather than by groups.
</p>
<p>3.2.9 Extracting from and rebuilding &#12;les
</p>
<p>cut Extract a column in a table
</p>
<p>paste Merge several &#12;les so that each &#12;le becomes a column in a table.
</p>
<p>sed A batch text-editor for searching, replacing and selecting text without human
</p>
<p>intervention.
</p>
<p>awk A prerunner to the Perl language, for extracting and modifying text&#12;les.
</p>
<p>rmcr Strip carriage return (ASCII 13) characters from a &#12;le. Useful for converting
</p>
<p>DOS &#12;les to unix.
</p>
<p>3.2.10 Locating &#12;les
</p>
<p>find Search for &#12;les from a speci&#12;ed directory using various criteria.
</p>
<p>locate Fast search in a global &#12;le database for &#12;les containing a search-string.
</p>
<p>whereis Look for a command and its documentation on the system.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>28 The unix programming environment
</p>
<p>3.2.11 Disk usage.
</p>
<p>du Show number of blocks used by a &#12;le or &#12;les.
</p>
<p>df Show the state of usage for one or more disk partitions.
</p>
<p>3.2.12 Show other users logged on
</p>
<p>users Simple list of other users.
</p>
<p>finger Show who is logged onto this and other systems.
</p>
<p>who List of users logged into this system.
</p>
<p>w Long list of who is logged onto this system and what they are doing.
</p>
<p>3.2.13 Contacting other users
</p>
<p>write Send a simple message to the named user, end with
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>. The command
</p>
<p>`mesg n' switches o&#11; messages receipt.
</p>
<p>talk Interactive two-way conversation with named user.
</p>
<p>irc Internet relay chat. A conferencing system for realtime multi-user conversa-
</p>
<p>tions, for addicts and losers.
</p>
<p>3.2.14 Mail senders/readers
</p>
<p>mail The standard (old) mail interface.
</p>
<p>Mail Another mail interface.
</p>
<p>elm Electronic Mail program. Lots of functionality but poor support for multimedia.
</p>
<p>pine Pine Is No-longer Elm. Improved support for multimedia but very slow and
</p>
<p>rather stupid at times. Some of the best features of elm have been removed!
</p>
<p>mailtool Sun's openwindows client program.
</p>
<p>rmail A mail interface built into the emacs editor.
</p>
<p>netscape mail
</p>
<p>A mail interface built into the netscape navigator.
</p>
<p>zmail A commerical mail package.
</p>
<p>tkrat A graphical mail reader which supports most MIME types, written in tcl/tk.
</p>
<p>This program has a nice feel and allows you to create a searchable database of
</p>
<p>old mail messages, but has a hopeless locking mechanism.
</p>
<p>3.2.15 File transfer
</p>
<p>ftp The File Transfer program - copies &#12;les to/from a remote host.
</p>
<p>ncftp An enhanced ftp for anonymous login.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 3: The login environment 29
</p>
<p>3.2.16 Compilers
</p>
<p>cc The C compiler.
</p>
<p>CC The C++ compiler.
</p>
<p>gcc The GNU C compiler.
</p>
<p>g++ The GNU C++ compiler.
</p>
<p>ld The system linker/loader.
</p>
<p>ar Archive library builder.
</p>
<p>dbx A symbolic debugger.
</p>
<p>gdb The GNU symbolic debugger.
</p>
<p>xxgdb The GNU debugger with a windown driven front-end.
</p>
<p>ddd A motif based front-end to the gdb debugger.
</p>
<p>3.2.17 Other interpreted languages
</p>
<p>perl Practical extraction an report language.
</p>
<p>tcl A perl-like language with special support for building user interfaces and com-
</p>
<p>mand shells.
</p>
<p>scheme A lisp-like extensible scripting language from GNU.
</p>
<p>mercury A prolog-like language for arti&#12;cial intelligence.
</p>
<p>3.2.18 Processes and system statistics
</p>
<p>ps List system process table.
</p>
<p>vmstat List kernel virtual-memory statistics.
</p>
<p>netstat List network connections and statistics.
</p>
<p>rpcinfo Show rpc information.
</p>
<p>showmount
</p>
<p>Show clients mounting local &#12;lesystems.
</p>
<p>3.2.19 System identity
</p>
<p>uname Display system name and operating system release.
</p>
<p>hostname Show the name of this host.
</p>
<p>domainname
</p>
<p>Show the name of the local NIS domain. Normally this is chosen to be the same
</p>
<p>as the BIND/DNS domain, but it need not be.
</p>
<p>nslookup Interrogate the DNS/BIND name service (hostname to IP address conversion).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>30 The unix programming environment
</p>
<p>3.2.20 Internet resources
</p>
<p>archie, xarchie
</p>
<p>Search the internet ftp database for &#12;les.
</p>
<p>xrn, fnews
</p>
<p>Read news (browser).
</p>
<p>netscape, xmosaic
</p>
<p>Read world wide web (WWW) (browser).
</p>
<p>3.2.21 Text formatting and postscript
</p>
<p>tex, latex
</p>
<p>Donald Knuth's text formatting language, pronounced &quot;tek&quot; (the x is really a
</p>
<p>greek &quot;chi&quot;). Used widely for technical publications. Compiles to dvi (device
</p>
<p>independent) &#12;le format.
</p>
<p>texinfo A hypertext documentation system using tex and &quot;info&quot; format. This is the
</p>
<p>GNU documentation system. This UNIX guide is written in texinfo!!!
</p>
<p>xdvi View a tex dvi &#12;le on screen.
</p>
<p>dvips Convert dvi format into postscript.
</p>
<p>ghostview, ghostscript
</p>
<p>View a postscript &#12;le on screen.
</p>
<p>3.2.22 Picture editors and processors
</p>
<p>xv Handles, edits and processes pictures in a variety of standard graphics formats
</p>
<p>(gif, jpg, ti&#11; etc). Use xv -quit to place a picture on your root window.
</p>
<p>xpaint A simple paint program.
</p>
<p>xfig A line drawing &#12;gure editor. Produces postscript, tex, and a variety of other
</p>
<p>output formats.
</p>
<p>xsetroot Load an X-bitmap image into the screen (root window) background. Small
</p>
<p>images are tiled.
</p>
<p>3.2.23 Miscellaneous
</p>
<p>date Print the date and time.
</p>
<p>ispell Spelling checker.
</p>
<p>xcalc A graphical calculator.
</p>
<p>dc,bc Text-based calculators.
</p>
<p>xclock A clock!
</p>
<p>ping Send a &quot;sonar&quot; ping to see if another unix host is alive.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 3: The login environment 31
</p>
<p>3.3 Terminals
</p>
<p>In order to communicate with a user, a shell needs to have access to a terminal. Unix was
</p>
<p>designed to work with many di&#11;erent kinds of terminals. Input/output commands in Unix
</p>
<p>read and write to a virtual terminal. In reality a terminal might be a text-based Teletype
</p>
<p>terminal (called a tty for short) or a graphics based terminal; it might be 80-characters
</p>
<p>wide or it might be wider or narrower. Unix take into account these possibility by de&#12;ning
</p>
<p>a number of instances of terminals in a more or less object oriented way.
</p>
<p>Each user's terminal has to be con&#12;gured before cursor based input/output will work
</p>
<p>correctly. Normally this is done by choosing one of a number of standard terminal types a
</p>
<p>list which is supplied by the system. In practice the user de&#12;nes the value of the environment
</p>
<p>variable `TERM' to an appropriate name. Typical examples are `vt100' and `xterm'. If no
</p>
<p>standard setup is found, the terminal can always be con&#12;gured manually using UNIX's most
</p>
<p>cryptic and opaque of commands: `stty'.
</p>
<p>The job of con&#12;guring terminals is much easier now that hardware is more standard.
</p>
<p>Users' terminals are usually con&#12;gured centrally by the system administrator and it is
</p>
<p>seldom indeed that one ever has to choose anything other than `vt100' or `xterm'.
</p>
<p>3.4 The X window system
</p>
<p>Because UNIX originated before windowing technology was available, the user-interface
</p>
<p>was not designed with windowing in mind. The X window system attempts to be like a
</p>
<p>virtual machine park, running a di&#11;erent program in each window. Although the programs
</p>
<p>appear on one screen, they may in fact be running on unix systems anywhere in the world,
</p>
<p>with only the output being local to the user's display. The standard shell interface is
</p>
<p>available by running an X client application called `xterm' which is a graphical front-end
</p>
<p>to the standard UNIX textual interface.
</p>
<p>The `xterm' program provides a virtual terminal using the X windows graphical user
</p>
<p>interface. It works in exactly the same way as a tty terminal, except that standard graphical
</p>
<p>facilities like copy and paste are available. Moreover, the user has the convenience of being
</p>
<p>able to run a di&#11;erent shell in every window. For example, using the `rlogin' command,
</p>
<p>it is possible to work on the local system in one window, and on another remote system in
</p>
<p>another window. The X-window environment allows one to cut and paste between windows,
</p>
<p>regardless of which host the shell runs on.
</p>
<p>3.4.1 The components of the X-window system
</p>
<p>The X11 system is based on the client-server model. You might wonder why a window
</p>
<p>system would be based on a model which was introduced for interprocess communication,
</p>
<p>or network communication. The answer is straightforward.
</p>
<p>The designers of the X window system realized that network communication was to be
</p>
<p>the paradigm of the next generation of computer systems. They wanted to design a system
</p>
<p>of windows which would enable a user to sit at a terminal in Massachusetts and work on a
</p>
<p>machine in Tokyo { and still be able to get high quality windows displayed on their terminal.
</p>
<p>The aim of X windows from the beginning is to create a distributed window environment.
</p>
<p>When I log onto my friend's Hewlett Packard workstation to use the text editor (because
</p>
<p>I don't like the one on my EUNUCHS workstation) I want it to work correctly on my screen,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>32 The unix programming environment
</p>
<p>with my keyboard { even though my workstation is manufactured by a di&#11;erent company.
</p>
<p>I also want the colours to be right despite the fact that the HP machine uses a completely
</p>
<p>di&#11;erent video hardware to my machine. When I press the curly brace key {, I want to see
</p>
<p>a curly brace, and not some hieroglyphic because the HP station uses a di&#11;erent keyboard.
</p>
<p>These are the problems which X tries to address. In a network environment we need a
</p>
<p>common window system which will work on any kind of hardware, and hide the di&#11;erences
</p>
<p>between di&#11;erent machines as far as possible. But it has to be &#13;exible enough to allow
</p>
<p>us to change all of the things we don't like { to choose our own colours, and the kind
</p>
<p>of window borders we want etc. Other windowing systems (like Microsoft windows) ignore
</p>
<p>these problems and thereby lock the user to a single vendors products and a single operating
</p>
<p>system. (That, of course, is no accident.)
</p>
<p>The way X solves this problem is to use the client server model. Each program which
</p>
<p>wants to open a window on somebody's compute screen is a client of the X window service.
</p>
<p>To get something drawn on a user's screen, the client asks a server on the host of interest
</p>
<p>to draw windows for it. No client ever draws anything itself { it asks the server to do it on
</p>
<p>its behalf. There are several reasons for this:
</p>
<p>&#15; The clients can all talk a common `window language' or protocol. We can hide the
</p>
<p>di&#11;erence between di&#11;erent kinds of hardware by making the machine-speci&#12;c part
</p>
<p>of drawing graphics entirely a problem of implementing the server on the particular
</p>
<p>hardware. When a new type of hardware comes along, we just need to modify the
</p>
<p>server { none of the clients need to be modi&#12;ed.
</p>
<p>&#15; We can contact di&#11;erent servers and send our output to di&#11;erent hardware { thus even
</p>
<p>though a program is running on a CPU in Tokyo, it can ask the server in Massachusetts
</p>
<p>to display its window for it.
</p>
<p>&#15; When more than one window is on a user's display, it eventually becomes necessary to
</p>
<p>move the windows around and then &#12;gure out which windows are on top of which other
</p>
<p>windows etc. If all of the drawing information is kept in a server, it is straightforward
</p>
<p>to work out this information. If every client drew where it wanted to, it would be
</p>
<p>impossible to know which window was supposed to be on top of another.
</p>
<p>In X, the window manager is a di&#11;erent program to the server which does the drawing
</p>
<p>of graphics { but the client-server idea still applies, it just has one more piece to its puzzle.
</p>
<p>3.4.2 How to set up X windows
</p>
<p>The X windows system is large and complex and not particularly user friendly. When
</p>
<p>you log in to the system, X reads two &#12;les in your home directory which decide which
</p>
<p>applications will be started what they will look like. The &#12;les are called
</p>
<p>.Xsession This &#12;le is a shell script which starts up a number of applications as background
</p>
<p>processes and exits by calling a window manager. Here is a simple example &#12;le
</p>
<p>#!/bin/csh
</p>
<p>#
</p>
<p># .xsession file
</p>
<p>#
</p>
<p>#</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 3: The login environment 33
</p>
<p>setenv PATH /usr/bin:/bin:/local/gnu/bin:/usr/X11R6/bin
</p>
<p>#
</p>
<p># List applications here, with &amp; at the end
</p>
<p># so they run in the background
</p>
<p>#
</p>
<p>xterm -T NewTitle -sl 1000 -geometry 90x45+16+150 -sb &amp;
</p>
<p>xclock &amp;
</p>
<p>xbiff -geometry 80x80+510+0 &amp;
</p>
<p># Start a window manager. Exec replaces this script with
</p>
<p># the fvwm process, so that it doesn't exist as a separate
</p>
<p># (useless) process.
</p>
<p>exec /local/bin/fvwm
</p>
<p>.Xdefaults This &#12;le speci&#12;es all of the resources which X programs use. It can be used
</p>
<p>to change the colours used by applications, or font types etc. The subject of
</p>
<p>X-rescources is a large one and we don't have time for it here. Here is a simple
</p>
<p>example, which shows how you can make your over-bright xterm and emacs
</p>
<p>windows less bright grey shade.
</p>
<p>xterm*background: LightGrey
</p>
<p>Emacs*background: grey92
</p>
<p>Xemacs*background: grey92
</p>
<p>3.4.3 X displays and authority
</p>
<p>In the terminology used by X11, every client program has to contact a display in order to
</p>
<p>open a window. A display is a virtual screen which is created by the X server on a particular
</p>
<p>host. X can create several separate displays on a given host, though most machines only
</p>
<p>have one.
</p>
<p>When an X client program wants to open a window, it looks in the UNIX environment
</p>
<p>variable `DISPLAY' for the IP address of a host which has an X server it can contact. For
</p>
<p>example, if we wrote
</p>
<p>setenv DISPLAY myhost:0
</p>
<p>the client would try to contact the X server on `myhost' and ask for a window on display
</p>
<p>number zero (the usual display). If we wrote
</p>
<p>setenv DISPLAY 198.112.208.35:0
</p>
<p>the client would try to open display zero on the X server at the host with the IP address
</p>
<p>`198.112.208.35'.
</p>
<p>Clearly there must be some kind of security mechanism to prevent just anybody from
</p>
<p>opening windows on someone's display. X has two such mechanisms:
</p>
<p>xhost This mechanism is now obsolete. The `xhost' command is used to de&#12;ne a list
</p>
<p>of hosts which are allowed to open windows on the user's display. It cannot</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>34 The unix programming environment
</p>
<p>destinguish between individual users. i.e. the command xhost yourhost would
</p>
<p>allow anyone using yourhost to access the local display. This mechanism is only
</p>
<p>present for backward compatibility with early versions of X windows. Normally
</p>
<p>one should use the command xhost - to exclude all others from accessing the
</p>
<p>display.
</p>
<p>Xauthority
</p>
<p>The Xauthority mechanism has replaced the xhost scheme. It provides a secu-
</p>
<p>rity mechanism which can distinguish individual users, not just hosts. In order
</p>
<p>for a user to open a window on a display, he/she must have a ticket|called a
</p>
<p>&quot;magic cookie&quot;. This is a binary &#12;le called `.Xauthority' which is created in
</p>
<p>the user's home directory when he/she &#12;rst starts the X-windows system. Any-
</p>
<p>one who does not have a recent copy of this &#12;le cannot open windows or read
</p>
<p>the display of the user's terminal. This mechanism is based on the idea that the
</p>
<p>user's home directory is available via NFS on all hosts he/she will log onto, and
</p>
<p>thus the owner of the display will always have access to the magic cookie, and
</p>
<p>will therefore always be able to open windows on the display. Other users must
</p>
<p>obtain a copy of the &#12;le in order to open windows there. The command xauth
</p>
<p>is an interactive utility used for controlling the contents of the `.Xauthority'
</p>
<p>&#12;le. See the `xauth' manual page for more information.
</p>
<p>3.5 Multiple screens
</p>
<p>The window paradigm has been very successful in many ways, but anyone who has used
</p>
<p>a window system knows that the screen is simply not big enough for all the windows one
</p>
<p>would like! Unix has several solutions to this problem.
</p>
<p>One solution is to attach several physical screens to a terminal. The X window system
</p>
<p>can support any number of physical screens of di&#11;erent types. A graphical designer might
</p>
<p>want a high resolution colour screen for drawing and a black and white screen for writing
</p>
<p>text, for instance. The disadvantage with this method is the cost of the hardware.
</p>
<p>A cheaper solution is to use a window manager such as `fwvm' which creates a virtual
</p>
<p>screen of unlimited size on a single monitor. As the mouse pointer reaches the edge of the
</p>
<p>true screen, the window manager replaces the display with a new &quot;blank screen&quot; in which
</p>
<p>to place windows. A miniaturized image of the windows on a control panel acts as a map
</p>
<p>which makes it possible to &#12;nd the applications on the virtual screen.
</p>
<p>Yet another possibility is to create virtual displays inside a single window. In other
</p>
<p>words, one can collapse several shell windows into a single `xterm' window by running the
</p>
<p>program `screen'. The screen command allows you to start several shells in a single window
</p>
<p>(using
</p>
<p>h
</p>
<p>CTRL-a CTRL-c
</p>
<p>i
</p>
<p>) and to switch between them (by typing
</p>
<p>h
</p>
<p>CTRL-a CTRL-n
</p>
<p>i
</p>
<p>). It is only
</p>
<p>possible to see one shell window at a time, but it is still possible to cut and paste between
</p>
<p>windows and one has a considerable saving of space. The `screen' command also allows
</p>
<p>you to suspend a shell session, log out, log in again later and resume the session precisely
</p>
<p>where you left o&#11;.
</p>
<p>Here is a summary of some useful screen commands:
</p>
<p>screen Start the screen server.
</p>
<p>screen -r Resume a previously suspended screen session if possible.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 3: The login environment 35
</p>
<p>CTRL-a CTRL-c
</p>
<p>Start a new shell on top of the others (a fresh `screen') in the current window.
</p>
<p>CTRL-a CTRL-n
</p>
<p>Switch to the next `screen'.
</p>
<p>CTRL-a CTRL-a
</p>
<p>Switch to the last screen used.
</p>
<p>CTRL-a a When screen is running, CTRL-a is used for screen commands and cannot there-
</p>
<p>fore be used in its usual shell meaning of `jump to start of line'. CTRL-a a
</p>
<p>replaces this.
</p>
<p>CTRL-a CTRL-d
</p>
<p>Detach the screen session from the current window so that it can be resumed
</p>
<p>later. It can be resumed with the `screen -r' command.
</p>
<p>CTRL-a ? Help screen.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>36 The unix programming environment</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 4: Files and access 37
</p>
<p>4 Files and access
</p>
<p>To prevent all users from being able to access all &#12;les on the system, unix records
</p>
<p>information about who creates &#12;les and also who is allowed to access them later.
</p>
<p>Each user has a unique username or loginname together with a unique user id or uid.
</p>
<p>The user id is a number, whereas the login name is a text string { otherwise the two express
</p>
<p>the same information. A &#12;le belongs to user A if it is owned by user A. User A then decides
</p>
<p>whether or not other users can read, write or execute the &#12;le by setting the protection bits
</p>
<p>or the permission of the &#12;le using the command chmod.
</p>
<p>In addition to user identities, there are groups of users. The idea of a group is that
</p>
<p>several named users might want to be able to read and work on a &#12;le, without other users
</p>
<p>being able to access it. Every user is a member of at least one group, called the login group
</p>
<p>and each group has both a textual name and a number (group id). The uid and gid of each
</p>
<p>user is recorded in the &#12;le /etc/passwd (See chapter 6). Membership of other groups is
</p>
<p>recorded in the &#12;le /etc/group or on some systems /etc/logingroup.
</p>
<p>4.1 Protection bits
</p>
<p>The following output is from the command ls -lag executed on a SunOS type machine.
</p>
<p>lrwxrwxrwx 1 root wheel 7 Jun 1 1993 bin -&gt; usr/bin
</p>
<p>-r--r--r-- 1 root bin 103512 Jun 1 1993 boot
</p>
<p>drwxr-sr-x 2 bin staff 11264 May 11 17:00 dev
</p>
<p>drwxr-sr-x 10 bin staff 2560 Jul 8 02:06 etc
</p>
<p>drwxr-sr-x 8 root wheel 512 Jun 1 1993 export
</p>
<p>drwx------ 2 root daemon 512 Sep 26 1993 home
</p>
<p>-rwxr-xr-x 1 root wheel 249079 Jun 1 1993 kadb
</p>
<p>lrwxrwxrwx 1 root wheel 7 Jun 1 1993 lib -&gt; usr/lib
</p>
<p>drwxr-xr-x 2 root wheel 8192 Jun 1 1993 lost+found
</p>
<p>drwxr-sr-x 2 bin staff 512 Jul 23 1992 mnt
</p>
<p>dr-xr-xr-x 1 root wheel 512 May 11 17:00 net
</p>
<p>drwxr-sr-x 2 root wheel 512 Jun 1 1993 pcfs
</p>
<p>drwxr-sr-x 2 bin staff 512 Jun 1 1993 sbin
</p>
<p>lrwxrwxrwx 1 root wheel 13 Jun 1 1993 sys-&gt;kvm/sys
</p>
<p>drwxrwxrwx 6 root wheel 732 Jul 8 19:23 tmp
</p>
<p>drwxr-xr-x 27 root wheel 1024 Jun 14 1993 usr
</p>
<p>drwxr-sr-x 10 bin staff 512 Jul 23 1992 var
</p>
<p>-rwxr-xr-x 1 root daemon 2182656 Jun 4 1993 vmunix
</p>
<p>The &#12;rst column is a textual representation of the protection bits for each &#12;le. Column
</p>
<p>two is the number of hard links to the &#12;le (See exercises below). The third and fourth
</p>
<p>columns are the user name and group name and the remainder show the &#12;le size in bytes
</p>
<p>and the creation date. Notice that the directories /bin and /sys are symbolic links to other
</p>
<p>directories.
</p>
<p>There are sixteen protection bits for a UNIX &#12;le, but only twelve of them can be changed
</p>
<p>by users. These twelve are split into four groups of three. Each three-bit number corresponds
</p>
<p>to one octal number.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>38 The unix programming environment
</p>
<p>The leading four invisible bits gives information about the type of &#12;le: is the &#12;le a plain
</p>
<p>&#12;le, a directory or a link. In the output from ls this is represented by a single character:
</p>
<p>-, d or l.
</p>
<p>The next three bits set the so-called s-bits and t-bit which are explained below.
</p>
<p>The remaining three groups of three bits set &#13;ags which indicate whether a &#12;le can be
</p>
<p>read `r', written to `w' or executed `x' by (i) the user who created them, (ii) the other users
</p>
<p>who are in the group the &#12;le is marked with, and (iii) any user at all.
</p>
<p>For example, the permission
</p>
<p>Type Owner Group Anyone
</p>
<p>d rwx r-x ---
</p>
<p>tells us that the &#12;le is a directory, which can be read and written to by the owner, can be
</p>
<p>read by others in its group, but not by anyone else.
</p>
<p>Note about directories. It is impossible to cd to a directory unless the x bit is set. That
</p>
<p>is, directories must be `executable' in order to be accessible.
</p>
<p>Here are some examples of the relationship between binary, octal and the textual repre-
</p>
<p>sentation of &#12;le modes.
</p>
<p>Binary Octal Text
</p>
<p>001 1 x
</p>
<p>010 2 w
</p>
<p>100 4 r
</p>
<p>110 6 rw-
</p>
<p>101 5 r-x
</p>
<p>- 644 rw-r--r--
</p>
<p>It is well worth becoming familiar with the octal number representation of these permissions.
</p>
<p>4.2 chmod
</p>
<p>The chmod command changes the permission or mode of a &#12;le. Only the owner of the
</p>
<p>&#12;le or the superuser can change the permission. Here are some examples of its use. Try
</p>
<p>them.
</p>
<p># make read/write-able for everyone
</p>
<p>chmod a+w myfile
</p>
<p># add the 'execute' flag for directory
</p>
<p>chmod u+x mydir/
</p>
<p># open all files for everyone
</p>
<p>chmod 755 *
</p>
<p># set the s-bit on my-dir's group
</p>
<p>chmod g+s mydir/
</p>
<p># descend recursively into directory opening all files
</p>
<p>chmod -R a+r dir</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 4: Files and access 39
</p>
<p>4.3 Umask
</p>
<p>When a new &#12;le gets created, the operating system must decide what default protection
</p>
<p>bits to set on that &#12;le. The variable umask decides this. umask is normally set by each user
</p>
<p>in his or her .cshrc &#12;le (see next chapter). For example
</p>
<p>umask 077 # safe
</p>
<p>umask 022 # liberal
</p>
<p>According the UNIX documentation, the value of umask is `XOR'ed (exclusive `OR') with a
</p>
<p>value of 666 &amp; umask for plain &#12;les or 777 &amp; umask for directories in order to &#12;nd out the
</p>
<p>standard protection. Actually this is not quite true: `umask' only removes bits, it never sets
</p>
<p>bits which were not already set in 666. For instance
</p>
<p>umask Permission
</p>
<p>077 600 (plain)
</p>
<p>077 700 (dir)
</p>
<p>022 644 (plain)
</p>
<p>022 755 (dir)
</p>
<p>The correct rule for computing permissions is not XOR but `NOT AND'.
</p>
<p>4.3.1 Making programs executable
</p>
<p>A unix program is normally executed by typing its pathname. If the x execute bit is not
</p>
<p>set on the &#12;le, this will generate a `Permission denied' error. This protects the system from
</p>
<p>interpreting nonsense &#12;les as programs. To make a program executable for someone, you
</p>
<p>must therefore ensure that they can execute the &#12;le, using a command like
</p>
<p>chmod u+x &#12;lename
</p>
<p>This command would set execute permissions for the owner of the &#12;le;
</p>
<p>chmod ug+x &#12;lename
</p>
<p>would set execute permissions for the owner and for any users in the same group as the &#12;le.
</p>
<p>Note that script programs must also be readable in order to be executable, since the shell
</p>
<p>has the interpret them by reading.
</p>
<p>4.3.2 chown and chgrp
</p>
<p>These two commands change the ownership and the group ownership of a &#12;le. Only
</p>
<p>the superuser can change the ownership of a &#12;le on most systems. This is to prevent users
</p>
<p>from being able to defeat quota mechanisms. (On some systems, which do not implement
</p>
<p>quotas, ordinary users can give a &#12;le away to another user but not get it back again.) The
</p>
<p>same applies to group ownership.
</p>
<p>4.3.3 Making a group
</p>
<p>Normally users other than root cannot de&#12;ne their own groups. This is a weakness in
</p>
<p>Unix from older times which no one seems to be in a hurry to change. At Oslo College,
</p>
<p>Computer Science, we use a local solution whereby users can edit a &#12;le to create their own
</p>
<p>groups. This &#12;le is called `/iu/nexus/local/iu/etc/iu-group'. The format of the group
</p>
<p>&#12;le is:
</p>
<p>group-name::group-number:comma-separated-list-of-users</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>40 The unix programming environment
</p>
<p>4.4 s-bit and t-bit (sticky bit)
</p>
<p>The s and t bits have special uses. They are described as follows.
</p>
<p>Octal Text Name
</p>
<p>4000 chmod u+s Setuid bit
</p>
<p>2000 chmod g+s Setgid bit
</p>
<p>1000 chmod +t Sticky bit
</p>
<p>The e&#11;ect of these bits di&#11;ers for plain &#12;les and directories and di&#11;er between di&#11;erent
</p>
<p>versions of UNIX. You should check the manual page man sticky to &#12;nd out about your
</p>
<p>system! The following is common behaviour.
</p>
<p>For executable &#12;les, the setuid bit tells UNIX that regardless of who runs the program it
</p>
<p>should be executed with the permissions and rights of owner of the &#12;le. This is often used
</p>
<p>to allow normal users limited access to root privileges. A setuid-root program is executed
</p>
<p>as root for any user. The setgid bit sets the group execution rights of the program in a
</p>
<p>similar way.
</p>
<p>In BSD unix, if the setgid bit is set on a directory then any new &#12;les created in that
</p>
<p>directory assume the group ownership of the parent directory and not the logingroup of the
</p>
<p>user who created the &#12;le. This is standard policy under system 5.
</p>
<p>A directory for which the sticky bit is set restrict the deletion of &#12;les within it. A &#12;le or
</p>
<p>directory inside a directory with the t-bit set can only be deleted or renamed by its owner
</p>
<p>or the superuser. This is useful for directories like the mail spool area and /tmp which must
</p>
<p>be writable to everyone, but should not allow a user to delete another user's &#12;les.
</p>
<p>(Ultrix) If an executable &#12;le is marked with a sticky bit, it is held in the memory or
</p>
<p>system swap area. It does not have to be fetched from disk each time it is executed. This
</p>
<p>saves time for frequently used programs like ls.
</p>
<p>(Solaris 1) If a non-executable &#12;le is marked with the sticky bit, it will not be held in the
</p>
<p>disk page cache { that is, it is never copied from the disk and held in RAM but is written
</p>
<p>to directly. This is used to prevent certain &#12;les from using up valuable memory.
</p>
<p>On some systems (e.g. ULTRIX), only the superuser can set the sticky bit. On others
</p>
<p>(e.g. SunOS) any user can create a sticky directory.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 41
</p>
<p>5 C shell
</p>
<p>The C shell is the command interpreter which you use to run programs and utilities.
</p>
<p>It contains a simple programming language for writing tailor-made commands, and allows
</p>
<p>you to join together unix commands with pipes. It is a con&#12;gurable environment, and once
</p>
<p>you know it well, it is the most e&#14;cient way of working with unix.
</p>
<p>5.1 .cshrc and .login &#12;les
</p>
<p>Most users run the C-shell `/bin/csh' as their login environment, or these days, prefer-
</p>
<p>ably the `tcsh' which is an improved version of csh. When a user logs in to a UNIX
</p>
<p>system the C-shell starts by reading some &#12;les which con&#12;gure the environment by de&#12;ning
</p>
<p>variables like path.
</p>
<p>&#15; The &#12;le `.cshrc' is searched for in your home directory. i.e. `~/.cshrc'. If it is found,
</p>
<p>its contents are interpreted by the C-shell as C-shell instructions, before giving you the
</p>
<p>command prompt
</p>
<p>1
</p>
<p>.
</p>
<p>&#15; If and only if this is the login shell (not a sub-shell that you have started after login)
</p>
<p>then the &#12;le `~/.login' is searched for and executed.
</p>
<p>With the advent of the X11 windowing system, this has changed slightly. Since the window
</p>
<p>system takes over the entire login procedure, users never get to run `login shells', since the
</p>
<p>login shell is used up by the X11 system. On an X-terminal or host running X the `.login'
</p>
<p>&#12;le normally has no e&#11;ect.
</p>
<p>With some thought, the `.login' &#12;le can be eliminated entirely, and we can put every-
</p>
<p>thing into the .cshrc &#12;le. Here is a very simple example `.cshrc' &#12;le.
</p>
<p>#
</p>
<p># .cshrc - read in by every csh that starts.
</p>
<p>#
</p>
<p># Set the default file creation mask
</p>
<p>umask 077
</p>
<p># Set the path
</p>
<p>set path=( /usr/local/bin /usr/bin/X11 /usr/ucb /bin /usr/bin . )
</p>
<p># Exit here if the shell is not interactive
</p>
<p>if ( $?prompt == 0 ) exit
</p>
<p># Set some variables
</p>
<p>set noclobber notify filec nobeep
</p>
<p>set history=100
</p>
<p>set prompt=&quot;`hostname`%&quot;
</p>
<p>1
</p>
<p>Under HPUX, two other &#12;les are also read by the C-shell. These are called `/etc/csh.login'
</p>
<p>and `/etc/src.csh', enabling some standard set-up to be con&#12;gured globally. GNU/Linux
</p>
<p>has a similar system. On solaris systems `/etc/.login' is read.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>42 The unix programming environment
</p>
<p>set prompt2 = &quot;%m %h&gt;&quot; # tcsh, prompt for foreach and while
</p>
<p>setenv PRINTER myprinter
</p>
<p>setenv LD_LIBRARY_PATH /usr/lib:/usr/local/lib:/usr/openwin/lib
</p>
<p># Aliases are shortcuts to unix commands
</p>
<p>alias passwd yppasswd
</p>
<p>alias dir 'ls -lg \!* | more'
</p>
<p>alias sys 'ps aux | more'
</p>
<p>alias h history
</p>
<p>It is possible to make a much more complicated .cshrc &#12;le than this. The advent of
</p>
<p>distributed computing and NFS (Network &#12;le system) means that you might log into many
</p>
<p>di&#11;erent machines running di&#11;erent versions of unix. The command path would have to be
</p>
<p>set di&#11;erently for each type of machine.
</p>
<p>5.2 De&#12;ning variables with set, setenv
</p>
<p>We have already seen in the examples above how to de&#12;ne variables in C-shell. Let's
</p>
<p>formalize this. To de&#12;ne a local variable { that is, one which will not get passed on to
</p>
<p>programs and sub-shells running under the current shell, we write
</p>
<p>set local = &quot;some string&quot;
</p>
<p>set myname = &quot;`whoami`&quot;
</p>
<p>These variables are then referred to by using the dollar `$' symbol. i.e. The value of the
</p>
<p>variable `local' is `$local'.
</p>
<p>echo $local $myname
</p>
<p>Global variables, that is variables which all sub-shells inherit from the current shell are
</p>
<p>de&#12;ned using `setenv'
</p>
<p>setenv GLOBAL &quot;Some other string&quot;
</p>
<p>setenv MYNAME &quot;`who am i`&quot;
</p>
<p>Their values are also referred to using the `$' symbol. Notice that set uses an `=' sign while
</p>
<p>`setenv' does not.
</p>
<p>Variables can be also created without a value. The shell uses this method to switch on
</p>
<p>and o&#11; certain features, using variables like `noclobber' and `noglob'. For instance
</p>
<p>nexus% set flag
</p>
<p>nexus% if ($?flag) echo 'Flag is set!'
</p>
<p>Flag is set!
</p>
<p>nexus% unset flag
</p>
<p>nexus% if ( $?flag ) echo 'Flag is set!'
</p>
<p>nexus%
</p>
<p>The operator `$?variable' is `true' if variable exists and `false' if it does not. It does not
</p>
<p>matter whether the variable holds any information.
</p>
<p>The commands `unset' and `unsetenv' can be used to unde&#12;ne or delete variables when
</p>
<p>you don't want them anymore.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 43
</p>
<p>5.3 Arrays
</p>
<p>A useful facility in the C-shell is the ability to make arrays out of strings and other vari-
</p>
<p>ables. The round parentheses `(..)' do this. For example, look at the following commands.
</p>
<p>nexus% set array = ( a b c d )
</p>
<p>nexus% echo $array[1]
</p>
<p>a
</p>
<p>nexus% echo $array[2]
</p>
<p>b
</p>
<p>nexus% echo $array[$#array]
</p>
<p>d
</p>
<p>nexus% set noarray = ( &quot;a b c d&quot; )
</p>
<p>nexus% echo $noarray[1]
</p>
<p>a b c d
</p>
<p>nexus% echo $noarray[$#noarray]
</p>
<p>a b c d
</p>
<p>The &#12;rst command de&#12;nes an array containing the elements `a b c d'. The elements of the
</p>
<p>array are referred to using square brackets `[..]' and the &#12;rst element is `$array[1]'. The
</p>
<p>last element is `$array[4]'. NOTE: this is not the same as in C or C++ where the &#12;rst
</p>
<p>element of the array is the zeroth element!
</p>
<p>The special operator `$#' returns the number of elements in an array. This gives us a
</p>
<p>simple way of &#12;nding the end of the array. For example
</p>
<p>nexus% echo $#path
</p>
<p>23
</p>
<p>nexus% echo &quot;The last element in path is $path[$#path]&quot;
</p>
<p>The last element in path is .
</p>
<p>To &#12;nd the next last element we need to be able to do arithmetic. We'll come back to this
</p>
<p>later.
</p>
<p>5.4 Pipes and redirection in csh
</p>
<p>The symbols
</p>
<p>&lt; &gt; &gt;&gt; &lt;&lt; | &amp;
</p>
<p>have a special meaning in the shell. By default, most commands take their input from
</p>
<p>the &#12;le `stdin' (the keyboard) and write their output to the &#12;le `stdout' and their error
</p>
<p>messages to the &#12;le `stderr' (normally, both of these output &#12;les are de&#12;ned to be the
</p>
<p>current terminal device `/dev/tty', or `/dev/console').
</p>
<p>`stdin', `stdout' and `stderr', known collectively as `stdio', can be rede&#12;ned or redi-
</p>
<p>rected so that information is taken from or sent to a di&#11;erent &#12;le. The output direction can
</p>
<p>be changed with the symbol `&gt;'. For example,
</p>
<p>echo testing &gt; myfile
</p>
<p>produces a &#12;le called `myfile' which contains the string `testing'. The single `&gt;' (greater
</p>
<p>than) sign always creates a new &#12;le, whereas the double `&gt;&gt;' appends to the end of a &#12;le, if
</p>
<p>it already exists. So the &#12;rst of the commands</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>44 The unix programming environment
</p>
<p>echo blah blah &gt;&gt; myfile
</p>
<p>echo Newfile &gt; myfile
</p>
<p>adds a second line to `myfile' after `testing', whereas the second command writes over
</p>
<p>`myfile' and ends up with just one line `New&#12;le'.
</p>
<p>Now suppose we mistype a command
</p>
<p>ehco test &gt; myfile
</p>
<p>The command `ehco' does not exist and so the error message `ehco: Command not found'
</p>
<p>appears on the terminal. This error message was sent to stderr { so even though we
</p>
<p>redirected output to a &#12;le, the error message appeared on the screen to tell us that an
</p>
<p>error occurred. Even this can be changed. `stderr' can also be redirected by adding an
</p>
<p>ampersand `&amp;' character to the `&gt;' symbol. The command
</p>
<p>ehco test &gt;&amp; myfile
</p>
<p>results in the &#12;le `myfile' being created, containing the error message `ehco: Command
</p>
<p>not found'.
</p>
<p>The input direction can be changed using the `&lt;' symbol for example
</p>
<p>/bin/mail mark &lt; message
</p>
<p>would send the &#12;le `message' to the user `mark' by electronic mail. The mail program takes
</p>
<p>its input from the &#12;le instead of waiting for keyboard input.
</p>
<p>There are some re&#12;nements to the redirection symbols. First of all, let us introduce the
</p>
<p>C-shell variable `noclobber'. If this variable is set with a command like
</p>
<p>set noclobber
</p>
<p>then &#12;les will not be overwritten by the `&gt;' command. If one tries to redirect output to an
</p>
<p>existing &#12;le, the following happens.
</p>
<p>unix% set noclobber
</p>
<p>unix% touch blah # create an empty file blah
</p>
<p>unix% echo test &gt; blah
</p>
<p>blah: File exists.
</p>
<p>If you are nervous about overwriting &#12;les, then you can set `noclobber' in your `.cshrc'
</p>
<p>&#12;le. `noclobber' can be overridden using the pling `!' symbol. So
</p>
<p>unix% set noclobber
</p>
<p>unix% touch blah # create an empty file blah
</p>
<p>unix% echo test &gt;! blah
</p>
<p>writes over the &#12;le `blah' even though `noclobber' is set.
</p>
<p>Here are some other combinations of redirection symbols
</p>
<p>`&gt;&gt;' Append, including `stderr'
</p>
<p>`&gt;&gt;!' Append, ignoring `noclobber'
</p>
<p>`&gt;&gt;&amp;!' Append `stdout', `stderr', ignore `noclobber'
</p>
<p>`&lt;&lt;' See below.
</p>
<p>The last of these commands reads from the standard input until it &#12;nds a line which contains
</p>
<p>a word. It then feeds all of this input into the program concerned. For example,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 45
</p>
<p>nexus% mail mark &lt;&lt;quit
</p>
<p>nexus 1&gt; Hello mark
</p>
<p>nexus 2&gt; Nothing much to say...
</p>
<p>nexus 2&gt; so bye
</p>
<p>nexus 2&gt;
</p>
<p>nexus 2&gt; quit
</p>
<p>Sending mail...
</p>
<p>Mail sent!
</p>
<p>The mail message contains all the lines up to, but not including `marker'. This method
</p>
<p>can also be used to print text verbatim from a &#12;le without using multiple echo commands.
</p>
<p>Inside a script one may write:
</p>
<p>cat &lt;&lt; &quot;marker&quot;;
</p>
<p>MENU
</p>
<p>1) choice 1
</p>
<p>2) choice 2
</p>
<p>...
</p>
<p>marker
</p>
<p>The cat command writes directly to stdout and the input is redirected and taken
</p>
<p>directly from the script &#12;le.
</p>
<p>A very useful construction is the `pipe' facility. Using the `|' symbol one can feed the
</p>
<p>`stdout' of one program straight into the `stdin' of another program. Similarly with `|&amp;'
</p>
<p>both `stdout' and `stderr' can be piped into the input of another program. This is very
</p>
<p>convenient. For instance, look up the following commands in the manual and try them.
</p>
<p>ps aux | more
</p>
<p>echo 'Keep on sharpenin them there knives!' | mail henry
</p>
<p>vmstat 1 | head
</p>
<p>ls -l /etc | tail
</p>
<p>Note that when piping both standard input and standard error to another program, the
</p>
<p>two &#12;les do not mix synchronously. Often `stderr' appears &#12;rst.
</p>
<p>5.5 `tee' and `script'
</p>
<p>Occasionally you might want to have a copy of what you see on your terminal sent to a
</p>
<p>&#12;le. `tee' and `script' do this. For instance,
</p>
<p>find / -type l -print | tee myfile
</p>
<p>sends a copy of the output of `find' to the &#12;le `my&#12;le'. `tee' can split the output into as
</p>
<p>many &#12;les as you want:
</p>
<p>command | tee &#12;le1 &#12;le2 ....
</p>
<p>You can also choose to record the output an entire shell session using the `script' command.
</p>
<p>nexus% script mysession
</p>
<p>Script started, file is mysession
</p>
<p>nexus% echo Big brother is scripting you</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>46 The unix programming environment
</p>
<p>Big brother is scripting you
</p>
<p>nexus% exit
</p>
<p>exit
</p>
<p>Script done, file is mysession
</p>
<p>The &#12;le `mysession' is a text &#12;le which contains a transcript of the session.
</p>
<p>5.6 Command history
</p>
<p>The history feature in C-shell means that you do not have to type commands over and
</p>
<p>over again. In the `tcsh' version of the C shell, and the `bash' version of the Bourne shell,
</p>
<p>you can use the
</p>
<p>h
</p>
<p>UP ARROW
</p>
<p>i
</p>
<p>key to browse back through the list of commands you have
</p>
<p>typed previously.
</p>
<p>In the normal C-shell (`csh') there are three main commands.
</p>
<p>`!!' Execute the last command again.
</p>
<p>`!-3' Execute the third last command again.
</p>
<p>`!4' Execute command number 4.
</p>
<p>The &#12;rst of these simply repeats the last command. The second counts backwards from
</p>
<p>the last command to three commands-ago. The &#12;nal command gives an absolute number.
</p>
<p>The absolute command number can be seen by typing `history'.
</p>
<p>5.7 Command/&#12;lename completion
</p>
<p>In the `tcsh' extension of the C-shell, you can save hours worth of typing errors by using
</p>
<p>the completion mechanism. This feature is based on the
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>key.
</p>
<p>The idea is that if you type half a &#12;lename and press
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>, the shell will try to guess
</p>
<p>the remainder of the &#12;lename. It does this by looking at the &#12;les which match what you
</p>
<p>have already typed and trying to &#12;ll in the rest. If there are several &#12;les which match, the
</p>
<p>shell sounds the &quot;bell&quot; or beeps. You can then type
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>to obtain a list of the possible
</p>
<p>alternatives. Here is an example: suppose you have just a single &#12;le in the current directory
</p>
<p>called `very_long_filename', typing
</p>
<p>more
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>results in the following appearing on the command line
</p>
<p>more very_long_filename
</p>
<p>The shell was able to identify a unique &#12;le. Now suppose that you have two &#12;les called
</p>
<p>`very_long_filename' and `very_big_filename', typing
</p>
<p>more
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>results in the following appearing on the command line
</p>
<p>more very_
</p>
<p>and the shell beeps, indicating that the choice was not unique and a decision is required.
</p>
<p>Next, you type
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>to see which &#12;les you ahve to choose from and the shell lists
</p>
<p>them and returns you to the command line, exactly where you were. You now choose
</p>
<p>`very_long_filename' by typing `l'. This is enough to uniquely identify the &#12;le. Pressing
</p>
<p>the
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>key again results in</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 47
</p>
<p>more very_long_filename
</p>
<p>on the screen. As long as you have written enough to select a &#12;le uniquely, the shell will be
</p>
<p>able to complete the name for you.
</p>
<p>Completion also works on shell commands, but it is a little slower since the shell must
</p>
<p>serach through all the directories in the command path to complete commands.
</p>
<p>5.8 Single and double quotes
</p>
<p>Two kinds of quotes can be used in shell apart from the backward quotes we mentioned
</p>
<p>above. The essential di&#11;erence between them is that certain shell commands work inside
</p>
<p>double quotes but not inside single quotes. For example
</p>
<p>nexus% echo /etc/rc.*
</p>
<p>/etc/rc.boot /etc/rc.ip /etc/rc.local
</p>
<p>nexus% echo &quot;/etc/rc.*&quot;
</p>
<p>/etc/rc.*
</p>
<p>nexus% echo &quot;`who am i` -- my name is $user ???&quot;
</p>
<p>nexus!mark ttyp7 Jul 13 10:16 -- my name is mark ???
</p>
<p>nexus% echo '`who am i` -- my name is $user ???'
</p>
<p>`who am i` -- my name is $user ???
</p>
<p>We see that the single quotes prevent variable substitution and sub-shells. Wildcards do
</p>
<p>not work inside either single or double quotes.
</p>
<p>5.9 Job control, break key, `fg', `bg'
</p>
<p>So far we haven't mentioned UNIX's ability to multitask. In the Bourne shell (`sh') there
</p>
<p>are no facilities for controlling several user processes
</p>
<p>2
</p>
<p>. C-shell provides some commands for
</p>
<p>starting and stopping processes. These originate from the days before windows and X11,
</p>
<p>so some of them may seem a little old-fashioned. They are still very useful nonetheless.
</p>
<p>Let's begin by looking at the commands which are true for any shell. Most programs
</p>
<p>are run in the foreground or interactively. That means that they are connected to the
</p>
<p>standard input and send their output to the standard output. A program can be made to
</p>
<p>run in the background, if it does not need to use the standard I/O. For example, a program
</p>
<p>which generates output and sends it to a &#12;le could run in the background. In a window
</p>
<p>environment, programs which create their own windows can also be started as background
</p>
<p>processes, leaving standard I/O in the shell free.
</p>
<p>Background processes run independently of what you are doing in the foreground.
</p>
<p>2
</p>
<p>Newer versions of the Bourne shell, like the Korn shell and Bourne-again-shell do have
</p>
<p>these facilities.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>48 The unix programming environment
</p>
<p>5.9.1 Unix Processes and BSD signals
</p>
<p>A background process is started using the special charcter `&amp;' at the end of the command
</p>
<p>line.
</p>
<p>find / -name '*lib*' -print &gt;&amp; output &amp;
</p>
<p>The &#12;nal `&amp;' on the end of this line means that the job will be run in the background.
</p>
<p>Note that this is not confused with the redirection operator `&gt;&amp;' since it must be the last
</p>
<p>character on the line. The command above looks for any &#12;les in the system containing the
</p>
<p>string `lib' and writes the list of &#12;les to a &#12;le called `output'. This might be a useful way
</p>
<p>of searching for missing libraries which you want to include in your environment variable
</p>
<p>`LD_LIBRARY_PATH'. Searching the enire disk from the root directory `/' could take a long
</p>
<p>time, so it pays to run this in the background.
</p>
<p>If we want to see what processes are running, we can use the `ps' command. `ps' without
</p>
<p>any arguments lists all of your processes, i.e. all processes owned by the user name you
</p>
<p>logged in with. `ps' takes many options, for instance `ps auxg' will list all processes in
</p>
<p>gruesome detail. (The &quot;g&quot; is for group, not gruesome!) `ps' reads the kernel's process
</p>
<p>tables directly.
</p>
<p>Processes can be stopped and started, or killed one and for all. The `kill' command
</p>
<p>does this. There are, in fact, two versions of the `kill' command. One of them is built into
</p>
<p>the C-shell and the other is not. If you use the C-shell then you will never care about the
</p>
<p>di&#11;erence. We shall nonetheless mention the special features of the C-shell built-ins below.
</p>
<p>The kill command takes a number called a signal as an argument and another number
</p>
<p>called the process identi&#12;er or PID for short. Kill send signals to processes. Some of these
</p>
<p>are fatal and some are for information only. The two commands
</p>
<p>kill -15 127
</p>
<p>kill 127
</p>
<p>are identical. They both send signal 15 to PID 127. This is the normal termination signal
</p>
<p>and it is often enough to stop any process from running.
</p>
<p>Programs can choose to ignore certain signals by trapping signals with a special handler.
</p>
<p>One signal they cannot ignore is signal 9.
</p>
<p>kill -9 127
</p>
<p>is a sure way of killing PID 127. Even though the process dies, it may not be removed from
</p>
<p>the kernel's process table if it has a parent (see next section).
</p>
<p>Here is the complete list of unix signals which the kernel send to processes in di&#11;erent
</p>
<p>circumstances.
</p>
<p>1 &quot;SIGHUP&quot;, /* hangup */
</p>
<p>2 &quot;SIGINT&quot;, /* interrupt */
</p>
<p>3 &quot;SIGQUIT&quot;, /* quit */
</p>
<p>4 &quot;SIGILL&quot;, /* illegal instruction (not reset when caught) */
</p>
<p>5 &quot;SIGTRAP&quot;, /* trace trap (not reset when caught) */
</p>
<p>6 &quot;SIGIOT/SIGABRT&quot;, /* IOT instruction */
</p>
<p>7 &quot;SIGEMT&quot;, /* EMT instruction */
</p>
<p>8 &quot;SIGFPE&quot;, /* floating point exception */
</p>
<p>9 &quot;SIGKILL&quot;, /* kill (cannot be caught or ignored) */</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 49
</p>
<p>10 &quot;SIGBUS&quot;, /* bus error */
</p>
<p>11 &quot;SIGSEGV&quot;, /* segmentation violation */
</p>
<p>12 &quot;SIGSYS&quot;, /* bad argument to system call */
</p>
<p>13 &quot;SIGPIPE&quot;, /* write on a pipe with no one to read it */
</p>
<p>14 &quot;SIGALRM&quot;, /* alarm clock */
</p>
<p>15 &quot;SIGTERM&quot;, /* software termination signal from kill */
</p>
<p>16 &quot;SIGURG&quot;, /* urgent condition on IO channel */
</p>
<p>17 &quot;SIGSTOP&quot;, /* sendable stop signal not from tty */
</p>
<p>18 &quot;SIGTSTP&quot;, /* stop signal from tty */
</p>
<p>19 &quot;SIGCONT&quot;, /* continue a stopped process */
</p>
<p>20 &quot;SIGCHLD/SIGCLD&quot;, /* to parent on child stop or exit */
</p>
<p>21 &quot;SIGTTIN&quot;, /* to readers pgrp upon background tty read */
</p>
<p>22 &quot;SIGTTOU&quot;, /* like TTIN for output if (tp-&gt;t_local&amp;LTOSTOP) */
</p>
<p>23 &quot;SIGIO/SIGPOLL&quot;, /* input/output possible signal */
</p>
<p>24 &quot;SIGXCPU&quot;, /* exceeded CPU time limit */
</p>
<p>25 &quot;SIGXFSZ&quot;, /* exceeded file size limit */
</p>
<p>26 &quot;SIGVTALRM&quot;, /* virtual time alarm */
</p>
<p>27 &quot;SIGPROF&quot;, /* profiling time alarm */
</p>
<p>28 &quot;SIGWINCH&quot;, /* window changed */
</p>
<p>29 &quot;SIGLOST&quot;, /* resource lost (eg, record-lock lost) */
</p>
<p>30 &quot;SIGUSR1&quot;, /* user defined signal 1 */
</p>
<p>31 &quot;SIGUSR2&quot;
</p>
<p>We have already mentioned 15 and 9 which are the main signals for users. Signal 1, or
</p>
<p>`HUP' can be sent to certain programs by the superuser. For instance
</p>
<p>kill -1 &lt;inetd&gt;
</p>
<p>kill -HUP &lt;inetd&gt;
</p>
<p>which forces `inetd' to reread its con&#12;guration &#12;le. Sometimes it is useful to suspend a
</p>
<p>process temporarily and then restart it later.
</p>
<p>kill -18 &lt;PID&gt; # suspend process &lt;PID&gt;
</p>
<p>kill -19 &lt;PID&gt; # resume process &lt;PID&gt;
</p>
<p>5.9.2 Child Processes and zombies
</p>
<p>When you start a process from a shell, regardless of whether it is a background process or
</p>
<p>a foreground process, the new process becomes a child of the original shell. Remember that
</p>
<p>the shell is just a unix process itself. Moreover, if one of the children starts a new process
</p>
<p>then it will be a child of the child (a grandchild?)! Processes therefore form hierachies.
</p>
<p>Several children can have a common parent.
</p>
<p>If we kill a parent, then (unless the child has detached itself from the parent) all of its
</p>
<p>children die too. If a child dies, the parent is not a&#11;ected. Sometimes when a child is killed,
</p>
<p>it does not die but becomes &quot;defunct&quot; or a zombie process. This means that the child has
</p>
<p>a parent which is waiting for it to &#12;nish. If the parent has not yet been informed that
</p>
<p>the child has died, for example because it has been suspended itself, then the dead child is
</p>
<p>not removed from the kernel's process table. When the parent wakes up and receives the
</p>
<p>message that the child has terminated, the process entry for the dead child can be removed.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>50 The unix programming environment
</p>
<p>5.9.3 C-shell builtins: `jobs', `kill', `fg',`bg', break key
</p>
<p>Now let's look at some commands which are built into the C-shell for starting and
</p>
<p>stopping processes. C-shell refers to user programs as `jobs' rather than processes { but
</p>
<p>there is no real di&#11;erence. The added bonus of the C-shell is that each shell has a job number
</p>
<p>in addition to its PID. The job numbers are simpler and are private for the shell, whereas
</p>
<p>the PIDs are assigned by the kernel and are often very large numbers which are di&#14;cult to
</p>
<p>to remember. When a command is executed in the shell, it is assigned a job number. If you
</p>
<p>never run any background jobs then there is only ever one job number: 1, since every job
</p>
<p>exits before the next one starts. However, if you run background tasks, then you can have
</p>
<p>several jobs &quot;active&quot; at any time. Moreover, by suspending jobs, C-shell allows you to have
</p>
<p>several interactive programs running on the same terminal { the `fg' and `bg' commands
</p>
<p>allow you to move commands from the background to the foreground and vice-versa.
</p>
<p>Take a look at the following shell session.
</p>
<p>nexus% emacs myfile &amp;
</p>
<p>[1] 4990
</p>
<p>nexus%
</p>
<p>( other commands ... , edit myfile and close emacs )
</p>
<p>[1] Exit 70 emacs myfile
</p>
<p>When a background job is done, the shell prints a message at a suitable moment between
</p>
<p>prompts.
</p>
<p>[1] Done emacs myfile
</p>
<p>This tells you that job number 1 &#12;nished normally. If the job exits abnormally then the
</p>
<p>word `Done' may be replaced by some other message. For instance, if you kill the job, it
</p>
<p>will say
</p>
<p>unix% kill %12
</p>
<p>[12] Terminated textedit file
</p>
<p>You can list the jobs you have running using the `jobs' command. The output looks
</p>
<p>something like
</p>
<p>[1] + Running textedit c.tex
</p>
<p>[3] Running textedit glossary.tex
</p>
<p>[4] Running textedit net.tex
</p>
<p>[5] Running textedit overview.tex
</p>
<p>[6] Running textedit perl.tex
</p>
<p>[7] Running textedit shell.tex
</p>
<p>[8] Running textedit sysadm.tex
</p>
<p>[9] Running textedit unix.tex
</p>
<p>[10] Running textedit x11.tex
</p>
<p>[11] - Running shelltool
</p>
<p>[15] Suspended emacs myfile</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 51
</p>
<p>To suspend a program which you are running in the foreground you can type
</p>
<p>h
</p>
<p>CTRL-z
</p>
<p>i
</p>
<p>(this is like sending a `kill -18' signal from the keyboard).
</p>
<p>3
</p>
<p>You can suspend any number
</p>
<p>of programs and then restart them one at a time using `fg' and `bg'. If you want job 5 to
</p>
<p>be restarted in the foreground, you would type
</p>
<p>fg %5
</p>
<p>When you have had enough of job 5, you can type CTRL-z to suspend it and then type
</p>
<p>fg %6
</p>
<p>to activate job 6. Provided a job does not want to send output to `stdout', you can restart
</p>
<p>any job in the background, using a command like.
</p>
<p>bg %4
</p>
<p>This method of working was useful before windows were available. Using `fg' and `bg',
</p>
<p>you can edit several &#12;les or work on several programs without have to quit to move from
</p>
<p>one to another.
</p>
<p>See also some related commands for batch processing `at', `batch' and `atq', `cron'.
</p>
<p>NOTE:
</p>
<p>h
</p>
<p>CTRL-c
</p>
<p>i
</p>
<p>sends a `kill -2' signal, which send a standard interrupt message to a
</p>
<p>program. This is always a safe way to interrupt a shell command.
</p>
<p>5.10 Scripts with arguments
</p>
<p>One of the useful features of the shell is that you can use the normal unix commands
</p>
<p>to make programs called scripts. To make a script, you just create a &#12;le containing shell
</p>
<p>commands you want to execute and make sure that the &#12;rst line of the &#12;le looks like the
</p>
<p>following example.
</p>
<p>#!/bin/csh -f
</p>
<p>#
</p>
<p># A simple script: check for user's mail
</p>
<p>#
</p>
<p>#
</p>
<p>set path = ( /bin /usr/ucb ) # Set the local path
</p>
<p>cd /var/spool/mail # Change dir
</p>
<p>foreach uid ( * )
</p>
<p>echo &quot;$uid has mail in the intray! &quot; # space prevents an error!
</p>
<p>end
</p>
<p>The sequence `#!/bin/csh' means that the following commands are to be fed into
</p>
<p>`/bin/csh'. The two symbols `#!' must be the very &#12;rst two characters in the &#12;le. The
</p>
<p>`-f' option means that your `.cshrc' &#12;le is not read by the shell when it starts up. The &#12;le
</p>
<p>containing this script must be executable (see `chmod') and must be in the current path,
</p>
<p>like all other programs.
</p>
<p>3
</p>
<p>This does not seem to work in solaris?!</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>52 The unix programming environment
</p>
<p>Like C programs, C-shell scripts can accept command line arguments. Suppose you want
</p>
<p>to make a program to say hello to some other users who are logged onto the system.
</p>
<p>say-hello mark sarah mel
</p>
<p>To do this you need to know the names that were typed on the command line. These names
</p>
<p>are copied into an array in the C-shell called the argument vector, or `argv'. To read these
</p>
<p>arguments, you just treat `argv' as an array.
</p>
<p>#!/bin/csh -f
</p>
<p>#
</p>
<p># Say hello
</p>
<p>#
</p>
<p>foreach name ( $argv )
</p>
<p>echo Saying hello to $name
</p>
<p>echo &quot;Hello from $user! &quot; | write $name
</p>
<p>end
</p>
<p>The elements of the array can be referred to as `argv[1]'..`argv[$#argv]' as usual.
</p>
<p>They can also be referred to as `$1'..`$3' upto the last acceptable number. This makes
</p>
<p>C-shell compatible with the Bourne shell as far as arguments are concerned. One extra
</p>
<p>&#13;ourish in this method is that you can also refer to the name of the program itself as `$0'.
</p>
<p>For example,
</p>
<p>#!/bin/csh -f
</p>
<p>echo This is program $0 running for $user
</p>
<p>`$argv' represents all the arguments. You can also use `$*' from the Bourne shell.
</p>
<p>5.11 Sub-shells ()
</p>
<p>The C-shell does not allow you to de&#12;ne subroutines or functions, but you can create a
</p>
<p>local shell, with its own private variables by enclosing commands in parentheses.
</p>
<p>#!/bin/csh
</p>
<p>cd /etc
</p>
<p>( cd /usr/bin; ls * ) &gt; myfile
</p>
<p>pwd
</p>
<p>This program changes the working directory to /etc and then executes a subshell which
</p>
<p>inside the brackets changes directory to /usr/bin and lists the &#12;les there. The output of this
</p>
<p>private shell are sent to a &#12;le `my&#12;le'. At the end we print out the current working directory
</p>
<p>just to show that the `cd' command in brackets had no e&#11;ect on the main program.
</p>
<p>Normally both parentheses must be on the same line. If a subshell command line gets
</p>
<p>too long, so that the brackets are not on the same line, you have to use backslash characters
</p>
<p>to continue the lines,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 53
</p>
<p>( command \
</p>
<p>command \
</p>
<p>command \
</p>
<p>)
</p>
<p>5.12 Tests and conditions
</p>
<p>No programming language would be complete without tests and loops. C-shell has two
</p>
<p>kinds of decision structure: the `if..then..else' and the `switch' structure. These are
</p>
<p>closely related to their C counterparts. The syntax of these is
</p>
<p>if (condition) command
</p>
<p>if (condition) then
</p>
<p>command
</p>
<p>command..
</p>
<p>else
</p>
<p>command
</p>
<p>command..
</p>
<p>endif
</p>
<p>switch (string)
</p>
<p>case one:
</p>
<p>commands
</p>
<p>breaksw
</p>
<p>case two:
</p>
<p>commands
</p>
<p>breaksw
</p>
<p>...
</p>
<p>endsw
</p>
<p>In the latter case, no commands should appear on the same line as a `case' statement,
</p>
<p>or they will be ignored. Also, if the `breaksw' commands are omitted, then control &#13;ows
</p>
<p>through all the commands for case 2, case 3 etc, exactly as it does in the C programming
</p>
<p>language.
</p>
<p>We shall consider some examples of these statements in a moment, but &#12;rst it is worth
</p>
<p>listing some important tests which can be used in `if' questions to &#12;nd out information
</p>
<p>about &#12;les.
</p>
<p>`-r &#12;le' True if the &#12;le exists and is readable
</p>
<p>`-w &#12;le' True if the &#12;le exists and is writable
</p>
<p>`-x &#12;le' True if the &#12;le exists and is executable</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>54 The unix programming environment
</p>
<p>`-e &#12;le' True if the &#12;le simply exists
</p>
<p>`-z &#12;le' True if the &#12;le exists and is empty
</p>
<p>`-f &#12;le' True if the &#12;le is a plain &#12;le
</p>
<p>`-d &#12;le' True if the &#12;le is a directory
</p>
<p>We shall also have need of the following comparision operators.
</p>
<p>`==' is equal to (string comparison)
</p>
<p>`!=' is not equal to
</p>
<p>`&gt;' is greater than
</p>
<p>`&lt;' is less than
</p>
<p>`&gt;=' is greater than or equal to
</p>
<p>`&lt;=' is less than or equal to
</p>
<p>`=~' matches a wildcard
</p>
<p>`!~' does not match a wildcard
</p>
<p>The simplest way to learn about these statements is to use them, so we shall now look
</p>
<p>at some examples.
</p>
<p>#!/bin/csh -f
</p>
<p>#
</p>
<p># Safe copy from &lt;arg[1]&gt; to &lt;arg[2]&gt;
</p>
<p>#
</p>
<p>#
</p>
<p>if ($#argv != 2) then
</p>
<p>echo &quot;Syntax: copy &lt;from-file&gt; &lt;to-file&gt;&quot;
</p>
<p>exit 0
</p>
<p>endif
</p>
<p>if ( -f $argv[2] ) then
</p>
<p>echo &quot;File exists. Copy anyway?&quot;
</p>
<p>switch ( $&lt; ) # Get a line from user
</p>
<p>case y:
</p>
<p>breaksw
</p>
<p>default:
</p>
<p>echo &quot;Doing nothing!&quot;
</p>
<p>exit 0
</p>
<p>endsw</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 55
</p>
<p>endif
</p>
<p>echo -n &quot;Copying $argv[1] to $argv[2]...&quot;
</p>
<p>cp $argv[1] $argv[2]
</p>
<p>echo done
</p>
<p>endif
</p>
<p>This script tries to copy a &#12;le from one location to another. If the user does not type
</p>
<p>exactly two arguments, the script quits with a message about the correct syntax. Otherwise
</p>
<p>it tests to see whether a plain &#12;le has the same name as the &#12;le the user wanted to copy to.
</p>
<p>If such a &#12;le exists, it asks the user if he/she wants to continue before proceding to copy.
</p>
<p>5.12.1 Switch example: con&#12;gure script
</p>
<p>Here is another example which compiles a software package. This is a problem we shall
</p>
<p>return to later See Section 9.5 [Make], page 119. The problem this script tries to address
</p>
<p>is the following. There are many di&#11;erent versions of UNIX and they are not exactly
</p>
<p>compatible with one another. The program this &#12;le compiles has to work on any kind of
</p>
<p>UNIX, so it tries &#12;rst to determine what kind of UNIX system the script is being run on
</p>
<p>by calling `uname'. Then it de&#12;nes a variable `MAKE' which contains the path to the `make'
</p>
<p>program which will build software. The make program reads a &#12;le called `Make&#12;le' which
</p>
<p>contains instructions for compiling the program, but this &#12;le needs to know the type of
</p>
<p>UNIX, so the script &#12;rst copies a &#12;le `Make&#12;le.src' using `sed' replace a dummy string with
</p>
<p>the real name of the UNIX. Then it calls make and sets the correct permission on the &#12;le
</p>
<p>using `chmod'.
</p>
<p>#!/bin/csh -f
</p>
<p>#################################################
</p>
<p>#
</p>
<p>#
</p>
<p># CONFIGURE Makefile AND BUILD software
</p>
<p>#
</p>
<p>#
</p>
<p>#################################################
</p>
<p>set NAME = ( `uname -r -s` )
</p>
<p>switch ($NAME[1])
</p>
<p>case SunOS*:
</p>
<p>switch ($NAME[2])
</p>
<p>case 4*:
</p>
<p>setenv TYPE SUN4
</p>
<p>setenv MAKE /bin/make
</p>
<p>breaksw
</p>
<p>case 5*:
</p>
<p>setenv TYPE SOLARIS</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>56 The unix programming environment
</p>
<p>setenv MAKE /usr/ccs/bin/make
</p>
<p>breaksw
</p>
<p>endsw
</p>
<p>breaksw
</p>
<p>case ULTRIX*:
</p>
<p>setenv TYPE ULTRIX
</p>
<p>setenv MAKE /bin/make
</p>
<p>breaksw
</p>
<p>case HP-UX*:
</p>
<p>setenv TYPE HPuUX
</p>
<p>setenv MAKE /bin/make
</p>
<p>breaksw
</p>
<p>case AIX*:
</p>
<p>setenv TYPE AIX
</p>
<p>setenv MAKE /bin/make
</p>
<p>breaksw
</p>
<p>case OSF*:
</p>
<p>setenv TYPE OSF
</p>
<p>setenv MAKE /bin/make
</p>
<p>breaksw
</p>
<p>case IRIX*:
</p>
<p>setenv TYPE IRIX
</p>
<p>setenv MAKE /bin/make
</p>
<p>breaksw
</p>
<p>default:
</p>
<p>echo Unknown architecture $NAME[1]
</p>
<p>endsw
</p>
<p># Generate Makefile from source file
</p>
<p>sed s/HOSTTYPE/$TYPE/ Makefile.src &gt; Makefile
</p>
<p>echo &quot;Making software. Type CTRL-C to abort and edit Makefile&quot;
</p>
<p>$MAKE software # call make to build program
</p>
<p>chmod 755 software # set correct protection
</p>
<p>5.13 Loops in csh
</p>
<p>The C-shell has three loop structures: `repeat', `while' and `foreach'. We have already
</p>
<p>seen some examples of the `foreach' loop.
</p>
<p>The structure of these loops is as follows
</p>
<p>repeat number-of-times command</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 57
</p>
<p>while ( test expression )
</p>
<p>commands
</p>
<p>end
</p>
<p>foreach control-variable ( list-or-array )
</p>
<p>commands
</p>
<p>end
</p>
<p>The commands `break' and `continue' can be used to break out of the loops at any time.
</p>
<p>Here are some examples.
</p>
<p>repeat 2 echo &quot;Yo!&quot; | write mark
</p>
<p>This sends the message &quot;Yo!&quot; to mark's terminal twice.
</p>
<p>repeat 5 echo `echo &quot;Shutdown time! Log out now&quot; | wall ; sleep 30` ; halt
</p>
<p>This example repeats the command `echo Shutdown time...' &#12;ve times at 30 second intervals,
</p>
<p>before shutting down the system. Only the superuser can run this command! Note the
</p>
<p>strange construction with `echo echo'. This is to force the repeat command to take two
</p>
<p>shell commands as an argument. (Try to explain why this works for yourself.)
</p>
<p>5.14 Input from the user
</p>
<p># Test a user response
</p>
<p>echo &quot;Answer y/n (yes or no)&quot;
</p>
<p>set valid = false
</p>
<p>while ( $valid == false )
</p>
<p>switch ( $&lt; )
</p>
<p>case y:
</p>
<p>echo &quot;You answered yes&quot;
</p>
<p>set valid = true
</p>
<p>breaksw
</p>
<p>case n:
</p>
<p>echo &quot;You answered no&quot;
</p>
<p>set valid = true
</p>
<p>breaksw</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>58 The unix programming environment
</p>
<p>default:
</p>
<p>echo &quot;Invalid reponse, try again&quot;
</p>
<p>breaksw
</p>
<p>endsw
</p>
<p>end
</p>
<p>Notice that it would have been simpler to replace the two lines
</p>
<p>set valid = true
</p>
<p>breaksw
</p>
<p>by a single line `break'. `breaksw' jumps out of the switch construction, after which the
</p>
<p>`while' test fails. `break' jumps out of the entire while loop.
</p>
<p>5.15 Extracting parts of a pathname
</p>
<p>A path name consists of a number of di&#11;erent parts:
</p>
<p>&#15; The path to the directory where a &#12;le is held.
</p>
<p>&#15; The name of the &#12;le itself.
</p>
<p>&#15; The &#12;le extension (after a dot).
</p>
<p>By using one of the following modi&#12;ers, we can extract these di&#11;erent elements.
</p>
<p>`:h' The path to the &#12;le
</p>
<p>`:t' The &#12;lename itself
</p>
<p>`:e' The &#12;le extension
</p>
<p>`:r' The complete &#12;le-path minus the &#12;le extension
</p>
<p>Here are some examples and the results:
</p>
<p>set f = ~/progs/c++/test.C
</p>
<p>echo $f:h
</p>
<p>/home/mark/progs/c++
</p>
<p>echo $f:t
</p>
<p>test.C
</p>
<p>echo $f:e
</p>
<p>C
</p>
<p>echo $f:r
</p>
<p>/home/mark/progs/c++/test</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 59
</p>
<p>5.16 Arithmetic
</p>
<p>Before using these features in a real script, we need one more possibility: numerical
</p>
<p>addition, subtraction and multiplication etc.
</p>
<p>To tell the C-shell that you want to perform an operation on numbers rather than strings,
</p>
<p>you use the `@' symbol followed by a space. Then the following operations are possible.
</p>
<p>@ var = 45 # Assign a numerical value to var
</p>
<p>echo $var # Print the value
</p>
<p>@ var = $var + 34 # Add 34 to var
</p>
<p>@ var += 34 # Add 34 to var
</p>
<p>@ var -= 1 # subtract 1 from var
</p>
<p>@ var *= 5 # Multiply var by 5
</p>
<p>@ var /= 3 # Divide var by 3 (integer division)
</p>
<p>@ var %= 3 # Remainder after dividing var by 3
</p>
<p>@ var++ # Increment var by 1
</p>
<p>@ var-- # Decrement var by 1
</p>
<p>@ array[1] = 5 # Numerical array
</p>
<p>@ logic = ( $x &gt; 6 &amp;&amp; $x &lt; 10) # AND
</p>
<p>@ logic = ( $x &gt; 6 || $x &lt; 10) # OR
</p>
<p>@ false = ! $var # Logical NOT
</p>
<p>@ bits = ( $x | $y ) # Bitwise OR
</p>
<p>@ bits = ( $x ^ $y ) # Bitwise XOR
</p>
<p>@ bits = ( $x &amp; $y ) # Bitwise AND
</p>
<p>@ shifted = ( $var &gt;&gt; 2 ) # Bitwise shift right
</p>
<p>@ back = ( $var &lt;&lt; 2 ) # Bitwise shift left
</p>
<p>These operators are precisely those found in the C programming language.
</p>
<p>5.17 Examples
</p>
<p>The following script uses the operators in the last two sections to take a list of &#12;les with
</p>
<p>a given &#12;le extension (say `.doc') and change it for another (say `.tex'). This is a partial
</p>
<p>solution to the limitation of not being able to do multiple renames in shell.
</p>
<p>#!/bin/csh -f
</p>
<p>#############################################################
</p>
<p>#
</p>
<p># Change file extension for multiple files
</p>
<p>#
</p>
<p>#############################################################
</p>
<p>if ($#argv &lt; 2) then</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>60 The unix programming environment
</p>
<p>echo Syntax: chext oldpattern newextension
</p>
<p>echo &quot;e.g: chext *.doc tex &quot;
</p>
<p>exit 0
</p>
<p>endif
</p>
<p>mkdir /tmp/chext.$user # Make a scratch area
</p>
<p>set newext=&quot;$argv[$#argv]&quot; # Last arg is new ext
</p>
<p>set oldext=&quot;$argv[1]:e&quot;
</p>
<p>echo &quot;Old extenstion was ($oldext)&quot;&quot;
</p>
<p>echo &quot;New extension ($newext) -- okay? (y/n)&quot;
</p>
<p>switch( $&lt; )
</p>
<p>case y:
</p>
<p>breaksw
</p>
<p>default:
</p>
<p>echo &quot;Nothing done.&quot;
</p>
<p>exit 0
</p>
<p>endsw
</p>
<p>##############################################################
</p>
<p># Remove the last file extension from files
</p>
<p>##############################################################
</p>
<p>i = 0
</p>
<p>foreach file ($argv)
</p>
<p>i++
</p>
<p>if ( $i == $#argv ) break
</p>
<p>cp $file /tmp/chext.$user/$file:r # temporary store
</p>
<p>end
</p>
<p>###############################################################
</p>
<p># Add .newext file extension to files
</p>
<p>###############################################################
</p>
<p>set array = (`ls /tmp/chext.$user`)
</p>
<p>foreach file ($array)
</p>
<p>if ( -f $file.$newext ) then
</p>
<p>echo destination file $file.$newext exists. No action taken.
</p>
<p>continue
</p>
<p>endif</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 5: C shell 61
</p>
<p>cp /tmp/chext.$user/$file $file.$newext
</p>
<p>rm $file.$oldext
</p>
<p>end
</p>
<p>rm -r /tmp/chext.$user
</p>
<p>Here is another example to try to decipher. Use the manual pages to &#12;nd out about
</p>
<p>`awk'. This script can be written much more easily in Perl or C, as we shall see in the next
</p>
<p>chapters. It is also trivially implemented as a script in the system administration language
</p>
<p>cfengine.
</p>
<p>#!/bin/csh -f
</p>
<p>###########################################################
</p>
<p>#
</p>
<p># KILL all processes owned by $argv[1] with PID &gt; $argv[2]
</p>
<p>#
</p>
<p>###########################################################
</p>
<p>if (&quot;`whoami`&quot; != &quot;root&quot;) then
</p>
<p>echo Permission denied
</p>
<p>exit 0
</p>
<p>endif
</p>
<p>if ( $#argv &lt; 1 || $#argv &gt; 2 ) then
</p>
<p>echo Usage: KILL username lowest-pid
</p>
<p>exit 0
</p>
<p>endif
</p>
<p>if ( $argv[1] == &quot;root&quot;) then
</p>
<p>echo No! Too dangerous -- system will crash
</p>
<p>exit 0
</p>
<p>endif
</p>
<p>############################################################
</p>
<p># Kill everything
</p>
<p>############################################################
</p>
<p>if ( $#argv == 1 ) then
</p>
<p>set killarray = ( `ps aux | awk '{ if ($1 == user) \
</p>
<p>{printf &quot;%s &quot;,$2}}' user=$argv[1]` )
</p>
<p>foreach process ($killarray)
</p>
<p>kill -1 $process
</p>
<p>kill -15 $process &gt; /dev/null</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>62 The unix programming environment
</p>
<p>kill -9 $process &gt; /dev/null
</p>
<p>if (&quot;`kill -9 $process | egrep -e 'No such process'`&quot; == &quot;&quot;) then
</p>
<p>echo &quot;Warning - $process would not die - try again&quot;
</p>
<p>endif
</p>
<p>end
</p>
<p>#############################################################
</p>
<p># Start from a certain PID
</p>
<p>#############################################################
</p>
<p>else if ( $#argv == 2 ) then
</p>
<p>set killarray = ( `ps aux | awk '{ if ($1 == user &amp;&amp; $2 &gt; uid) \
</p>
<p>{printf &quot;%s &quot;,$2}}' user=$argv[1] uid=$argv[2]` )
</p>
<p>foreach process ($killarray)
</p>
<p>kill -1 $process &gt; /dev/null
</p>
<p>kill -15 $process
</p>
<p>sleep 2
</p>
<p>kill -9 $process &gt; /dev/null
</p>
<p>if (&quot;`kill -9 $process | egrep -e 'No such process'`&quot; == &quot;&quot;) then
</p>
<p>echo &quot;Warning - $process would not die - try again&quot;
</p>
<p>endif
</p>
<p>end
</p>
<p>endif
</p>
<p>This program would be better written in C or Perl.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 6: Bourne shell 63
</p>
<p>6 Bourne shell
</p>
<p>Programmers who are used to C or C++ often &#12;nd it easier to program in C-shell because
</p>
<p>there are strong similarities between the two. The Bourne shell is somewhat di&#11;erent in
</p>
<p>style, but is structured in a way which makes it better suited to more complicated script
</p>
<p>writing, especially for system administrators. Also it is closer to the kernels own exec
</p>
<p>mechanism. The Bourne shell allows subroutines and default values for parameters. Most
</p>
<p>of the system scripts in UNIX are written in the Bourne shell.
</p>
<p>The principles of the Bourne shell are largely the same as those for the C-shell, so we
</p>
<p>shall skip fairly quickly through the details. Historically, the Bourne shell came before the
</p>
<p>C shell.
</p>
<p>6.1 .pro&#12;le
</p>
<p>The `.profile' &#12;le is the Bourne shell's answer to `.cshrc'. This &#12;le is read by interac-
</p>
<p>tive `/bin/sh' shells on starting up. On Sun systems the &#12;le `/etc/profile' is also read.
</p>
<p>On `HPUX' machines, the &#12;le `/etc/src.sh' is read.
</p>
<p>6.2 Variables and export
</p>
<p>Local and global variables are both de&#12;ned using the syntax
</p>
<p>VARIABLE=&quot;Some string&quot;
</p>
<p>VAR=13
</p>
<p>It is important that there be no space between the variable and the equals sign. By default
</p>
<p>these variables are local. To make them global (so that child processes will inherit them)
</p>
<p>we use the command
</p>
<p>export VARIABLE
</p>
<p>This adds the variable to the process environment. It is the analogue of making `environment
</p>
<p>variables' with setenv in C shell. The command
</p>
<p>set -a
</p>
<p>changes the default so that all variables, after the command are created global.
</p>
<p>Arrays or lists are often simulated in shell by sandwiching the colon `:' symbol between
</p>
<p>items
</p>
<p>PATH=/bin:/usr/bin:/etc:/local/bin:.
</p>
<p>LD_LIBARAY_PATH=/usr/lib:/usr/openwin/lib:/local/lib
</p>
<p>but there is no real facility for arrays in the Bourne shell. Note that the UNIX `cut'
</p>
<p>command can be used to extract the elements of the list. Loops can also read such lists
</p>
<p>directly See Section 6.9 [Loops in sh], page 69. A Perl script can also be used.
</p>
<p>The value of a variable is given by the dollar symbol as in C-shell. It is also possible to
</p>
<p>use curly braces around the variable name to `protect' the variable from interfering text.
</p>
<p>For example:
</p>
<p>$ animal=worm
</p>
<p>$ echo book$animal</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>64 The unix programming environment
</p>
<p>bookworm
</p>
<p>$ thing=book
</p>
<p>$ echo $thingworm
</p>
<p>(nothing..)
</p>
<p>$ echo ${thing}worm
</p>
<p>bookworm
</p>
<p>Default values can be given to variables in the Bourne shell. The following commands
</p>
<p>illustrate this.
</p>
<p>echo ${var-&quot;No value set&quot;}
</p>
<p>echo ${var=&quot;Octopus&quot;}
</p>
<p>echo ${var+&quot;Forced value&quot;}
</p>
<p>echo ${var?&quot;No such variable&quot;}
</p>
<p>The &#12;rst of these prints out the contents of `$var', if it is de&#12;ned. If it is not de&#12;ned the
</p>
<p>variable is substituted for the string &quot;No value set&quot;. The value of `var' is not changed by
</p>
<p>this operation. It is only for convenience.
</p>
<p>The second command has the same e&#11;ect as the &#12;rst, but here the value of `$var' is
</p>
<p>actually changed to &quot;Octopus&quot; if `$var' is not set.
</p>
<p>The third version is slightly peculiar. If `$var' is already set, its value will be forced to
</p>
<p>be &quot;Forced value&quot;, otherwise it is left unde&#12;ned.
</p>
<p>Finally the last instance issues an error message &quot;No such variable&quot; if `$var' is not
</p>
<p>de&#12;ned.
</p>
<p>6.3 Stdin, stdout and stderr
</p>
<p>In the Bourne shell, the standard input/output &#12;les are referred to by numbers rather
</p>
<p>than by names.
</p>
<p>stdin File number 0
</p>
<p>stdout File number 1
</p>
<p>stderr File number 2
</p>
<p>The default routes for these &#12;les can be changed by redirection. The redirection commands
</p>
<p>are more complicated than in C-shell, but they are also more &#13;exible. Here is a comparison.
</p>
<p>sh csh Description
</p>
<p>command &gt; file command &gt; file Stdout to file
</p>
<p>command 1&gt; file command &gt; file Stdout to file
</p>
<p>command 2&gt; errs (No analogue) Stderr only to file errs
</p>
<p>command 1&gt; file 2&gt;&amp;1 command &gt;&amp; file stdout and stderr to file
</p>
<p>command 1&gt; file 2&gt; errs (No analogue) stdout to file, stderr to errs</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 6: Bourne shell 65
</p>
<p>6.4 Arithmetic in sh
</p>
<p>Arithmetic is performed entirely `by proxy'. There are no internal arithmetic operators
</p>
<p>as in the C-shell. To evaluate an expression we call the `expr' command or the `bc' precision
</p>
<p>calculator. Here are some examples of `expr'
</p>
<p>a=`expr $a+1` # increment a
</p>
<p>a=`expr 4 + 10 \* 5` # 4+10*5
</p>
<p>check = `expr $a \&gt; $b` # true=1, false=0. True if $a &gt; $b
</p>
<p>`expr' is very sensitive to spaces and backslash characters.
</p>
<p>6.5 Scripts and arguments
</p>
<p>Scripts are created by making an executable &#12;le which begins with the sequence of
</p>
<p>characters
</p>
<p>#!/bin/sh
</p>
<p>Although we didn't discuss it before, this construction is quite general: any executable &#12;le
</p>
<p>which begins with a sequence
</p>
<p>#!myprogram -option
</p>
<p>will cause the shell to attempt to execute
</p>
<p>myprogam -option filename
</p>
<p>where &#12;lename is the name of the &#12;le.
</p>
<p>If a script is to accept arguments then these can be referred to as ` $1 $2 $3..$9'. There
</p>
<p>is a logical limit of nine arguments to a script, but in practice it is possibile to get around
</p>
<p>this limitation. `$0' is the name of the script itself.
</p>
<p>Here is a simple script in the Bourne shell which prints out all its arguments.
</p>
<p>#!/bin/sh
</p>
<p>#
</p>
<p># Print all arguments (version 1)
</p>
<p>#
</p>
<p>for arg in $*
</p>
<p>do
</p>
<p>echo Argument $arg
</p>
<p>done
</p>
<p>echo Total number of arguments was $#
</p>
<p>The `$*' symbol stands for the entire list of arguments (like `$argv' in C-shell) and `$#' is
</p>
<p>the total number of arguments (like `$#argv' in C-shell).
</p>
<p>Another way of achieving the same is to use the `shift' command. We shall meet
</p>
<p>this again in the Perl programming language. `shift' takes the &#12;rst argument from the
</p>
<p>argument list and deletes it, moving all of the other arguments down one number { this is
</p>
<p>how we can handle long lists of arguments in `sh'.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>66 The unix programming environment
</p>
<p>#!/bin/sh
</p>
<p>#
</p>
<p># Print all arguments (version 2)
</p>
<p>#
</p>
<p>while ( true )
</p>
<p>do
</p>
<p>arg=$1;
</p>
<p>shift;
</p>
<p>echo $arg was an argument;
</p>
<p>if [ $# -eq 0 ]; then
</p>
<p>break
</p>
<p>fi
</p>
<p>done
</p>
<p>6.6 Return codes
</p>
<p>All programs which execute in UNIX return a value through the C `return' command.
</p>
<p>There is a convention that a return value of zero (0) means that everything went well,
</p>
<p>whereas any other value implies that some error occurred. The return value is usually the
</p>
<p>value returned in `errno', the extenal error variable in C.
</p>
<p>Shell scripts can test for these values either by placing the command directly inside an
</p>
<p>`if' test, or by testing the variable `$?' which is always set to the return code of the last
</p>
<p>command. Some examples are given following the next two sections.
</p>
<p>6.7 Tests and conditionals
</p>
<p>The Bourne shell has the usual array of tests. They are written as follows. Notice that
</p>
<p>`test' is itself not a part of the shell, but is a program which works out conditions and
</p>
<p>provides a return code. See the manual page on `test' for more details.
</p>
<p>test -f &#12;le
</p>
<p>True if the &#12;le is a plain &#12;le
</p>
<p>test -d &#12;le
</p>
<p>True if the &#12;le is a directory
</p>
<p>test -r &#12;le
</p>
<p>True if the &#12;le is readable
</p>
<p>test -w &#12;le
</p>
<p>True if the &#12;le is writable
</p>
<p>test -x &#12;le
</p>
<p>True if the &#12;le is executable
</p>
<p>test -s &#12;le
</p>
<p>True if the &#12;le contains something
</p>
<p>test -g &#12;le
</p>
<p>True if setgid bit is set</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 6: Bourne shell 67
</p>
<p>test -u &#12;le
</p>
<p>True if setuid bit is set
</p>
<p>test s1 = s2
</p>
<p>True if strings s1 and s2 are equal
</p>
<p>test s1 != s2
</p>
<p>True if strings s1 and s2 are unequal
</p>
<p>test x -eq y
</p>
<p>True if the integers x and y are numerically equal
</p>
<p>test x -ne y
</p>
<p>True if integers are not equal
</p>
<p>test x -gt y
</p>
<p>True if x is greater than y
</p>
<p>test x -lt y
</p>
<p>True if x is less than y
</p>
<p>test x -ge y
</p>
<p>True if x&gt;=y
</p>
<p>test x -le y
</p>
<p>True if x &lt;= y
</p>
<p>! Logical NOT operator
</p>
<p>-a Logical AND
</p>
<p>-o Logical OR
</p>
<p>Note that an alternate syntax for writing these commands if to use the square brackets,
</p>
<p>instead of writing the word test.
</p>
<p>[ $x -lt $y ] &quot;==&quot; test $x -lt $y
</p>
<p>The conditional structures have the following syntax.
</p>
<p>if unix-command
</p>
<p>then
</p>
<p>command
</p>
<p>else
</p>
<p>commands
</p>
<p>fi
</p>
<p>The `else' clause is, of course, optional. As noted before, the &#12;rst unix command could be
</p>
<p>anything, since every command has a return code. The result is TRUE if it evaluates to
</p>
<p>zero and false otherwise (in contrast to the conventions in most languages). Multiple tests
</p>
<p>can be made using
</p>
<p>if unix-command
</p>
<p>then
</p>
<p>commands
</p>
<p>elif unix-command
</p>
<p>then
</p>
<p>commands</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>68 The unix programming environment
</p>
<p>elif unix-command
</p>
<p>then
</p>
<p>commands
</p>
<p>else
</p>
<p>commands
</p>
<p>fi
</p>
<p>where `elif' means `else-if'.
</p>
<p>The equivalent of the C-school's `switch' statement is a more Pascal-like `case' struc-
</p>
<p>ture.
</p>
<p>case unix-command-or-variable in
</p>
<p>wildcard1) commands ;;
</p>
<p>wildcard2) commands ;;
</p>
<p>wildcard3) commands ;;
</p>
<p>esac
</p>
<p>This structure uses the wildcards to match the output of the command or variable in the
</p>
<p>&#12;rst line. The &#12;rst pattern which matches gets executed.
</p>
<p>6.8 Input from the user in sh
</p>
<p>In shell you can read the value of a variable using the `read' command, with syntax
</p>
<p>read variable
</p>
<p>This reads in a string from the keyboard and terminates on a newline character. Another
</p>
<p>way to do this is to use the `input' command to access a particular logical device. The
</p>
<p>keyboard device in the current terminal is `/dev/tty', so that one writes
</p>
<p>variable = `line &lt; /dev/tty`
</p>
<p>which fetches a single line from the user.
</p>
<p>Here are some examples of these commands. First a program which asks yes or no...
</p>
<p>#!/bin/sh
</p>
<p>#
</p>
<p># Yes or no
</p>
<p>#
</p>
<p>echo &quot;Please answer yes or no: &quot;
</p>
<p>answer=`line &lt; /dev/tty`
</p>
<p>case $answer in
</p>
<p>y* | Y* | j* | J* ) echo YES!! ;;
</p>
<p>n* | N* ) echo NO!! ;;
</p>
<p>*) echo &quot;Can't you answer a simple question?&quot;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 6: Bourne shell 69
</p>
<p>esac
</p>
<p>echo The end
</p>
<p>Notice the use of pattern matching and the `|' `OR' symbol.
</p>
<p>#!/bin/sh
</p>
<p>#
</p>
<p># Kernel check
</p>
<p>#
</p>
<p>if test ! -f /vmunix # Check that the kernel is there!
</p>
<p>then
</p>
<p>echo &quot;This is not BSD unix...hmmm&quot;
</p>
<p>if [ -f /hp-ux ]
</p>
<p>then
</p>
<p>echo &quot;It's a Hewlett Packard machine!&quot;
</p>
<p>fi
</p>
<p>elif [ -w /vmunix ]
</p>
<p>then
</p>
<p>echo &quot;HEY!! The kernel is writable my me!&quot;;
</p>
<p>else
</p>
<p>echo &quot;The kernel is write protected.&quot;
</p>
<p>echo &quot;The system is safe from me today.&quot;
</p>
<p>fi
</p>
<p>6.9 Loops in sh
</p>
<p>The loop structures in the Bourne shell have the following syntax.
</p>
<p>while unix-command
</p>
<p>do
</p>
<p>commands
</p>
<p>done
</p>
<p>The &#12;rst command will most likely be a test but, as before, it could in principle be any UNIX
</p>
<p>command. The `until' loop, reminiscent of BCPL, carries out a task until its argument
</p>
<p>evaluates to TRUE.
</p>
<p>until unix-command
</p>
<p>do
</p>
<p>commands
</p>
<p>done
</p>
<p>Finally the `for' structure has already been used above.
</p>
<p>for variable in list
</p>
<p>do
</p>
<p>commands
</p>
<p>done
</p>
<p>Often we want to be able to use an array of values as the list which for parses, but
</p>
<p>Bourne shell has no array variables. This problem is usually solved by making a long string
</p>
<p>separated by, for example, colons. For example, the $PATH variable has the form</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>70 The unix programming environment
</p>
<p>PATH = /usr/bin:/bin:/local/gnu/bin
</p>
<p>Bourne shell allows us to split such a string on whatever character we wish. Normally the
</p>
<p>split is made on spaces, but the variable `IFS' can be de&#12;ned with a replacement. To make
</p>
<p>a loop over all directories in the command path we would therefore write
</p>
<p>IFS=:
</p>
<p>for name in $PATH; do
</p>
<p>commands
</p>
<p>done
</p>
<p>The best way to gain experience with these commands is through some examples.
</p>
<p>#!/bin/sh
</p>
<p>#
</p>
<p># Get text from user repeatedly
</p>
<p>#
</p>
<p>echo &quot;Type away...&quot;
</p>
<p>while read TEXT
</p>
<p>do
</p>
<p>echo You typed $TEXT
</p>
<p>if [ &quot;$TEXT&quot; = &quot;quit&quot; ]; then
</p>
<p>echo &quot;(So I quit!)&quot;
</p>
<p>exit 0
</p>
<p>fi
</p>
<p>done
</p>
<p>echo &quot;HELP!&quot;
</p>
<p>This very simple script is a typical use for a while-loop. It gets text repeatedly until the
</p>
<p>user type `quit'. Since read never returns `false' unless an error occurs or it detects an EOF
</p>
<p>(end of &#12;le) character
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>, it will never exit without some help from an `if' test. If it
</p>
<p>does receive a
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>signal, the script prints `HELP!'.
</p>
<p>#!/bin/sh
</p>
<p>#
</p>
<p># Watch in the background for a particular user
</p>
<p># and give alarm if he/she logs in
</p>
<p>#
</p>
<p># To be run in the background, using &amp;
</p>
<p>#
</p>
<p>if [ $# -ne 1 ]; then
</p>
<p>echo &quot;Give the name of the user as an argument&quot; &gt; /dev/tty</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 6: Bourne shell 71
</p>
<p>exit 1
</p>
<p>fi
</p>
<p>echo &quot;Looking for $1&quot;
</p>
<p>until users | grep -s $1
</p>
<p>do
</p>
<p>sleep 60
</p>
<p>done
</p>
<p>echo &quot;!!! WAKE UP !!!&quot; &gt; /dev/tty
</p>
<p>echo &quot;User $1 just logged in&quot; &gt; /dev/tty
</p>
<p>This script uses `grep' in `silent mode' (-s option). i.e. grep never writes anything to
</p>
<p>the terminal. The only thing we are interested in is the return code the piped command
</p>
<p>produces. If `grep' detects a line containing the username we are interested in, then the
</p>
<p>result evaluates to TRUE and the sleep-loop exits.
</p>
<p>Our &#12;nal example is the kind of script which is useful for a system administrator. It
</p>
<p>transfers over the Network Information Service database &#12;les so that a slave server is up to
</p>
<p>date. All we have to do is make a list of the &#12;les and place it in a `for' loop. The names
</p>
<p>used below are the actual names of the NIS maps, well known to system administrators.
</p>
<p>#!/bin/sh
</p>
<p>#
</p>
<p># Update the NIS database maps on a client server. This program
</p>
<p># shouldn't have to be run, but sometimes things go wrong and we
</p>
<p># have to force a download from the main sever.
</p>
<p>#
</p>
<p>PATH=/etc/yp:/usr/etc/yp:$PATH
</p>
<p>MASTER=myNISserver
</p>
<p>for map in auto.direct auto.master ethers.byaddr ethers.byname\
</p>
<p>group.bygid group.byname hosts.byaddr hosts.byname\
</p>
<p>mail.aliases netgroup.byhost netgroup.byuser netgroup\
</p>
<p>netid.byname networks.byaddr networks.byname passwd.byname\
</p>
<p>passwd.byuid priss.byname protocols.byname protocols.bynumber\
</p>
<p>rpc.bynumber services.byname services usenetgroups.byname;
</p>
<p>do
</p>
<p>ypxfr $1 -h $MASTER $map
</p>
<p>done
</p>
<p>6.10 Procedures and traps
</p>
<p>One of the worthy features of the Bourne shell is that it allows you to de&#12;ne subroutines
</p>
<p>or procedures. Subroutines work just like subroutines in any other programming language.
</p>
<p>They are executed in same shell (not as a sub-process).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>72 The unix programming environment
</p>
<p>Here is an interesting program which demonstrates two useful things at the same time.
</p>
<p>First of all, it shows how to make a hierachical subroutine structure using the Bourne shell.
</p>
<p>Secondly, it shows how the `trap' directive can be used to trap signals, so that Bourne shell
</p>
<p>programs can exit safely when they are killed or when CTRL-C is typed.
</p>
<p>#!/bin/sh
</p>
<p>#
</p>
<p># How to make a signal handler in Bourne Shell
</p>
<p># using subroutines
</p>
<p>#
</p>
<p>#####################################################
</p>
<p># Level 2
</p>
<p>#####################################################
</p>
<p>ReallyQuit()
</p>
<p>{
</p>
<p>while true
</p>
<p>do
</p>
<p>echo &quot;Do you really want to quit?&quot;
</p>
<p>read answer
</p>
<p>case $answer in
</p>
<p>y* | Y* ) return 0;;
</p>
<p>*) echo &quot;Resuming...&quot;
</p>
<p>return 1;;
</p>
<p>esac
</p>
<p>done
</p>
<p>}
</p>
<p>#####################################################
</p>
<p># Level 1
</p>
<p>#####################################################
</p>
<p>SignalHandler()
</p>
<p>{
</p>
<p>if ReallyQuit # Call a function
</p>
<p>then
</p>
<p>exit 0
</p>
<p>else
</p>
<p>return 0
</p>
<p>fi
</p>
<p>}
</p>
<p>#####################################################
</p>
<p># Level 0 : main program</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 6: Bourne shell 73
</p>
<p>#####################################################
</p>
<p>trap SignalHandler 2 15 # Trap kill signals 2 and 15
</p>
<p>echo &quot;Type some lines of text...&quot;
</p>
<p>while read text
</p>
<p>do
</p>
<p>echo &quot;$text - CTRL-C to exit&quot;
</p>
<p>done
</p>
<p>Note that the logical tree structure of this program is upside down (the highest level
</p>
<p>comes at the bottom). This is because all subroutines must be de&#12;ned before they are used.
</p>
<p>This example concludes our brief survey of the Bourne shell.
</p>
<p>6.11 setuid and setgid scripts
</p>
<p>The superuser `root' is the only privileged user in UNIX. All other users have only
</p>
<p>restricted access to the system. Usually this is desirable, but sometimes it is a nuisance.
</p>
<p>A setuid script is a script which has its setuid-bit set. When such a script is executed
</p>
<p>by a user, it is run with all the rights and privileges of the owner of the script. All of the
</p>
<p>commands in the script are executed as the owner of the &#12;le and not with the user-id of the
</p>
<p>person who ran the script. If the owner of the setuid script is `root' then the commands in
</p>
<p>the script are run with root privileges!
</p>
<p>Setuid scripts are clearly a touchy security issue. When giving away one's rights to
</p>
<p>another user (especially those of `root') one is tempting hackers. Setuid scripts should be
</p>
<p>avoided.
</p>
<p>A setgid program is almost the same, but only the group id is set to that of the owner
</p>
<p>of the &#12;le. Often the e&#11;ect is the same.
</p>
<p>An example of a setuid program is the `ps' program. `ps' lists all of the processes running
</p>
<p>in the kernel. In order to do this it needs permission to access the private data structures in
</p>
<p>the kernel. By making `ps' setgid root, it allows ordinary users to be able to read as much
</p>
<p>as the writers of `ps' thought &#12;t, but no more.
</p>
<p>Naturally, only the superuser can make a &#12;le setuid or setgid root.
</p>
<p>6.12 Summary: Limitations of shell programming
</p>
<p>To summarize the last two long and oppressive chapters we shall take a step back from
</p>
<p>the details and look at what we have achieved.
</p>
<p>The idea behind the shell is to provide a user interface, with access to the system's
</p>
<p>facilities at a simple level. In the 70's user interfaces were not deisgned to be user-friendly.
</p>
<p>The UNIX shell is not particularly use friendly, but it is very powerful. Perhaps it would
</p>
<p>have been enough to provide only commands to allow users to write C programs. Since</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>74 The unix programming environment
</p>
<p>all of the system functions are available from C, that would certainly allow everyone to do
</p>
<p>what anything that UNIX can do. But shell programming is much more immediate than
</p>
<p>C. It is an environment of frequently used tools. Also for quick programming solutions: C is
</p>
<p>a compiled language, whereas the shell is an interpreter. A quick shell program can solve
</p>
<p>many problems in no time at all, without having to compile anything.
</p>
<p>Shell programming is only useful for `quick and easy' programs. To use it for anything
</p>
<p>serious is an abuse. Programming di&#14;cult things in shell is clumsy, and it is di&#14;cult to
</p>
<p>get returned-information (like error messages) back in a useful form. Besides, shell scripts
</p>
<p>are slow compared to real programs since they involve starting a new program for each new
</p>
<p>command.
</p>
<p>These di&#14;culties are solved partly by Perl, which we shall consider next { but in the
</p>
<p>&#12;nal analysis, real programs of substance need to be written in C. Contrary to popular
</p>
<p>belief, this is not more di&#14;cult than programming in the shell { in fact, many things are
</p>
<p>much simpler, because all of the shell commands originated as C functions. The shell is an
</p>
<p>extra layer of the UNIX onion which we have to battle our way through to get where we're
</p>
<p>going.
</p>
<p>Sometimes it is helpful to be shielded from low level details { sometimes it is a hindrance.
</p>
<p>In the remaining chapters we shall consider more involved programming needs.
</p>
<p>6.13 Exercises
</p>
<p>1. Write an improved `which' command in C-shell.
</p>
<p>2. Make a counter program which records in a &#12;le how many times you log in to your
</p>
<p>account. You can call this in your .cshrc &#12;le.
</p>
<p>3. Make a Bourne shell script to kill all the processes owned by a particular user. (Note,
</p>
<p>that if you are not the superuser, you cannot kill processes owned by other users.)
</p>
<p>4. Write a script to replace the `rm' command with something safer. Think about a way
</p>
<p>of implementing `rm' so that it is possible to get deleted &#12;les back again in case of
</p>
<p>emergencies. This is not possible using the normal `rm' command. Hint: save &#12;les in a
</p>
<p>hidden directory `.deleted'. Make your script delete &#12;les in the `.deleted' directory
</p>
<p>if they are older than a week, so that you don't &#12;ll up the disk with rubbish.
</p>
<p>5. Suppose you have a bunch of &#12;les with a particular &#12;le-extension: write a script in csh
</p>
<p>to change the extension to something else. e.g. to change *.C into *.c. Give the old
</p>
<p>and new extensions as arguments to the script.
</p>
<p>6. Write a program in sh to search for &#12;les in the current directory which contain a
</p>
<p>certain string. e.g. search for all &#12;les which contain the word &quot;if&quot;. Hint: use the &quot;&#12;nd&quot;
</p>
<p>command.
</p>
<p>7. Use the manual pages to &#12;nd out about the commands `at', `batch' and `atq'. Test
</p>
<p>these commands by executing the shell command `date' at some time of your choice.
</p>
<p>Use the `-m' option so that the result of the job is mailed to you.
</p>
<p>8. Write a script in sh or csh to list all of the &#12;les bigger than a certain size starting from
</p>
<p>the current directory, and including all subdirectories. This kind of program is useful
</p>
<p>for system administrators when a disk becomes full.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 75
</p>
<p>7 Perl
</p>
<p>So far, we have been looking at shell programming for performing fairly simple tasks.
</p>
<p>Now let's extend the idea of shell programming to cover more complex tasks like systems
</p>
<p>programming and network communications. Perl is a language which was designed to retain
</p>
<p>the immediateness of shell languages, but at the same time capture some of the &#13;exibility
</p>
<p>of C. Perl is an acronym for Practical extraction and report language. In this chapter, we
</p>
<p>shall not aim to teach Perl from scratch { the best way to learn it is to use it! Rather we
</p>
<p>shall concentrate on demonstrating some principles.
</p>
<p>7.1 Sed and awk, cut and paste
</p>
<p>One of the reasons for using Perl is that it is extremely good at text&#12;le handling{one of
</p>
<p>the most important things for UNIX users, and particularly useful in connection with CGI
</p>
<p>script processing on the World Wide Web. It has simple built-in constructs for searching
</p>
<p>and replacing text, storing information in arrays and retrieving them in sorted form. All of
</p>
<p>the these things have previously been possible using the UNIX shell commands
</p>
<p>sed
</p>
<p>awk
</p>
<p>cut
</p>
<p>paste
</p>
<p>but these commands were designed to work primarily in the Bourne shell and are a bit
</p>
<p>`awk'ward to use for all but the simplest applications.
</p>
<p>`sed' is a stream editor. It takes command line instructions, reads input from the
</p>
<p>stream stdin and produces output on stdout according to those instructions.
</p>
<p>`sed' works line by line from the start of a text&#12;le.
</p>
<p>`awk' is a pattern matching and processing language. It takes a text&#12;le and reads it
</p>
<p>line by line, matching regular expressions and acting on them. `awk' is powerful
</p>
<p>enough to have conditional instructions like `if..then..else' and uses C's
</p>
<p>`printf' construction for output.
</p>
<p>`cut' Takes a line of input and cuts it into &#12;elds, separated by some character. For
</p>
<p>instance, a normal line of text is a string of words separated by spaces. Each
</p>
<p>word is a di&#11;erent &#12;eld. `cut' can be used, for instance, to pick out the third
</p>
<p>column in a table. Any character can be speci&#12;ed as the separator.
</p>
<p>`paste' is the logical opposite of cut. It concatenates n &#12;les, and makes each line in the
</p>
<p>&#12;le into a column of a table. For instance, `paste one two three' would make
</p>
<p>a table in which the &#12;rst column consisted of all lines in `one', the second of all
</p>
<p>lines in `two' and the third of all lines in `three'. If one &#12;le is longer than the
</p>
<p>others, then some columns have blank spaces.
</p>
<p>Perl uni&#12;es all of these operations and more. It also makes them much simpler.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>76 The unix programming environment
</p>
<p>7.2 Program structure
</p>
<p>To summarize Perl, we need to know about the structure of a Perl program, the con-
</p>
<p>ditional constructs it has, its loops and its variables. In the latest versions of Perl (Perl
</p>
<p>5), you can write object oriented programs of great complexity. We shall not go into this
</p>
<p>depth, for the simple reason that Perl's strength is not as a general programming language
</p>
<p>but as a specialized language for text&#12;le handling. The syntax of Perl is in many ways like
</p>
<p>the C programming language, but there are important di&#11;erences.
</p>
<p>&#15; Variables do not have types. They are interpreted in a context sensitive way. The
</p>
<p>operators which acts upon variables determine whether a variable is to be considered
</p>
<p>a string or as an integer etc.
</p>
<p>&#15; Although there are no types, Perl de&#12;nes arrays of di&#11;erent kinds. There are three
</p>
<p>di&#11;erent kinds of array, labelled by the symbols `$', `@' and `%'.
</p>
<p>&#15; Perl keeps a number of standard variables with special names e.g. `$_ @ARGV' and
</p>
<p>`%ENV'. Special attention should be paid to these. They are very important!
</p>
<p>&#15; The shell reverse apostrophe notation `command` can be used to execute UNIX pro-
</p>
<p>grams and get the result into a Perl variable.
</p>
<p>Here is a simple `structured hello world' program in Perl. Notice that subroutines are
</p>
<p>called using the `&amp;' symbol. There is no special way of marking the main program { it is
</p>
<p>simply that part of the program which starts at line 1.
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Comments
</p>
<p>#
</p>
<p>&amp;Hello();
</p>
<p>&amp;World;
</p>
<p># end of main
</p>
<p>sub Hello
</p>
<p>{
</p>
<p>print &quot;Hello&quot;;
</p>
<p>}
</p>
<p>sub World
</p>
<p>{
</p>
<p>print &quot;World\n&quot;;
</p>
<p>}
</p>
<p>The parentheses on subroutines are optional, if there are no parameters passed. Notice that
</p>
<p>each line must end in a semi-colon.
</p>
<p>7.3 Perl variables</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 77
</p>
<p>7.3.1 Scalar variables
</p>
<p>In Perl, variables do not have to be declared before they are used. Whenever you use
</p>
<p>a new symbol, Perl automatically adds the symbol to its symbol table and initializes the
</p>
<p>variable to the empty string.
</p>
<p>It is important to understand that there is no practical di&#11;erence between zero and the
</p>
<p>empty string in perl { except in the way that you, the user, choose to use it. Perl makes
</p>
<p>no distinction between strings and integers or any other types of data { except when it
</p>
<p>wants to interpret them. For instance, to compare two variables as strings is not the same
</p>
<p>as comparing them as integers, even if the string contains a textual representation of an
</p>
<p>integer. Take a look at the following program.
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Nothing!
</p>
<p>#
</p>
<p>print &quot;Nothing == $nothing\n&quot;;
</p>
<p>print &quot;Nothing is zero!\n&quot; if ($nothing == 0);
</p>
<p>if ($nothing eq &quot;&quot;)
</p>
<p>{
</p>
<p>print STDERR &quot;Nothing is really nothing!\n&quot;;
</p>
<p>}
</p>
<p>$nothing = 0;
</p>
<p>print &quot;Nothing is now $nothing\n&quot;;
</p>
<p>The output from this program is
</p>
<p>Nothing ==
</p>
<p>Nothing is zero!
</p>
<p>Nothing is really nothing!
</p>
<p>Nothing is now 0
</p>
<p>There are several important things to note here. First of all, we never declare the variable
</p>
<p>`nothing'. When we try to write its value, perl creates the name and associates a NULL
</p>
<p>value to it i.e. the empty string. There is no error. Perl knows it is a variable because of
</p>
<p>the `$' symbol in front of it. All scalar variables are identi&#12;ed by using the dollar symbol.
</p>
<p>Next, we compare the value of `$nothing' to the integer `0' using the integer comparison
</p>
<p>symbol `==', and then we compare it to the empty string using the string comparison symbol
</p>
<p>`eq'. Both tests are true! That means that the empty string is interpreted as having a
</p>
<p>numerical value of zero. In fact any string which does not form a valid integer number has
</p>
<p>a numerical value of zero.
</p>
<p>Finally we can set `$nothing' explicitly to a valid integer string zero, which would now
</p>
<p>pass the &#12;rst test, but fail the second.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>78 The unix programming environment
</p>
<p>As extra spice, this program also demonstrates two di&#11;erent ways of writing the `if'
</p>
<p>command in perl.
</p>
<p>7.3.2 The default scalar variable.
</p>
<p>The special variable `$_' is used for many purposes in Perl. It is used as a bu&#11;er to contain
</p>
<p>the result of the last operation, the last line read in from a &#12;le etc. It is so general that
</p>
<p>many functions which act on scalar variables work by default on `$_' if no other argument
</p>
<p>is speci&#12;ed. For example,
</p>
<p>print;
</p>
<p>is the same as
</p>
<p>print $_;
</p>
<p>7.3.3 Array (vector) variables
</p>
<p>The complement of scalar variables is arrays. An array, in Perl is identi&#12;ed by the `@'
</p>
<p>symbol and, like scalar variables, is allocated and initialized dynamically.
</p>
<p>@array[0] = &quot;This little piggy went to market&quot;;
</p>
<p>@array[2] = &quot;This little piggy stayed at home&quot;;
</p>
<p>print &quot;@array[0] @array[1] @array[2]&quot;;
</p>
<p>The index of an array is always understood to be a number, not a string, so if you use a
</p>
<p>non-numerical string to refer to an array element, you will always get the zeroth element,
</p>
<p>since a non-numerical string has an integer value of zero.
</p>
<p>An important array which every program de&#12;nes is
</p>
<p>@ARGV
</p>
<p>This is the argument vector array, and contains the commands line arguments by analogy
</p>
<p>with the C-shell variable `$argv[]'.
</p>
<p>Given an array, we can &#12;nd the last element by using the `$#' operator. For example,
</p>
<p>$last_element = $ARGV[$#ARGV];
</p>
<p>Notice that each element in an array is a scalar variable. The `$#' cannot be interpreted
</p>
<p>directly as the number of elements in the array, as it can in the C-shell. You should
</p>
<p>experiment with the value of this quantity { it often necessary to add 1 or 2 to its value in
</p>
<p>order to get the behaviour one is used to in the C-shell.
</p>
<p>Perl does not support multiple-dimension arrays directly, but it is possible to simulate
</p>
<p>them yourself. (See the Perl book.)
</p>
<p>7.3.4 Special array commands
</p>
<p>The `shift' command acts on arrays and returns and removes the &#12;rst element of the
</p>
<p>array. Afterwards, all of the elements are shifted down one place. So one way to read the
</p>
<p>elements of an array in order is to repeatedly call `shift'.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 79
</p>
<p>$next_element=shift(@myarray);
</p>
<p>Note that, if the array argument is omitted, then `shift' works on `@ARGV' by default.
</p>
<p>Another useful function is `split', which takes a string and turns it into an array
</p>
<p>of strings. `split' works by choosing a character (usually a space) to delimit the array
</p>
<p>elements, so a string containing a sentence separated by spaces would be turned into an
</p>
<p>array of words. The syntax is
</p>
<p>@array = split; # works with spaces on $_
</p>
<p>@array = split(pattern,string); # Breaks on pattern
</p>
<p>($v1,$v2...) = split(pattern,string); # Name array elements with scalars
</p>
<p>In the &#12;rst of these cases, it is assumed that the variable `$_' is to be split on whitespace
</p>
<p>characters. In the second case, we decide on what characterthe split is to take place and on
</p>
<p>what string the function is to act. For instance
</p>
<p>@new_array = split(&quot;:&quot;,&quot;name:passwd:uid:gid:gcos:home:shell&quot;);
</p>
<p>The result is a seven element array called `@new_array', where `$new_array[0]' is `name'
</p>
<p>etc.
</p>
<p>In the &#12;nal example, the left hand side shows that we wish to capture elements of the array
</p>
<p>in a named set of scalar variables. If the number of variables on the lefthand side is fewer
</p>
<p>than the number of strings which are generated on the right hand side, they are discarded.
</p>
<p>If the number on the left hand side is greater, then the remainder variables are empty.
</p>
<p>7.3.5 Associated arrays
</p>
<p>One of the very nice features of Perl is the ability to use one string as an index to
</p>
<p>another string in an array. For example, we can make a short encyclopaedia of zoo animals
</p>
<p>by constructing an associative array in which the keys (or indices) of the array are the
</p>
<p>names of animals, and the contents of the array are the information about them.
</p>
<p>$animals{&quot;Penguin&quot;} = &quot;A suspicious animal, good with cheese crackers...&quot;;
</p>
<p>$animals{&quot;dog&quot;} = &quot;Plays stupid, but could be a cover...&quot;;
</p>
<p>if ($index eq &quot;fish&quot;)
</p>
<p>{
</p>
<p>$animals{$index} = &quot;Often comes in square boxes. Very cold.&quot;;
</p>
<p>}
</p>
<p>An entire associated array is written `%array', while the elements are `$array{$key}'.
</p>
<p>Perl provides a special associative array for every program called `%ENV'. This contains
</p>
<p>the environment variables de&#12;ned in the parent shell which is running the Perl program.
</p>
<p>For example
</p>
<p>print &quot;Username = $ENV{&quot;USER&quot;}\n&quot;;
</p>
<p>$ld = &quot;LD_LIBRARY_PATH&quot;;
</p>
<p>print &quot;The link editor path is $ENV{$ld}\n&quot;;
</p>
<p>To get the current path into an ordinary array, one could write,
</p>
<p>@path_array= split(&quot;:&quot;,$ENV{&quot;PATH&quot;});</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>80 The unix programming environment
</p>
<p>7.3.6 Array example program
</p>
<p>Here is an example which prints out a list of &#12;les in a speci&#12;ed directory, in order of
</p>
<p>their UNIX protection bits. The least protected &#12;le &#12;les come &#12;rst.
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Demonstration of arrays and associated arrays.
</p>
<p># Print out a list of files, sorted by protection,
</p>
<p># so that the least secure files come first.
</p>
<p>#
</p>
<p># e.g. arrays &lt;list of words&gt;
</p>
<p># arrays *.C
</p>
<p>#
</p>
<p>############################################################
</p>
<p>print &quot;You typed in &quot;,$#ARGV+1,&quot; arguments to command\n&quot;;
</p>
<p>if ($#ARGV &lt; 1)
</p>
<p>{
</p>
<p>print &quot;That's not enough to do anything with!\n&quot;;
</p>
<p>}
</p>
<p>while ($next_arg = shift(@ARGV))
</p>
<p>{
</p>
<p>if ( ! ( -f $next_arg || -d $next_arg))
</p>
<p>{
</p>
<p>print &quot;No such file: $next_arg\n&quot;;
</p>
<p>next;
</p>
<p>}
</p>
<p>($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size) = stat($next_arg);
</p>
<p>$octalmode = sprintf(&quot;%o&quot;,$mode &amp; 0777);
</p>
<p>$assoc_array{$octalmode} .= $next_arg.
</p>
<p>&quot; : size (&quot;.$size.&quot;), mode (&quot;.$octalmode.&quot;)\n&quot;;
</p>
<p>}
</p>
<p>print &quot;In order: LEAST secure first!\n\n&quot;;
</p>
<p>foreach $i (reverse sort keys(%assoc_array))
</p>
<p>{
</p>
<p>print $assoc_array{$i};
</p>
<p>}</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 81
</p>
<p>7.4 Loops and conditionals
</p>
<p>Here are some of the most commonly used decision-making constructions and loops in
</p>
<p>Perl. The following is not a comprehensive list { for that, you will have to look in the
</p>
<p>Perl bible: Programming Perl, by Larry Wall and Randal Schwartz. The basic pattern
</p>
<p>follows the C programming language quite closely. In the case of the `for' loop, Perl has
</p>
<p>both the C-like version, called `for' and a `foreach' command which is like the C-shell
</p>
<p>implementation.
</p>
<p>if (expression)
</p>
<p>{
</p>
<p>block;
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>block;
</p>
<p>}
</p>
<p>command if (expression);
</p>
<p>unless (expression)
</p>
<p>{
</p>
<p>block;
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>block;
</p>
<p>}
</p>
<p>while (expression)
</p>
<p>{
</p>
<p>block;
</p>
<p>}
</p>
<p>do
</p>
<p>{
</p>
<p>block;
</p>
<p>}
</p>
<p>while (expression);
</p>
<p>for (initializer; expression; statement)
</p>
<p>{
</p>
<p>block;
</p>
<p>}
</p>
<p>foreach variable(array)
</p>
<p>{
</p>
<p>block;
</p>
<p>}</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>82 The unix programming environment
</p>
<p>In all cases, the `else' clauses may be omitted.
</p>
<p>Strangely, perl does not have a `switch' statement, but the Perl book describes how to
</p>
<p>make one using the features provided.
</p>
<p>7.4.1 The for loop
</p>
<p>The for loop is exactly like that in C or C++ and is used to iterate over a numerical
</p>
<p>index, like this:
</p>
<p>for ($i = 0; $i &lt; 10; $i++)
</p>
<p>{
</p>
<p>print $i, &quot;\n&quot;;
</p>
<p>}
</p>
<p>7.4.2 The foreach loop
</p>
<p>The foreach loop is like its counterpart in the C shell. It is used for reading elements
</p>
<p>one by one from a regular array. For example,
</p>
<p>foreach $i ( @array )
</p>
<p>{
</p>
<p>print $i, &quot;\n&quot;;
</p>
<p>}
</p>
<p>7.4.3 Iterating over elements in arrays
</p>
<p>One of the main uses for `for' type loops is to iterate over successive values in an array.
</p>
<p>This can be done in two ways which show the essential di&#11;erence between for and foreach.
</p>
<p>If we want to fetch each value in an array in turn, without caring about numerical indices,
</p>
<p>the it is simpest to use the foreach loop.
</p>
<p>@array = split(&quot; &quot;,&quot;a b c d e f g&quot;);
</p>
<p>foreach $var ( @array )
</p>
<p>{
</p>
<p>print $var, &quot;\n&quot;;
</p>
<p>}
</p>
<p>This example prints each letter on a separate line. If, on the other hand, we are interested
</p>
<p>in the index, for the purposes of some calculation, then the for loop is preferable.
</p>
<p>@array = split(&quot; &quot;,&quot;a b c d e f g&quot;);
</p>
<p>for ($i = 0; $i &lt;= $#array; $i++)
</p>
<p>{</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 83
</p>
<p>print $array[$i], &quot;\n&quot;;
</p>
<p>}
</p>
<p>Notice that, unlike the for-loop idiom in C/C++, the limit is `$i &lt;= $#array', i.e. `less than
</p>
<p>or equal to' rather than `less than'. This is because the `$#' operator does not return the
</p>
<p>number of elements in the array but rather the last element.
</p>
<p>Associated arrays are slightly di&#11;erent, since they do not use numerical keys. Instead
</p>
<p>they use a set of strings, like in a database, so that you can use one string to look up another.
</p>
<p>In order to iterate over the values in the array we need to get a list of these strings. The
</p>
<p>keys command is used for this.
</p>
<p>$assoc{&quot;mark&quot;} = &quot;cool&quot;;
</p>
<p>$assoc{&quot;GNU&quot;} = &quot;brave&quot;;
</p>
<p>$assoc{&quot;zebra&quot;} = &quot;stripy&quot;;
</p>
<p>foreach $var ( keys %assoc )
</p>
<p>{
</p>
<p>print &quot;$var , $assoc{$var} \n&quot;;
</p>
<p>}
</p>
<p>The order of the keys is not de&#12;ned in the above example, but you can choose to sort them
</p>
<p>alphabetically by writing
</p>
<p>foreach $var ( sort keys %assoc )
</p>
<p>instead.
</p>
<p>7.4.4 Iterating over lines in a &#12;le
</p>
<p>Since Perl is about &#12;le handling we are very interested in reading &#12;les. Unlike C and
</p>
<p>C++, perl likes to read &#12;les line by line. The angle brackets are used for this, See Section 7.5
</p>
<p>[Files in perl], page 84. Assuming that we have some &#12;le handle `&lt;file&gt;', for instance
</p>
<p>`&lt;STDIN&gt;', we can always read the &#12;le line by line with a while-loop like this.
</p>
<p>while ($line = &lt;file&gt;)
</p>
<p>{
</p>
<p>print $line;
</p>
<p>}
</p>
<p>Note that $line includes the end of line character on the end of each line. If you want to
</p>
<p>remove it, you should add a `chop' command:
</p>
<p>while ($line = &lt;file&gt;)
</p>
<p>{
</p>
<p>chop $line;
</p>
<p>print &quot;line = ($line)\n&quot;;
</p>
<p>}</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>84 The unix programming environment
</p>
<p>7.5 Files in perl
</p>
<p>Opening &#12;les is straightforward in Perl. Files must be opened and closed using { wait
</p>
<p>for it { the commands `open' and `close'. You should be careful to close &#12;les after you
</p>
<p>have &#12;nished with them { especially if you are writing to a &#12;le. Files are bu&#11;ered and often
</p>
<p>large parts of a &#12;le are not actually written until the `close' command is received.
</p>
<p>Three &#12;les are, of course, always open for every program, namely `STDIN', `STDOUT'and
</p>
<p>`STDERR'.
</p>
<p>Formally, to open a &#12;le, we must obtain a &#12;le descriptor or &#12;le handle. This is done
</p>
<p>using `open';
</p>
<p>open (file_descrip,&quot;Filename&quot;);
</p>
<p>The angular brackets `&lt;..&gt;' are used to read from the &#12;le. For example,
</p>
<p>$line = &lt;file_descrip&gt;;
</p>
<p>reads one line from the &#12;le associated with `file_descrip'.
</p>
<p>Let's look at some examples of &#12;ling opening. Here is how we can implement UNIX's
</p>
<p>`cut' and `paste' commands in perl:
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Cut in perl
</p>
<p>#
</p>
<p># Cut second column
</p>
<p>while (&lt;&gt;)
</p>
<p>{
</p>
<p>@cut_array = split;
</p>
<p>print &quot;@cut_array[1]\n&quot;;
</p>
<p>}
</p>
<p>This is the simplest way to open a &#12;le. The empty &#12;le descriptor `&lt;&gt;' tells perl to take the
</p>
<p>argument of the command as a &#12;lename and open that &#12;le for reading. This is really short
</p>
<p>for `while($_=&lt;STDIN&gt;)' with the standard input redirected to the named &#12;le.
</p>
<p>The `paste'program can be written as follows:
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Paste in perl
</p>
<p>#
</p>
<p># Two files only, syntax : paste file 1file2
</p>
<p>#
</p>
<p>open (file1,&quot;@ARGV[0]&quot;) || die &quot;Can't open @ARGV[0]\n&quot;;
</p>
<p>open (file2,&quot;@ARGV[1]&quot;) || die &quot;Can't open @ARGV[1]\n&quot;;
</p>
<p>while (($line1 = &lt;file1&gt;) || ($line2 = &lt;file2&gt;))</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 85
</p>
<p>{
</p>
<p>chop $line1;
</p>
<p>chop $line2;
</p>
<p>print &quot;$line1 $line2\n&quot;; # tab character between
</p>
<p>}
</p>
<p>Here we see more formally how to read from two separate &#12;les at the same time. Notice
</p>
<p>that, by putting the read commands into the test-expression for the `while' loop, we are
</p>
<p>using the fact that `&lt;..&gt;' returns a non-zero (true) value unless we have reached the end of
</p>
<p>the &#12;le.
</p>
<p>To write and append to &#12;les, we use the shell redirection symbols inside the `open'
</p>
<p>command.
</p>
<p>open(fd,&quot;&gt; filename&quot;); # open file for writing
</p>
<p>open(fd,&quot;&gt;&gt; filename&quot;); # open file for appending
</p>
<p>We can also open a pipe from an arbitrary UNIX command and receive the output of that
</p>
<p>command as our input:
</p>
<p>open (fd,&quot;/bin/ps aux | &quot;);
</p>
<p>7.5.1 A simple perl program
</p>
<p>Let us now write the simplest perl program which illustrates the way in which perl can
</p>
<p>save time. We shall write it in three di&#11;erent ways to show what the short cuts mean. Let
</p>
<p>us implement the `cat' command, which copies &#12;les to the standard output. The simplest
</p>
<p>way to write this is perl is the following:
</p>
<p>#!/local/bin/perl
</p>
<p>while (&lt;&gt;)
</p>
<p>{
</p>
<p>print;
</p>
<p>}
</p>
<p>Here we have made heavy use of the many default assumptions which perl makes. The
</p>
<p>program is simple, but di&#14;cult to understand for novices. First of all we use the default &#12;le
</p>
<p>handle &lt;&gt; which means, take one line of input from a default &#12;le. This object returns true
</p>
<p>as long as it has not reached the end of the &#12;le, so this loop continues to read lines until it
</p>
<p>reaches the end of &#12;le. The default &#12;le is standard input, unless this script is invoked with
</p>
<p>a command line argument, in which case the argument is treated as a &#12;lename and perl
</p>
<p>attempts to open the argument-&#12;lename for reading. The print statement has no argument
</p>
<p>telling it what to print, but perl takes this to mean: print the default variable `$_'.
</p>
<p>We can therefore write this more explicitly as follows:
</p>
<p>#!/local/bin/perl
</p>
<p>open (HANDLE,&quot;$ARGV[1]&quot;);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>86 The unix programming environment
</p>
<p>while (&lt;HANDLE&gt;)
</p>
<p>{
</p>
<p>print $_;
</p>
<p>}
</p>
<p>Here we have simply &#12;lled in the assumptions explicitly. The command `&lt;HANDLE&gt;' now
</p>
<p>reads a single line from the named &#12;le-handle into the default variable `$_'. To make this
</p>
<p>program more general, we can elimiate the defaults entirely.
</p>
<p>#!/local/bin/perl
</p>
<p>open (HANDLE,&quot;$ARGV[1]&quot;);
</p>
<p>while ($line=&lt;HANDLE&gt;)
</p>
<p>{
</p>
<p>print $line;
</p>
<p>}
</p>
<p>7.5.2 == and `eq'
</p>
<p>Be careful to distinguish between the comparison operator for integers `==' and the
</p>
<p>corresponding operator for strings `eq'. These do not work in each other's places so if you
</p>
<p>get the wrong comparison operator your program might not work and it is quite di&#14;cult to
</p>
<p>&#12;nd the error.
</p>
<p>7.5.3 chop
</p>
<p>The command `chop' cuts o&#11; the last character of a string. This is useful for removing
</p>
<p>newline characters when reading &#12;les etc. The syntax is
</p>
<p>chop; # chop $_;
</p>
<p>chop $scalar; # remove last character in $scalar
</p>
<p>7.6 Perl subroutines
</p>
<p>Subroutines are indicated, as in the example above, by the ampersand `&amp;' symbol. When
</p>
<p>parameters are passed to a Perl subroutine, they are handed over as an array called `@_'.
</p>
<p>Which is analogous to the `$_' variable. Here is a simple example:
</p>
<p>#!/local/bin/perl
</p>
<p>$a=&quot;silver&quot;;
</p>
<p>$b=&quot;gold&quot;;
</p>
<p>&amp;PrintArgs($a,$b);
</p>
<p># end of main
</p>
<p>sub PrintArgs</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 87
</p>
<p>{
</p>
<p>($local_a,$local_b) = @_;
</p>
<p>print &quot;$local_a, $local_b\n&quot;;
</p>
<p>}
</p>
<p>7.7 die - exit on error
</p>
<p>When a program has to quit and give a message, the `die' command is normally used.
</p>
<p>If called without an argument, Perl generates its own message including a line number at
</p>
<p>which the error occurred. To include your own message, you write
</p>
<p>die &quot;My message....&quot;;
</p>
<p>If the string is terminated with a `\n' newline character, the line number of the error is not
</p>
<p>printed, otherwise Perl appends the line number to your string.
</p>
<p>When opening &#12;les, it is common to see the syntax:
</p>
<p>open (filehandle,&quot;Filename&quot;) || die &quot;Can't open...&quot;;
</p>
<p>The logical `OR' symbol is used, because `open' returns true if all goes well, in which case
</p>
<p>the right hand side is never evaluated. If `open' is false, then die is executed. You can
</p>
<p>decide for yourself whether or not you think this is good programming style { we mention
</p>
<p>it here because it is common practice.
</p>
<p>7.8 The stat() idiom
</p>
<p>The unix library function stat() is used to &#12;nd out information about a given &#12;le. This
</p>
<p>function is available both in C and in Perl. In perl, it returns an array of values. Usually we
</p>
<p>are interested in knowing the access permissions of a &#12;le. stat() is called using the syntax
</p>
<p>@array = stat (&quot;&#12;lename&quot;);
</p>
<p>or alternatively, using a named array
</p>
<p>($device,$inode,$mode) = stat(&quot;&#12;lename&quot;);
</p>
<p>The value returned in the mode variable is a bit-pattern, See Section 4.1 [Protection
</p>
<p>bits], page 37. The most useful way of treating these bit patterns is to use octal numbers
</p>
<p>to interpret their meaning.
</p>
<p>To &#12;nd out whether a &#12;le is readable or writable to a group of users, we use a program-
</p>
<p>ming idiom which is very common for dealing with bit patterns: &#12;rst we de&#12;ne a mask
</p>
<p>which zeroes out all of the bits in the mode string except those which we are speci&#12;cally
</p>
<p>interested in. This is done by de&#12;ning a mask value in which the bits we want are set to 1
</p>
<p>and all others are set to zero. Then we AND the mask with the mode string. If the result
</p>
<p>is di&#11;erent from zero then we know that all of the bits were also set in the mode string. As
</p>
<p>in C, the bitwise AND operator in perl is called `&amp;'.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>88 The unix programming environment
</p>
<p>For example, to test whether a &#12;le is writable to other users in the same group as the
</p>
<p>&#12;le, we would write the following.
</p>
<p>$mask = 020; # Leading 0 means octal number
</p>
<p>($device,$inode,$mode) = stat(&quot;&#12;le&quot;);
</p>
<p>if ($mode &amp; $mask)
</p>
<p>{
</p>
<p>print &quot;File is writable by the group\n&quot;;
</p>
<p>}
</p>
<p>Here the 2 in the second octal number means &quot;write&quot;, the fact that it is the second octal
</p>
<p>number from the right means that it refers to &quot;group&quot;. Thus the result of the if-test is only
</p>
<p>true if that particular bit is true. We shall see this idiom in action below.
</p>
<p>7.9 Perl example programs
</p>
<p>7.9.1 The passwd program and `crypt()' function
</p>
<p>Here is a simple implementation of the UNIX `passwd' program in Perl.
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># A perl version of the passwd program.
</p>
<p>#
</p>
<p># Note - the real passwd program needs to be much more
</p>
<p># secure than this one. This is just to demonstrate the
</p>
<p># use of the crypt() function.
</p>
<p>#
</p>
<p>#############################################################
</p>
<p>print &quot;Changing passwd for $ENV{'USER'} on $ENV{'HOST'}\n&quot;;
</p>
<p>system 'stty','-echo';
</p>
<p>print &quot;Old passwd: &quot;;
</p>
<p>$oldpwd = &lt;STDIN&gt;;
</p>
<p>chop $oldpwd;
</p>
<p>($name,$coded_pwd,$uid,$gid,$x,$y,$z,$gcos,$home,$shell)
</p>
<p>= getpwnam($ENV{&quot;USER&quot;});
</p>
<p>if (crypt($oldpwd,$coded_pwd) ne $coded_pwd)
</p>
<p>{
</p>
<p>print &quot;\nPasswd incorrect\n&quot;;
</p>
<p>exit (1);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 89
</p>
<p>}
</p>
<p>$oldpwd = &quot;&quot;; # Destroy the evidence!
</p>
<p>print &quot;\nNew passwd: &quot;;
</p>
<p>$newpwd = &lt;STDIN&gt;;
</p>
<p>print &quot;\nRepeat new passwd: &quot;;
</p>
<p>$rnewpwd = &lt;STDIN&gt;;
</p>
<p>chop $newpwd;
</p>
<p>chop $rnewpwd;
</p>
<p>if ($newpwd ne $rnewpwd)
</p>
<p>{
</p>
<p>print &quot;\n Incorrectly typed. Password unchanged.\n&quot;;
</p>
<p>exit (1);
</p>
<p>}
</p>
<p>$salt = rand();
</p>
<p>$new_coded_pwd = crypt($newpwd,$salt);
</p>
<p>print &quot;\n\n$name:$new_coded_pwd:$uid:$gid:$gcos:$home:$shell\n&quot;;
</p>
<p>7.9.2 Example with `fork()'
</p>
<p>The following example uses the `fork' function to start a daemon which goes into the
</p>
<p>background and watches the system to which process is using the greatest amount of CPU
</p>
<p>time each minute. A pipe is opened from the BSD `ps' command.
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># A fork() demo. This program will sit in the background and
</p>
<p># make a list of the process which uses the maximum CPU average
</p>
<p># at 1 minute intervals. On a quiet BSD like system this will
</p>
<p># normally be the swapper (long term scheduler).
</p>
<p>#
</p>
<p>$true = 1;
</p>
<p>$logfile=&quot;perl.cpu.logfile&quot;;
</p>
<p>print &quot;Max CPU logfile, forking daemon...\n&quot;;
</p>
<p>if (fork())
</p>
<p>{
</p>
<p>exit(0);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>90 The unix programming environment
</p>
<p>}
</p>
<p>while ($true)
</p>
<p>{
</p>
<p>open (logfile,&quot;&gt;&gt; $logfile&quot;) || die &quot;Can't open $logfile\n&quot;;
</p>
<p>open (ps,&quot;/bin/ps aux |&quot;) || die &quot;Couldn't open a pipe from ps !!\n&quot;;
</p>
<p>$skip_first_line = &lt;ps&gt;;
</p>
<p>$max_process = &lt;ps&gt;;
</p>
<p>close(ps);
</p>
<p>print logfile $max_process;
</p>
<p>close(logfile);
</p>
<p>sleep 60;
</p>
<p>($a,$b,$c,$d,$e,$f,$g,$size) = stat($logfile);
</p>
<p>if ($size &gt; 500)
</p>
<p>{
</p>
<p>print STDERR &quot;Log file getting big, better quit!\n&quot;;
</p>
<p>exit(0);
</p>
<p>}
</p>
<p>}
</p>
<p>7.9.3 Example reading databases
</p>
<p>Here is an example program with several of the above features demonstrated simultane-
</p>
<p>ously. This following program lists all users who have home directories on the current host.
</p>
<p>If the home area has sub-directories, corresponding to groups, then this is speci&#12;ed on the
</p>
<p>command line. The word `home' causes the program to print out the home directories of
</p>
<p>the users.
</p>
<p>#!/local/bin/perl
</p>
<p>##################################################################
</p>
<p>#
</p>
<p># allusers - list all users on named host, i.e. all
</p>
<p># users who can log into this machine.
</p>
<p>#
</p>
<p># Syntax: allusers group
</p>
<p># allusers mygroup home
</p>
<p># allusers myhost group home
</p>
<p>#
</p>
<p># NOTE : This command returns only users who are registered on
</p>
<p># the current host. It will not find users which cannot
</p>
<p># be validated in the passwd file, or in the named groups
</p>
<p># in NIS. It assumes that the users belonging to
</p>
<p># different groups are saved in subdirectories of
</p>
<p># /home/hostname.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 91
</p>
<p>#
</p>
<p>##################################################################
</p>
<p>&amp;arguments();
</p>
<p>die &quot;\n&quot; if ( ! -d &quot;/home/$server&quot; );
</p>
<p>$disks = `/bin/ls -d /home/$server/$group`;
</p>
<p>foreach $home (split(/\s/,$disks))
</p>
<p>{
</p>
<p>open (LS,&quot;cd $home; /bin/ls $home |&quot;) || die &quot;allusers: Pipe didn't open&quot;;
</p>
<p>while (&lt;LS&gt;)
</p>
<p>{
</p>
<p>$exists = &quot;&quot;;
</p>
<p>($user) = split;
</p>
<p>($exists,$pw,$uid,$gid,$qu,$cm,$gcos,$dir)=getpwnam($user);
</p>
<p>if ($exists)
</p>
<p>{
</p>
<p>if ($printhomes)
</p>
<p>{
</p>
<p>print &quot;$dir\n&quot;;
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>print &quot;$user\n&quot;;
</p>
<p>}
</p>
<p>}
</p>
<p>}
</p>
<p>close(LS);
</p>
<p>}
</p>
<p>########################################################
</p>
<p>sub arguments
</p>
<p>{
</p>
<p>$printhomes = 0;
</p>
<p>$group = &quot;*&quot;;
</p>
<p>$server = `/bin/hostname`;
</p>
<p>chop $server;
</p>
<p>foreach $arg (@ARGV)
</p>
<p>{
</p>
<p>if (substr($arg,0,1) eq &quot;u&quot;)
</p>
<p>{
</p>
<p>$group = $arg;
</p>
<p>next;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>92 The unix programming environment
</p>
<p>}
</p>
<p>if ($arg eq &quot;home&quot;)
</p>
<p>{
</p>
<p>$printhomes = 1;
</p>
<p>next;
</p>
<p>}
</p>
<p>$server= $arg; #default is to interpret as a server.
</p>
<p>}
</p>
<p>}
</p>
<p>7.10 Pattern matching and extraction
</p>
<p>Perl has regular expression operators for identifying patterns. The operator
</p>
<p>/regular expression/
</p>
<p>returns true of false depending on whether the regular expression matches the contents of
</p>
<p>$_. For example
</p>
<p>if (/perl/)
</p>
<p>{
</p>
<p>print &quot;String contains perl as a substring&quot;;
</p>
<p>}
</p>
<p>if (/(Sat|Sun)day/)
</p>
<p>{
</p>
<p>print &quot;Weekend day....&quot;;
</p>
<p>}
</p>
<p>The e&#11;ect is rather like the grep command. To use this operator on other variables you
</p>
<p>would write:
</p>
<p>$variable =~ /regexp/
</p>
<p>Regular expression can contain parenthetic sub-expressions, e.g.
</p>
<p>if (/(Sat|Sun)day (..)th (.*)/)
</p>
<p>{
</p>
<p>$first = $1;
</p>
<p>$second = $2;
</p>
<p>$third = $3;
</p>
<p>}
</p>
<p>in which case perl places the objects matched by such sub-expressions in the variables $1,
</p>
<p>$2 etc.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 93
</p>
<p>7.11 Searching and replacing text
</p>
<p>The `sed'-like function for replacing all occurances of a string is easily implemented in Perl
</p>
<p>using
</p>
<p>while (&lt;input&gt;)
</p>
<p>{
</p>
<p>s/$search/$replace/g;
</p>
<p>print output;
</p>
<p>}
</p>
<p>This example replaces the string inside the default variable. To replace in a general variable
</p>
<p>we use the operator `=~', with syntax:
</p>
<p>$variable =~ s/search/replace/
</p>
<p>Here is an example of some of this operator in use. The following is a program which
</p>
<p>searches and replaces a string in several &#12;les. This is useful program indeed for making a
</p>
<p>change globally in a group of &#12;les! The program is called `&#12;le-replace'.
</p>
<p>#!/local/bin/perl
</p>
<p>##############################################################
</p>
<p>#
</p>
<p># Look through files for findstring and change to newstring
</p>
<p># in all files.
</p>
<p>#
</p>
<p>##############################################################
</p>
<p>#
</p>
<p># Define a temporary file and check it doesn't exist
</p>
<p>#
</p>
<p>$outputfile = &quot;tmpmarkfind&quot;;
</p>
<p>unlink $outputfile;
</p>
<p>#
</p>
<p># Check command line for list of files
</p>
<p>#
</p>
<p>if ($#ARGV &lt; 0)
</p>
<p>{
</p>
<p>die &quot;Syntax: file-replace [file list]\n&quot;;
</p>
<p>}
</p>
<p>print &quot;Enter the string you want to find (Don't use quotes):\n\n:&quot;;
</p>
<p>$findstring=&lt;STDIN&gt;;
</p>
<p>chop $findstring;
</p>
<p>print &quot;Enter the string you want to replace with (Don't use quotes):\n\n:&quot;;
</p>
<p>$replacestring=&lt;STDIN&gt;;
</p>
<p>chop $replacestring;
</p>
<p>#</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>94 The unix programming environment
</p>
<p>print &quot;\nFind: $findstring\n&quot;;
</p>
<p>print &quot;Replace: $replacestring\n&quot;;
</p>
<p>print &quot;\nConfirm (y/n) &quot;;
</p>
<p>$y = &lt;STDIN&gt;;
</p>
<p>chop $y;
</p>
<p>if ( $y ne &quot;y&quot;)
</p>
<p>{
</p>
<p>die &quot;Aborted -- nothing done.\n&quot;;
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>print &quot;Use CTRL-C to interrupt...\n&quot;;
</p>
<p>}
</p>
<p>#
</p>
<p># Now shift default array @ARGV to get arguments 1 by 1
</p>
<p>#
</p>
<p>while ($file = shift)
</p>
<p>{
</p>
<p>if ($file eq &quot;file-replace&quot;)
</p>
<p>{
</p>
<p>print &quot;Findmark will not operate on itself!&quot;;
</p>
<p>next;
</p>
<p>}
</p>
<p>#
</p>
<p># Save existing mode of file for later
</p>
<p>#
</p>
<p>($dev,$ino,$mode)=stat($file);
</p>
<p>open (INPUT,$file) || warn &quot;Couldn't open $file\n&quot;;
</p>
<p>open (OUTPUT,&quot;&gt; $outputfile&quot;) || warn &quot;Can't open tmp&quot;;
</p>
<p>$notify = 1;
</p>
<p>while (&lt;INPUT&gt;)
</p>
<p>{
</p>
<p>if (/$findstring/ &amp;&amp; $notify)
</p>
<p>{
</p>
<p>print &quot;Fixing $file...\n&quot;;
</p>
<p>$notify = 0;
</p>
<p>}
</p>
<p>s/$findstring/$replacestring/g;
</p>
<p>print OUTPUT;
</p>
<p>}</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 95
</p>
<p>close (OUTPUT);
</p>
<p>#
</p>
<p># If nothing went wrong (if outfile not empty)
</p>
<p># move temp file to original and reset the
</p>
<p># file mode saved above
</p>
<p>#
</p>
<p>if (! -z $outputfile)
</p>
<p>{
</p>
<p>rename ($outputfile,$file);
</p>
<p>chmod ($mode,$file);
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>print &quot;Warning: file empty!\n.&quot;;
</p>
<p>}
</p>
<p>}
</p>
<p>Similarly we can search for lines containing a string. Here is the grep program written in
</p>
<p>perl
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># grep as a perl program
</p>
<p>#
</p>
<p># Check arguments etc
</p>
<p>while (&lt;&gt;)
</p>
<p>{
</p>
<p>print if (/$ARGV[1]/);
</p>
<p>}
</p>
<p>The operator `/search-string/' returns true if the search string is a substring of the default
</p>
<p>variable $_. To search an arbitrary string, we write
</p>
<p>.... if (teststring =~ /search-string/);
</p>
<p>Here teststring is searched for occurrances of search-string and the result is true if one is
</p>
<p>found.
</p>
<p>In perl you can use regular expressions to search for text patterns. Note however that,
</p>
<p>like all regular expression dialects, perl has its own conventions. For example the dollar
</p>
<p>sign does not mean &quot;match the end of line&quot; in perl, instead one uses the `\n' symbol. Here
</p>
<p>is an example program which illustrates the use of regular expressions in perl:
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Test regular expressions in perl
</p>
<p>#
</p>
<p># NB - careful with \ $ * symbols etc. Use '' quotes since</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>96 The unix programming environment
</p>
<p># the shell interprets these!
</p>
<p>#
</p>
<p>open (FILE,&quot;regex_test&quot;);
</p>
<p>$regex = $ARGV[$#ARGV];
</p>
<p>print &quot;Looking for $ARGV[$#ARGV] in file...\n&quot;;
</p>
<p>while (&lt;FILE&gt;)
</p>
<p>{
</p>
<p>if (/$regex/)
</p>
<p>{
</p>
<p>print;
</p>
<p>}
</p>
<p>}
</p>
<p>#
</p>
<p># Test like this:
</p>
<p>#
</p>
<p># regex '.*' - prints every line (matches everything)
</p>
<p># regex '.' - all lines except those containing only blanks
</p>
<p># (. doesn't match ws/white-space)
</p>
<p># regex '[a-z]' - matches any line containing lowercase
</p>
<p># regex '[^a-z]' - matches any line containg something which is
</p>
<p># not lowercase a-z
</p>
<p># regex '[A-Za-z]' - matches any line containing letters of any kind
</p>
<p># regex '[0-9]' - match any line containing numbers
</p>
<p># regex '#.*' - line containing a hash symbol followed by anything
</p>
<p># regex '^#.*' - line starting with hash symbol (first char)
</p>
<p># regex ';\n' - match line ending in a semi-colon
</p>
<p>#
</p>
<p>Try running this program with the test data on the following &#12;le which is called `regex_test'
</p>
<p>in the example program.
</p>
<p># A line beginning with a hash symbol
</p>
<p>JUST UPPERCASE LETTERS
</p>
<p>just lowercase letters
</p>
<p>Letters and numbers 123456
</p>
<p>123456
</p>
<p>A line ending with a semi-colon;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 97
</p>
<p>Line with a comment # COMMENT...
</p>
<p>7.12 Example: convert mail to WWW pages
</p>
<p>Here is an example program which you could use to automatically turn a mail message
</p>
<p>of the form
</p>
<p>From: Newswire
</p>
<p>To: Mail2html
</p>
<p>Subject: Nothing happened
</p>
<p>On the 13th February at kl. 09:30 nothing happened. No footprints
</p>
<p>were found leading to the scene of a terrible murder, no evidence
</p>
<p>of a struggle .... etc etc
</p>
<p>into an html-&#12;le for the world wide web. The program works by extracting the message
</p>
<p>body and subject from the mail and writing html-commands around these to make a web
</p>
<p>page. The subject &#12;eld of the mail becomes the title. The other headers get skipped,
</p>
<p>since the script searches for lines containing the sequence &quot;colon-space&quot; or `: '. A regular
</p>
<p>expression is used for this.
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Make HTML from mail
</p>
<p>#
</p>
<p>&amp;BeginWebPage();
</p>
<p>&amp;ReadNewMail();
</p>
<p>&amp;EndWebPage();
</p>
<p>##########################################################
</p>
<p>sub BeginWebPage
</p>
<p>{
</p>
<p>print &quot;&lt;HTML&gt;\n&quot;;
</p>
<p>print &quot;&lt;BODY&gt;\n&quot;;
</p>
<p>}
</p>
<p>##########################################################
</p>
<p>sub EndWebPage
</p>
<p>{
</p>
<p>print &quot;&lt;/BODY&gt;\n&quot;;
</p>
<p>print &quot;&lt;/HTML&gt;\n&quot;;
</p>
<p>}</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>98 The unix programming environment
</p>
<p>##########################################################
</p>
<p>sub ReadNewMail
</p>
<p>{
</p>
<p>while (&lt;&gt;)
</p>
<p>{
</p>
<p>if (/Subject:/) # Search for subject line
</p>
<p>{
</p>
<p># Extract subject text...
</p>
<p>chop;
</p>
<p>($left,$right) = split(&quot;:&quot;,$_);
</p>
<p>print &quot;&lt;H1&gt; $right &lt;/H1&gt;\n&quot;;
</p>
<p>next;
</p>
<p>}
</p>
<p>elsif (/.*: .*/) # Search for - anything: anything
</p>
<p>{
</p>
<p>next; # skip other headers
</p>
<p>}
</p>
<p>print;
</p>
<p>}
</p>
<p>}
</p>
<p>7.13 Generate WWW pages automagically
</p>
<p>The following program scans through the password database and build a standardized
</p>
<p>html-page for each user it &#12;nds there. It &#12;lls in the name of the user in each case. Note
</p>
<p>the use of the `&lt;&lt;' operator for extended input, already used in the context of the shell, See
</p>
<p>Section 5.4 [Pipes and redirection], page 43. This allows us to format a whole passage of
</p>
<p>text, inserting variables at strategic places, and avoid having to the print over many lines.
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Build a default home page for each user in /etc/passwd
</p>
<p>#
</p>
<p>#
</p>
<p>####################################################################
</p>
<p># Level 0 (main)
</p>
<p>####################################################################
</p>
<p>$true = 1;
</p>
<p>$false = 0;
</p>
<p># First build an associated array of users and full names</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 99
</p>
<p>setpwent();
</p>
<p>while ($true)
</p>
<p>{
</p>
<p>($name,$passwd,$uid,$gid,$quota,$comment,$fullname) = getpwent;
</p>
<p>$FullName{$name} = $fullname;
</p>
<p>print &quot;$name - $FullName{$name}\n&quot;;
</p>
<p>last if ($name eq &quot;&quot;);
</p>
<p>}
</p>
<p>print &quot;\n&quot;;
</p>
<p># Now make a unique filename for each page and open a file
</p>
<p>foreach $user (sort keys(%FullName))
</p>
<p>{
</p>
<p>next if ($user eq &quot;&quot;);
</p>
<p>print &quot;Making page for $user\n&quot;;
</p>
<p>$outputfile = &quot;$user.html&quot;;
</p>
<p>open (OUT,&quot;&gt; $outputfile&quot;) || die &quot;Can't open $outputfile\n&quot;;
</p>
<p>&amp;MakePage;
</p>
<p>close (OUT);
</p>
<p>}
</p>
<p>####################################################################
</p>
<p># Level 1
</p>
<p>####################################################################
</p>
<p>sub MakePage
</p>
<p>{
</p>
<p>print OUT &lt;&lt;ENDMARKER;
</p>
<p>&lt;HTML&gt;
</p>
<p>&lt;BODY&gt;
</p>
<p>&lt;HEAD&gt;&lt;TITLE&gt;$FullName{$user}'s Home Page&lt;/TITLE&gt;&lt;/HEAD&gt;
</p>
<p>&lt;H1&gt;$FullName{$user}'s Home Page&lt;/H1&gt;
</p>
<p>Hi welcome to my home page. In case you hadn't
</p>
<p>got it yet my name is: $FullName{$user}...
</p>
<p>I study at &lt;a href=http://www.iu.hioslo.no&gt;H&amp;oslash;gskolen i Oslo&lt;/a&gt;.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>100 The unix programming environment
</p>
<p>&lt;/BODY&gt;
</p>
<p>&lt;/HTML&gt;
</p>
<p>ENDMARKER
</p>
<p>}
</p>
<p>7.14 Other supported functions
</p>
<p>Perl has very many functions which come directly from the C library. To give a taster,
</p>
<p>a few are listed here. The Perl book contains a comprehensive description of these.
</p>
<p>Fork The standard UNIX fork command for spawning new processes.
</p>
<p>Sockets Support for network socket communication.
</p>
<p>Directories
</p>
<p>Directory opening and handling routines.
</p>
<p>Databases Reading from the password &#12;les and the host databases is supported through
</p>
<p>the standard C functions `getpasswdbyname' etc. dressed up to look like Perl.
</p>
<p>Crypt The password encryption function.
</p>
<p>Regexp Regular expressions and pattern matching, search and replace functions as in
</p>
<p>`sed'.
</p>
<p>Operators Perl has the full set of C's logical operators.
</p>
<p>File testing
</p>
<p>Tests from the shell like `if (-f file)'.
</p>
<p>Here are some of the most frequently used functions
</p>
<p>chmod Change the &#12;le mode of a &#12;le. e.g. chmod 755,&#12;lename
</p>
<p>chdir Change the current working directory. e.g. chdir /etc
</p>
<p>stat Get info about permissions, ownership and type of a &#12;le.
</p>
<p>open Open a &#12;le for reading, `&gt;' writing, `|' as a pipe.
</p>
<p>close Close an open &#12;le handle.
</p>
<p>system Execute a shell command as a child process. e.g. system &quot;ls&quot;;
</p>
<p>split Split a string variable into an array of elements, by searching for a special
</p>
<p>character (space or `:' etc.) e.g. @array=split(&quot;:&quot;,$string).
</p>
<p>rename Rename a &#12;le. e.g. rename old name new-name
</p>
<p>mkdir Make a new directory. mkdir newdir
</p>
<p>shift Read the &#12;rst element of an array and delete it, shifting all the array elements
</p>
<p>down by one. (e.g. $first=shift(@array);).
</p>
<p>chop Chops o&#11; the last character of a string. Often used for deleting the end-of-line
</p>
<p>character when reading from a &#12;le.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 7: Perl 101
</p>
<p>oct Interprets a number as octal (converts to decimal). e.g. $decimal = oct(755);
</p>
<p>kill Send a kill signal to a list of processes. e.g. kill -9, pid1,pid2...
</p>
<p>You should explore Perl's possibilities yourself. Perl is a good alternative to the shell which
</p>
<p>has much of the power of C and is therefore ideal for simple and more complex system
</p>
<p>programming tasks. If you intend to be a system administrator for UNIX systems, you
</p>
<p>could do much worse than to read the Perl book and learn Perl inside out.
</p>
<p>7.15 Summary
</p>
<p>The Practical Extraction and Report Language is a powerful tool which goes beyond
</p>
<p>shell programming, but which retains much of the immediateness of shell programming in
</p>
<p>a more formal programming environment.
</p>
<p>The success of Perl has led many programmers to use it exclusively. In the next section,
</p>
<p>I would like to argue that programming directly in C is not much harder. In fact it has
</p>
<p>advantages in the long run. The power of Perl is that it is as immediate as shell program-
</p>
<p>ming. If you are inexperienced, Perl is a little easier than C because many features are
</p>
<p>ready programmed into the language, but with time one also builds up a repertoire of C
</p>
<p>functions which can do the same tricks.
</p>
<p>7.16 Exercises
</p>
<p>1. Write a progam which prints out all of its arguments alphabetically together with the
</p>
<p>&#12;rst and the last, and the number of arguments.
</p>
<p>2. Write a program which prints out the pathname of the home directory for a given user.
</p>
<p>The user's login name should be given as an argument.
</p>
<p>3. Write a program called `search-replace' which looks for a given string in a list of &#12;les
</p>
<p>and replaces it with a new string. You should be able to specify a list of &#12;les us-
</p>
<p>ing ordinary unix wildcards. e.g. `search-replace search-string replace-string
</p>
<p>*.text'. This is a dangerous operation! What if the user types the strings incorrectly?
</p>
<p>How can you may the program safer?
</p>
<p>4. Write a program which opens a pipe from `ps' and computes the total cpu-time used by
</p>
<p>each user. Print the results in order of maximum to minimum. Hint: use an associated
</p>
<p>array to store the information.
</p>
<p>5. Write a program which forks and goes into the background. Make the program send
</p>
<p>you mail when some other user of your choice logs in. Use sleep to check only every
</p>
<p>few minutes.
</p>
<p>6. Open a pipe from `find' and collect statistics over how many &#12;les there are in all of
</p>
<p>your sub-directories.
</p>
<p>7.17 Project
</p>
<p>Write a program which checks the `sanity' of your UNIX system.
</p>
<p>1. Check that the password &#12;le /etc/passwd is not writable by general users.
</p>
<p>2. Check that the processes `cron' and `sendmail' are running.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>102 The unix programming environment
</p>
<p>3. Check that, if the &#12;le `/etc/exports' or `/etc/dfs/dfstab' exists, the nfsd daemon
</p>
<p>is running.
</p>
<p>4. Check that if the &#12;lesystem table `/etc/fstab' (or its equivalent on non-BSD systems)
</p>
<p>contains NFS mounted &#12;lesystems, the `biod' or `nfsiod' daemon is running.
</p>
<p>5. Check that the &#12;le `/etc/resolv.conf' contains the correct domain name. It may or
</p>
<p>may not be the same as that returned by the shell command `domainname'. If it is
</p>
<p>not the same, you should print the message `NIS domain has di&#11;erent name to DNS
</p>
<p>domain'.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 8: WWW and CGI programming 103
</p>
<p>8 WWW and CGI programming
</p>
<p>CGI stands for the Common Gateway Interface. It is the name given to scripts which
</p>
<p>can be executed from within pages of the world wide web. Although it is possible to use any
</p>
<p>language in CGI programs (hence the word `common'), the usual choice is Perl, because of
</p>
<p>the ease with which Perl can handle text.
</p>
<p>The CGI interface is pretty unintelligent, in order to be as general as possible, so we
</p>
<p>need to do a bit of work in order to make scripts work.
</p>
<p>8.1 Permissions
</p>
<p>The key thing about the WWW which often causes a lot of confusion is that the W3
</p>
<p>service runs with a user ID of `nobody'. The purpose of this is to ensure that nobody has
</p>
<p>the right to read or write &#12;les unless they are opened very explicitly by the user who owns
</p>
<p>them.
</p>
<p>In order for &#12;les to be readable on the WWW, they must have &#12;le mode `644' and they
</p>
<p>must lie in a directory which has mode `755'. In order for a CGI program to be executable,
</p>
<p>it must have permission `755' and in order for such a program to write to a &#12;le in a user's
</p>
<p>directory, it must be possible for the &#12;le to be created (if necessary) and everyone must be
</p>
<p>able to write to it. That means that &#12;les which are written to by the WWW must have
</p>
<p>mode `666' and must either exist already or lie in a directory with permission `777'
</p>
<p>1
</p>
<p>.
</p>
<p>8.2 Protocols
</p>
<p>CGI script programs communicate with W3 browsers using a very simple protocol. It
</p>
<p>goes like this:
</p>
<p>&#15; A web page sends data to a script using the `forms' interface. Those data are concate-
</p>
<p>nated into a single line. The data in separate &#12;elds of a form are separated by `&amp;' signs.
</p>
<p>New lines are replaced by the text `%0D%0A', which is the DOS ASCII representation
</p>
<p>of a newline, and spaces are replaced by `+' symbols.
</p>
<p>&#15; A CGI script reads this single line of text on the standard input.
</p>
<p>&#15; The CGI script replies to the web browser. The &#12;rst line of the reply must be a line
</p>
<p>which is tells the browser what mime-type the data are sent in. Usually, a CGI script
</p>
<p>replies in HTML code, in which case the &#12;rst line in the reply must be:
</p>
<p>Content-type: text/html
</p>
<p>This must be followed by a blank line.
</p>
<p>8.3 HTML coding of forms
</p>
<p>To start a CGI program from a web page we use a form which is a part of the HTML
</p>
<p>code enclosed with the parentheses
</p>
<p>1
</p>
<p>You could also set the sticky bit `1777' in order to prevent malicious users from deleting
</p>
<p>your &#12;le.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>104 The unix programming environment
</p>
<p>&lt;FORM method=&quot;POST&quot; ACTION=&quot;/cgi-script-alias/program.pl&quot;&gt;
</p>
<p>...
</p>
<p>&lt;/FORM&gt;
</p>
<p>The method `post' means that the data which get typed into this form will be piped into
</p>
<p>the CGI program via its standard input. The `action' speci&#12;es which program you want to
</p>
<p>start. Note that you cannot simply use the absolute path of the &#12;le, for security reasons.
</p>
<p>You must use something called a `script alias' to tell the web browser where to &#12;nd the
</p>
<p>program. If you do not have a script alias de&#12;ned for you personally, then you need to get
</p>
<p>one from your system administrator. By using a script alias, no one from outside your site
</p>
<p>can see where your &#12;les are located, only that you have a `cgi-bin' area somewhere on your
</p>
<p>system.
</p>
<p>Within these parentheses, you can arrange to collect di&#11;erent kinds of input. The sim-
</p>
<p>plest kind of input is just a button which starts the CGI program. This has the form
</p>
<p>&lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Start my program&quot;&gt;
</p>
<p>This code creates a button. When you click on it the program in your `action' string gets
</p>
<p>started. More generally, you will want to create input boxes where you can type in data.
</p>
<p>To create a single line input &#12;eld, you use the following syntax:
</p>
<p>&lt;INPUT NAME=&quot;variable-name&quot; SIZE=40&gt;
</p>
<p>This creates a single line text &#12;eld of width 40 characters. This is not the limit on the
</p>
<p>length of the string which can be typed into the &#12;eld, only a limit on the amount which
</p>
<p>is visible at any time. It is for visual formatting only. The NAME &#12;eld is used to identify
</p>
<p>the data in the CGI script. The string you enter here will be sent to the CGI script in the
</p>
<p>form `variable-name=value of input...'. Another type of input is a text area. This is a
</p>
<p>larger box where one can type in text on several lines. The syntax is:
</p>
<p>&lt;TEXTAREA NAME=&quot;variable-name&quot; ROW=50 COLS=50&gt;
</p>
<p>which means: create a text area of &#12;fty rows by &#12;fty columns with a prompt to the left of
</p>
<p>the box. Again, the size has only to do with the visual formatting, not to do with limits on
</p>
<p>the amount of text which can be entered.
</p>
<p>As an example, let's create a WWW page with a complete form which can be used to
</p>
<p>make a guest book, or order form.
</p>
<p>&lt;HTML&gt;
</p>
<p>&lt;HEAD&gt;
</p>
<p>&lt;TITLE&gt;Example form&lt;/TITLE&gt;
</p>
<p>&lt;!-- Comment: Mark Burgess, 27-Jan-1997 --&gt;
</p>
<p>&lt;LINK REV=&quot;made&quot; HREF=&quot;mailto:mark@iu.hioslo.no&quot;&gt;
</p>
<p>&lt;/HEAD&gt;
</p>
<p>&lt;BODY&gt;
</p>
<p>&lt;CENTER&gt;&lt;H1&gt;Write in my guest book...&lt;/H1&gt;&lt;/CENTER&gt;
</p>
<p>&lt;HR&gt;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 8: WWW and CGI programming 105
</p>
<p>&lt;CENTER&gt;&lt;H2&gt;Please leave a comment using the form below.&lt;/H2&gt;&lt;P&gt;
</p>
<p>&lt;FORM method=&quot;POST&quot; ACTION=&quot;/cgi-bin-mark/comment.pl&quot;&gt;
</p>
<p>Your Name/e-mail: &lt;INPUT NAME=&quot;variable1&quot; SIZE=40&gt; &lt;BR&gt;&lt;BR&gt;
</p>
<p>&lt;P&gt;
</p>
<p>&lt;TEXTAREA NAME=&quot;variable2&quot; cols=50 rows=8&gt;&lt;/TEXTAREA&gt;
</p>
<p>&lt;P&gt;
</p>
<p>&lt;INPUT TYPE=submit VALUE=&quot;Add message to book&quot;&gt;
</p>
<p>&lt;INPUT TYPE=reset VALUE=&quot;Clear message&quot;&gt;
</p>
<p>&lt;/FORM&gt;
</p>
<p>&lt;P&gt;
</p>
<p>&lt;/BODY&gt;
</p>
<p>&lt;/HTML&gt;
</p>
<p>The reset button clears the form. When the submit button is pressed, the CGI program
</p>
<p>is activated.
</p>
<p>8.4 Perl and the web
</p>
<p>8.4.1 Interpreting data from forms
</p>
<p>To interpret and respond to the data in a form, we must write a program which satsi&#12;es
</p>
<p>the protocol above, See Section 8.2 [Protocols], page 103. We use perl as a script langauge.
</p>
<p>The simplest valid CGI script is the following:
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Reply with proper protocol
</p>
<p>#
</p>
<p>print &quot;Content-type: text/html\n\n&quot;;
</p>
<p>#
</p>
<p># Get the data from the form ...
</p>
<p>#
</p>
<p>$input = &lt;STDIN&gt;;
</p>
<p>#
</p>
<p># ... and echo them back
</p>
<p>#</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>106 The unix programming environment
</p>
<p>print $input, &quot;\n Done! \n&quot;;
</p>
<p>Although rather banal, this script is a useful starting point for CGI programming, because
</p>
<p>it shows you just how the input arrives at the script from the HTML form. The data arrive
</p>
<p>all in a single, enormously long line, full of funny characters. The &#12;rst job of any script is
</p>
<p>to decode this line.
</p>
<p>Before looking at how to decode the data, we should make an important point about the
</p>
<p>protocol line. If a web browser does not get this `Content-type' line from the CGI script it
</p>
<p>returns with an error:
</p>
<p>500 Server Error
</p>
<p>The server encountered an internal error or misconfiguration and was
</p>
<p>unable to complete your request.
</p>
<p>Please contact the server administrator, and inform them of the time
</p>
<p>the error occurred, and anything you might have done that may have
</p>
<p>caused the error.
</p>
<p>Error: HTTPd: malformed header from script www/cgi-bin/comment.pl
</p>
<p>Before &#12;nishing your CGI script, you will probably ecounter this error several times. A
</p>
<p>common reason for getting the error is a syntax error in your script. If your program
</p>
<p>contains an error, the &#12;rst thing a browser gets in return is not the `Content-type' line,
</p>
<p>but an error message. The browser does not pass on this error message, it just prints the
</p>
<p>uninformative message above.
</p>
<p>If you can get the above script to work, then you are ready to decode the data which
</p>
<p>are sent to the script. The &#12;rst thing is to use perl to split the long line into an array of
</p>
<p>lines, by splitting on `&amp;'. We can also convert all of the `+' symbols back into spaces. The
</p>
<p>script now looks like this:
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Reply with proper protocol
</p>
<p>#
</p>
<p>print &quot;Content-type: text/html\n\n&quot;;
</p>
<p>#
</p>
<p># Get the data from the form ...
</p>
<p>#
</p>
<p>$input = &lt;STDIN&gt;;
</p>
<p>#
</p>
<p># ... and echo them back</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 8: WWW and CGI programming 107
</p>
<p>#
</p>
<p>print &quot;$input\n\n\n&quot;;
</p>
<p>$input =~ s/\+/ /g;
</p>
<p>#
</p>
<p># Now split the lines and convert
</p>
<p>#
</p>
<p>@array = split('&amp;',$input);
</p>
<p>foreach $var ( @array )
</p>
<p>{
</p>
<p>print &quot;$var\n&quot;;
</p>
<p>}
</p>
<p>print &quot;Done! \n&quot;;
</p>
<p>We now have a series of elements in our array. The output from this script is something
</p>
<p>like this:
</p>
<p>variable1=Mark+Burgess&amp;variable2=%0D%0AI+just+called+to+say+ (wrap)
</p>
<p>....%0D%0A...hey+pig%2C+nothing%27s+working+out+the+way+I+planned
</p>
<p>variable1=Mark Burgess variable2=%0D%0AI just called to say (wrap)
</p>
<p>....%0D%0A...hey pig%2Cnothing%27s working out the way I planned Done!
</p>
<p>As you can see, all control characters are converted into the form `%XX'. We should now try
</p>
<p>to do something with these. Since we are usually not interested in keeping new lines, or
</p>
<p>any other control codes, we can simply null-out these with a line of the form
</p>
<p>$input =~ s/%..//g;
</p>
<p>The regular expression `%..' matches anything beginning with a percent symbol followed by
</p>
<p>two characters. The resulting output is then free of these symbols. We can then separate
</p>
<p>the variable contents from their names by splitting the input. Here is the complete code:
</p>
<p>#!/local/bin/perl
</p>
<p>#
</p>
<p># Reply with proper protocol
</p>
<p>#
</p>
<p>print &quot;Content-type: text/html\n\n&quot;;
</p>
<p>#
</p>
<p># Get the data from the form ...
</p>
<p>#</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>108 The unix programming environment
</p>
<p>$input = &lt;STDIN&gt;;
</p>
<p>#
</p>
<p># ... and echo them back
</p>
<p>#
</p>
<p>print &quot;$input\n\n\n&quot;;
</p>
<p>$input =~ s/%..//g;
</p>
<p>$input =~ s/\+/ /g;
</p>
<p>@array = split('&amp;',$input);
</p>
<p>foreach $var ( @array )
</p>
<p>{
</p>
<p>print &quot;$var&lt;br&gt;&quot;;
</p>
<p>}
</p>
<p>print &quot;&lt;hr&gt;\n&quot;;
</p>
<p>($name,$variable1) = split(&quot;variable1=&quot;,$array[0]);
</p>
<p>($name,$variable2) = split(&quot;variable2=&quot;,$array[1]);
</p>
<p>print &quot;&lt;br&gt;var1 = $variable1&lt;br&gt;&quot;;
</p>
<p>print &quot;&lt;br&gt;var2 = $variable2&lt;br&gt;&quot;;
</p>
<p>print &quot;&lt;br&gt;Done! \n&quot;;
</p>
<p>and the output
</p>
<p>&#11; &#8;
</p>
<p>variable1=Mark+Burgess&amp;variable2=%0D%0AI+just+called+to+say (wrap)
</p>
<p>+....%0D%0A...hey+pig%2C+nothing%27s+working+out+the+way+I+planned
</p>
<p>variable1=Mark Burgess
</p>
<p>variable2=I just called to say .......hey pig nothings working (wrap)
</p>
<p>out the way I planned
</p>
<p>var1 = Mark Burgess
</p>
<p>var2 = I just called to say .......hey pig nothings working out (wrap)
</p>
<p>the way I planned
</p>
<p>Done!
</p>
<p>&#10; &#9;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 8: WWW and CGI programming 109
</p>
<p>8.4.2 A complete guestbook example in perl
</p>
<p>Let us now use this technique to develop a guest book aplication. Based on the code
</p>
<p>above, analyze the following code.
</p>
<p>#!/local/bin/perl
</p>
<p>####################################################################
</p>
<p>#
</p>
<p># Guest book
</p>
<p>#
</p>
<p>####################################################################
</p>
<p>$guestbook_page = &quot;/iu/nexus/ud/mark/www/tmp/cfguest.html&quot;;
</p>
<p>$tmp_page = &quot;/iu/nexus/ud/mark/www/tmp/guests.tmp&quot;;
</p>
<p>$remote_host = $ENV{&quot;REMOTE_HOST&quot;};
</p>
<p>print &quot;Content-type: text/html\n\n&quot;;
</p>
<p>print &quot;&lt;br&gt;&lt;hr&gt;&lt;br&gt;\n&quot;;
</p>
<p>print &quot;Thank you for submitting your comment!&lt;br&gt;&lt;br&gt;\n&quot;;
</p>
<p>print &quot;best wishes,&lt;br&gt;&lt;br&gt;&quot;;
</p>
<p>print &quot;-Mark&lt;br&gt;&lt;br&gt;&lt;br&gt;&quot;;
</p>
<p>print &quot;Return to &lt;a href=http://www.iu.hioslo.no/~mark/menu.html&gt;menu&lt;/a&gt;\n&quot;;
</p>
<p>$input = &lt;STDIN&gt;;
</p>
<p>$input =~ s/%..//g;
</p>
<p>$input =~ s/\+/ /g;
</p>
<p>@array = split('&amp;',$input);
</p>
<p>($skip,$name) = split(&quot;var1=&quot;,$array[0]);
</p>
<p>($skip,$message) = split(&quot;var2=&quot;,$array[1]);
</p>
<p>if (! open (PAGE, $guestbook_page))
</p>
<p>{
</p>
<p>print &quot;Content-type: text/html\n\n&quot;;
</p>
<p>print &quot;couldn't open guestbook page file!&quot;;
</p>
<p>}
</p>
<p>if (! open (TMP, &quot;+&gt;$tmp_page&quot;))
</p>
<p>{
</p>
<p>print &quot;Content-type: text/html\n\n&quot;;
</p>
<p>print &quot;couldn't open temporary output file!&quot;;
</p>
<p>}
</p>
<p>while ($line = &lt;PAGE&gt;)
</p>
<p>{</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>110 The unix programming environment
</p>
<p>if ($line =~ /&lt;h3&gt;Number of entries: (..)/)
</p>
<p>{
</p>
<p>$entry_no = $1;
</p>
<p>$entry_no++;
</p>
<p>$line = &quot;&lt;h3&gt;Number of entries: $entry_no &lt;/h3&gt;\n&quot;;
</p>
<p>}
</p>
<p>if ($line =~ /&lt;!-- LAST ENTRY --&gt;/)
</p>
<p>{
</p>
<p>$date = `date +&quot;%A, %b %d %Y&quot;`;
</p>
<p>print TMP &quot;&lt;b&gt;Entry $date from host: $remote_host&lt;/b&gt;\n&lt;p&gt;\n&quot;;
</p>
<p>print TMP &quot;From: $name\n&lt;p&gt;\n&quot;;
</p>
<p>print TMP $message;
</p>
<p>print TMP &quot;\n&lt;hr&gt;\n&quot;;
</p>
<p>}
</p>
<p>print TMP &quot;$line&quot;;
</p>
<p>}
</p>
<p>close PAGE;
</p>
<p>close TMP;
</p>
<p>if (! rename ($tmp_page, $guestbook_page))
</p>
<p>{
</p>
<p>print &quot;Oops! Rename operation failed!\n&quot;;
</p>
<p>}
</p>
<p>chmod (0600, $guestbook_page);
</p>
<p>This script works by reading through the old guest book &#12;le, opening a new copy of the
</p>
<p>guest book &#12;le and appending a new messages at the end. The end of the message section
</p>
<p>(not counting the `&lt;/HTML&gt;' tags) is marked by a comment line.
</p>
<p>&lt;!-- LAST ENTRY --&gt;
</p>
<p>Note that a provisional guest book &#12;le has to exist in the &#12;rst place. The script writes to
</p>
<p>a new &#12;le and then swaps the new &#12;le for the old one. The guest book &#12;le looks something
</p>
<p>like this:
</p>
<p>&lt;html&gt;&lt;head&gt;
</p>
<p>&lt;title&gt;Comments&lt;/title&gt;
</p>
<p>&lt;/head&gt;
</p>
<p>&lt;body&gt;
</p>
<p>&lt;h1&gt;My guest book&lt;/h1&gt;
</p>
<p>&lt;b&gt;Entry no. Wednesday, Feb 28 1996
</p>
<p>from host: dax&lt;/b&gt;
</p>
<p>&lt;p&gt;
</p>
<p>From: Mark.Burgess@iu.hioslo.no
</p>
<p>&lt;p&gt;
</p>
<p>Just to start the ball rolling....</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 8: WWW and CGI programming 111
</p>
<p>&lt;hr&gt;
</p>
<p>&lt;b&gt;Entry no. Tuesday, Mar 26 1996
</p>
<p>from host: enterprise.subspace.net&lt;/b&gt;
</p>
<p>&lt;p&gt;
</p>
<p>From: spock@enterprise
</p>
<p>&lt;p&gt;
</p>
<p>Registering a form of energy never before encountered.
</p>
<p>&lt;!-- LAST ENTRY --&gt;
</p>
<p>&lt;/body&gt; &lt;address&gt;&lt;a href=&quot;http://www.iu.hioslo.no/~mark&quot;&gt;Mark
</p>
<p>Burgess&lt;/a&gt; - Mark.Burgess@iu.hioslo.no&lt;/addre ss&gt; &lt;/html&gt;
</p>
<p>The directory in which this &#12;le lies needs to be writable to the user nobody (the WWW
</p>
<p>user) and the &#12;les within need to be deletable by nobody but no one else. Some users
</p>
<p>try to make guest book scripts setuid-themselves in order to overcome the problem that
</p>
<p>httpd runs with uid nobody, but this opens many security issues. In short it is asking for
</p>
<p>trouble. Unfortunately an ordinary user cannot use chown in order to give access only to the
</p>
<p>WWW user nobody, so this approach needs the cooperation of the system administrator.
</p>
<p>Nevertheless this is the most secure approach. Try to work through this example step for
</p>
<p>step.
</p>
<p>8.5 PHP and the web
</p>
<p>The PHP 3 language makes the whole business of web programming rather simpler
</p>
<p>than perl. It hides the business of translating variables from forms into new variables in
</p>
<p>a CGI program and it even allows you to embed active code into you HTML pages. PHP
</p>
<p>has special support for querying data in an SQL database like MySQL or Oracle. PHP
</p>
<p>documentation lives at http://www.php.net.
</p>
<p>8.5.1 Embedded PHP
</p>
<p>PHP code can be embedded inside HTML pages provided your WWW server is con&#12;g-
</p>
<p>urered with PHP support. PHP code lives inside a tag with the general form
</p>
<p>&lt;?php code... ?&gt;
</p>
<p>For example, we could use this to import one &#12;le into another and print out a table of
</p>
<p>numbers:
</p>
<p>&lt;html&gt;
</p>
<p>&lt;body&gt;
</p>
<p>&lt;?php</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>112 The unix programming environment
</p>
<p>include &quot;file.html&quot;
</p>
<p>for ($i = 0; $i &lt; 10; $i++)
</p>
<p>{
</p>
<p>print &quot;Counting $i&lt;br&gt;&quot;;
</p>
<p>}
</p>
<p>?&gt;
</p>
<p>&lt;/body&gt;
</p>
<p>&lt;/html&gt;
</p>
<p>This makes it easy to generate WWW pages with a &#12;xed visual layout:
</p>
<p>&lt;?php
</p>
<p>#
</p>
<p># Standard layout
</p>
<p>#
</p>
<p># Set $title, $comment and $contents
</p>
<p>##########################################################################
</p>
<p>print &quot;&lt;body&gt;\n&quot;;
</p>
<p>print &quot;&lt;img src=img/header.gif&gt;&quot;;
</p>
<p>print &quot;&lt;h1&gt;&quot;$title&lt;/h1&gt;&quot;;
</p>
<p>print &quot;&lt;em&gt;$comment&lt;/em&gt;&quot;;
</p>
<p>print &quot;&lt;blockquote&gt;\n&quot;;
</p>
<p>include $contents;
</p>
<p>print (&quot;&lt;/blockquote&gt;\n&quot;);
</p>
<p>print (&quot;&lt;/body&gt;\n&quot;);
</p>
<p>print (&quot;&lt;/html&gt;\n&quot;);
</p>
<p>Variables are easily set by calling PHP code in the form of a CGI program from a form.
</p>
<p>8.5.2 PHP and forms
</p>
<p>PHP is particularly good at dealing with forms, as a CGI scripting langauge. Consider
</p>
<p>the following form:
</p>
<p>&lt;html&gt;
</p>
<p>&lt;body&gt;
</p>
<p>&lt;form action=&quot;/cgi-bin-scriptalias/spititout.php&quot; method=&quot;post&quot;&gt;
</p>
<p>Name: &lt;input type=&quot;text&quot; name=&quot;personal[name]&quot;&gt;&lt;br&gt;
</p>
<p>Email: &lt;input type=&quot;text&quot; name=&quot;personal[email]&quot;&gt;&lt;br&gt;
</p>
<p>Preferred language:
</p>
<p>&lt;select multiple name=&quot;language[]&quot;&gt;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 8: WWW and CGI programming 113
</p>
<p>&lt;option value=&quot;English&quot;&gt;English
</p>
<p>&lt;option value=&quot;Norwegian&quot;&gt;Norwegian
</p>
<p>&lt;option value=&quot;Gobbledigook&quot;&gt;Gobbledigook
</p>
<p>&lt;/select&gt;
</p>
<p>&lt;input type=image src=&quot;image.gif&quot; name=&quot;sub&quot;&gt;
</p>
<p>&lt;/form&gt;
</p>
<p>&lt;/body&gt;
</p>
<p>&lt;/html&gt;
</p>
<p>This produces a page into which one types a name and email address and chooses a
</p>
<p>language from a list of three possible choices. When the user clicks on a button marked by
</p>
<p>the &#12;le `image.gif' the form is posted. Here is a program which unravels the data sent to
</p>
<p>the CGI program:
</p>
<p>#!/local/bin/php
</p>
<p>&lt;?php
</p>
<p>#
</p>
<p># A CGI program which handles a form
</p>
<p># Variables a translated automatically
</p>
<p>#
</p>
<p>$title = &quot;This page title&quot;;
</p>
<p>$comment = &quot;This pages talks about the following.....&quot;;
</p>
<p>##########################################################################
</p>
<p>echo &quot;&lt;body&gt;&quot;;
</p>
<p>echo &quot;&lt;h1&gt;$title&lt;/h1&gt;&quot;;
</p>
<p>echo &quot;&lt;em&gt;$comment&lt;/em&gt;&quot;;
</p>
<p>echo &quot;&lt;blockquote&gt;\n&quot;;
</p>
<p>###
</p>
<p>echo &quot;Your name is $personal[name]&lt;br&gt;&lt;br&gt;&quot;;
</p>
<p>echo &quot;Your email is $personal[email]&lt;br&gt;&lt;br&gt;&quot;;
</p>
<p>echo &quot;Language options: &quot;;
</p>
<p>echo &quot;&lt;table&gt; &quot;;
</p>
<p>for ($i = 0; strlen($language[$i]) &gt; 0; $i++)
</p>
<p>{
</p>
<p>echo &quot;&lt;tr&gt;&lt;td bgcolor=#ff0000&gt;Variable language[$i] = $language[$i]&lt;/td&gt;&lt;/tr&gt;&quot;;
</p>
<p>}
</p>
<p>if ($language[0] == &quot;Norwegian&quot;)
</p>
<p>{
</p>
<p>echo &quot;Hei alle sammen&lt;p&gt;&quot;;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>114 The unix programming environment
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>echo &quot;Greetings everyone, this page will be in English&lt;p&gt;&quot;;
</p>
<p>}
</p>
<p>echo &quot;&lt;/table&gt; &quot;;
</p>
<p>###
</p>
<p>echo (&quot;&lt;/blockquote&gt;\n&quot;);
</p>
<p>echo (&quot;&lt;/body&gt;\n&quot;);
</p>
<p>echo (&quot;&lt;/html&gt;\n&quot;);
</p>
<p>?&gt;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 115
</p>
<p>9 C programming
</p>
<p>This section is not meant to teach you C. It is a guide to using C in UNIX and it is
</p>
<p>assumed that you have a working knowledge of the language. See the GNU C-Tutorial for
</p>
<p>an introduction to basics.
</p>
<p>9.1 Shell or C?
</p>
<p>In the preceding chapters we have been looking at ways to get simple programming
</p>
<p>tasks done. The immediateness of the script languages is a great advantage when we just
</p>
<p>want to get a job done as quickly as possible. Scripts lend themselves to simple system
</p>
<p>administration tasks like &#12;le processing, but they do not easily lend themselves to more
</p>
<p>serious programs.
</p>
<p>Although some system administrators have grown to the idea that shell programming
</p>
<p>is easier, I would argue that this is not really true. First of all, most of the UNIX shell
</p>
<p>commands are just wrapper programs for C function calls. Why use the wrapper when you
</p>
<p>can use the real thing? Secondly, the C function calls return data in pointers and structures
</p>
<p>which are very easy to manipulate, whereas piping the output of shell programs into others
</p>
<p>can be a very messy and awkward way of working. Here are some of the reasons why we
</p>
<p>also need a more traditional programming language like C.
</p>
<p>1. The shell languages do not allow us to create an acceptable user-interface, like X-
</p>
<p>windows, or the curses (cursor manipulation) library. They are mainly intended for
</p>
<p>&#12;le-processing. (Though recently the Tk library has provided a way of creating user
</p>
<p>interfaces in Tcl and Perl.)
</p>
<p>2. Shell commands read their input line-by-line. Not all input is generated in this simple
</p>
<p>way { we also need to be able to read through lines i.e. the concept of a data stream.
</p>
<p>3. More advanced data structures are needed for most applications, such as linked lists
</p>
<p>and binary trees, acyclic graphs etc.
</p>
<p>4. Compilers help to sort out simple typographical and logical errors by compile-time
</p>
<p>checking source code.
</p>
<p>5. Compiled code is faster than interpreted code.
</p>
<p>6. Many tools have been written to help in the programming of C code (dbx, lex, yacc
</p>
<p>etc.).
</p>
<p>9.2 C program structure
</p>
<p>9.2.1 The form of a C program
</p>
<p>A C program consists of a set of function, beginning with the main program:
</p>
<p>main () /* This is a comment */
</p>
<p>{
</p>
<p>Commands ...</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>116 The unix programming environment
</p>
<p>}
</p>
<p>The source code of a C program can be divided into several text &#12;les. C compiles all
</p>
<p>functions separately; the linker ld joins them all up at the end. This means that we can
</p>
<p>plan out a strategy for writing large programs in a clear and e&#14;cient manner.
</p>
<p>NOTE: C++ style comments `//...' are not allowed by most C compilers.
</p>
<p>9.2.2 Macros and declarations
</p>
<p>Most Unix systems now have ANSI C compatible compilers, but this has not always
</p>
<p>been the case. Most UNIX programs written in a version of C which is older than the ANSI
</p>
<p>standard, so you will need an appreciation of old Kernighan and Ritchie C conventions for
</p>
<p>C programming. See for example my C book.
</p>
<p>An obvious di&#11;erence between ANSI C and K&amp;R C is that the C++ additions to the
</p>
<p>language are not included. Here are some useful points to remember.
</p>
<p>&#15; K&amp;R C does not allow `const' data, it uses the C preprocessor with `#define' instead.
</p>
<p>i.e. intead of
</p>
<p>const int blah = 1;
</p>
<p>use
</p>
<p>#define blah 1
</p>
<p>Remember that the hash symbol `#' must be the &#12;rst character on a line under UNIX.
</p>
<p>&#15; K&amp;R C doesn't use function prototypes or declarations of the form:
</p>
<p>void function (char *string, int a, int b)
</p>
<p>{
</p>
<p>}
</p>
<p>Instead one writes:
</p>
<p>void function (string, a, b)
</p>
<p>char *string;
</p>
<p>int a,b;
</p>
<p>{
</p>
<p>}
</p>
<p>9.2.3 Several &#12;les
</p>
<p>Most unix programs are very large and are split up into many &#12;les. Remember, when
</p>
<p>you split up programs into several &#12;les, you must declare variables as `extern' in &#12;le A if</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 117
</p>
<p>they are really declared in &#12;le B. in which you want to use them. This tells the compiler
</p>
<p>that it should not try to create local storage for the variable, because this was already done
</p>
<p>in another &#12;le.
</p>
<p>9.3 A note about UNIX system calls and standards
</p>
<p>Most of the system calls in UNIX return data in the form of `struct' variables. Some-
</p>
<p>times these are structures used by the operating system itself { in other cases they are just
</p>
<p>put together so that programmers can handle a packet of data in a convenient way.
</p>
<p>If in doubt, you can &#12;nd the de&#12;nitions of these structures in the relevant include &#12;les
</p>
<p>under `/usr/include'.
</p>
<p>Since UNIX comes in many &#13;avours the system calls are not always compatible and may
</p>
<p>have di&#11;erent options and arguments. Because of this there is a number of standardizing
</p>
<p>organizations for UNIX. One of them is POSIX which is an organization run by the major
</p>
<p>UNIX vendors. Programs written for UNIX are now expected to be POSIX compliant. This
</p>
<p>is not something you need to think about at the level of this course, but you should certainly
</p>
<p>remember that there exist programming standards and that these should be adhered to.
</p>
<p>The aim is to work towards a single standard UNIX.
</p>
<p>9.4 Compiling: `cc', `ld' and `a.out'
</p>
<p>The C compiler on the unix system is traditionally called `cc' and has always been a
</p>
<p>traditional part of every Unix environment. Recently several Unix vendors have stopped
</p>
<p>including the C compiler as a part of their operating systems and instead sell a compiler
</p>
<p>separately. Fortunately there is a public domain Free Software version of the compiler called
</p>
<p>`gcc' (the GNU C compiler). We shall use this in all the examples.
</p>
<p>To compile a program consisting of several &#12;les of code, we &#12;rst compile all of the separate
</p>
<p>pieces without trying to link them. There are therefore two stages: &#12;rst we turn `.c' &#12;les
</p>
<p>into `.o' &#12;les. This compiles code but does not &#12;x any address references. Then we link all
</p>
<p>`.o' &#12;les into the &#12;nal executable, including any libraries which are used.
</p>
<p>Let's suppose we have &#12;les `a.c', `b.c' and `c.c'. We write:
</p>
<p>gcc -c a.c b.c c.c
</p>
<p>This creates &#12;les `a.o', `b.o' and `c.o'. Next we link them into one &#12;le called `myprog'.
</p>
<p>gcc -o myprog a.o b.o c.o
</p>
<p>If the naming option `-o myprog' is not used, the link `ld' uses the default name a.out for
</p>
<p>the executable &#12;le.
</p>
<p>9.4.1 Libraries and `LD_LIBRARY_PATH'
</p>
<p>The resulting &#12;le is called `myprog' and includes references only to the standard li-
</p>
<p>brary `libc'. If we wish to link in the math library `libm' or the cursor movement library
</p>
<p>`libcurses' { or in general, a library called `libBLAH' , we need to use the `-l' directive.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>118 The unix programming environment
</p>
<p>gcc -o myprog files.o -lm -lcurses -lBLAH
</p>
<p>The compiler looks for a suitable library in all of the directories listed in the environment
</p>
<p>variable `LD_LIBRARY_PATH'. Alternatively we can add a directory to the search path by
</p>
<p>using the `-L'. option:
</p>
<p>gcc -o myprog files.o -L/usr/local/lib -lm -lcurses -lBLAH
</p>
<p>9.4.2 Include &#12;les
</p>
<p>Normally the compiler looks for include &#12;les only in the directory `/usr/include'. We
</p>
<p>can add further paths to search using the `-I' option.
</p>
<p>gcc -o myprog file.c -I/usr/local/include -I/usr/local/X11/include
</p>
<p>Previously, Unix libraries have been in `a.out' code format, but recent releases of unix
</p>
<p>have gone over to a more e&#14;cient and &#13;exible format called ELF (executable and linking
</p>
<p>format).
</p>
<p>9.4.3 Shared and static libraries
</p>
<p>Libraries are collections of C functions which the operating system creators have written
</p>
<p>for our convenience. The source code for such a library is just the source for a collection of
</p>
<p>functions { there is no main program.
</p>
<p>There are two kinds of library used by modern operating systems: archive libraries or
</p>
<p>static libraries and shared libraries or dynamical libraries. An archive library has a
</p>
<p>name of the form
</p>
<p>libname.a
</p>
<p>When an archive library is linked to a program, it is appended lock, stock and barrel to the
</p>
<p>program code. This uses a lot of disk space and makes the size of the compiled program very
</p>
<p>large. Shared libraries (shared objects `so' or shared archives `sa' generally have names of
</p>
<p>the form)
</p>
<p>libname.so
</p>
<p>libname.sa
</p>
<p>often with version numbers appended. When a program is linked with a shared library the
</p>
<p>code is not appended to the program. Instead pointers to the shared objects are created and
</p>
<p>the library is loaded at runtime, thus avoiding the problem of having to store the library
</p>
<p>e&#11;ectively multiple times on the disk.
</p>
<p>To make an archive library we compile all of the functions we wish to include in the
</p>
<p>library</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 119
</p>
<p>gcc -c function1.c function2.c ...
</p>
<p>and then join the &#12;les using the `ar' command.
</p>
<p>ar rcv libMYLIB.a function1.o
</p>
<p>ar rcv libMYLIB.a function2.o
</p>
<p>To make a shared library one provides an option to the linker program. The exact method
</p>
<p>is di&#11;erent in di&#11;erent operating systems, so you should look at the manual page for ld on
</p>
<p>your system. Under SunOS 4 we take the object &#12;les `*.o' and run
</p>
<p>ld -o libMYLIB.so.1.1 -assert pure-text *.o
</p>
<p>Under HPUX, we write
</p>
<p>ld -b -o libMYLIB.so.1.1 *.o
</p>
<p>With the GNU linker, you write
</p>
<p>ld -shared -o libMYLIB.so.1.1 *.o
</p>
<p>NOTE: when you add a shared library to the system under SunOS or GNU/Linux
</p>
<p>you must run the command `ldconfig', making sure that the path to the library is in-
</p>
<p>cluded in `LD_LIBRARY_PATH'. SunOS and GNU/Linux use a cache &#12;le `/etc/ld.so.cache'
</p>
<p>to keep current versions of libraries. GNU/Linux also uses a con&#12;guration &#12;le called
</p>
<p>`/etc/ld.so.conf'.
</p>
<p>9.4.4 Knowing about important paths: directory structure
</p>
<p>It is important to understand how the C compiler &#12;nds the &#12;les it needs. We have
</p>
<p>already mentioned the `-I' and `-L' options to the compilation command line. In general,
</p>
<p>all system include &#12;les can be found in the directory `/usr/include' and subdirectories of
</p>
<p>this directory. All system libraries can be found in `/usr/lib'.
</p>
<p>Many packages build their own libraries and keep the relevant &#12;les in separate directories
</p>
<p>so that if the system gets reinstalled, they do not get deleted. This is true for example of
</p>
<p>the X-windows system. The include and library &#12;les for this are typically kept in directo-
</p>
<p>ries which look something like `/usr/local/X11R5/include' and `/usr/X11R6/lib'. That
</p>
<p>means that we need to give all of this information to the compiler. Compiling a program
</p>
<p>becomes a complicated task in many cases so we need some kind of script to help us perform
</p>
<p>the task. The Unix tool make was designed for this purpose.
</p>
<p>9.5 Make
</p>
<p>Nowadays compilers are often sold with fancy user environments driven by menus which
</p>
<p>make it easier to compile programs. Unix has similar environments but all of them use</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>120 The unix programming environment
</p>
<p>shell-based command line compilation beneath the surface. That is because UNIX pro-
</p>
<p>grammers are used to writing large and complex programs which occupy many directories
</p>
<p>and subdirectories. Each directory has to be adapted or con&#12;gured to &#12;t the particular
</p>
<p>&#13;avour of Unix system it is being compiled upon. Interactive user environments are very
</p>
<p>poor at performing this kind of service. UNIX solves the problem of compiling enormous
</p>
<p>trees of software (such as the unix system itself!) by using a compilation language called
</p>
<p>`make'. Such language &#12;les can be generated automatically by scripts, allowing very complex
</p>
<p>programs to con&#12;gure and compile themselves from a single control script.
</p>
<p>9.5.1 Compiling large projects
</p>
<p>Typing lines like
</p>
<p>cc -c file1.c file2.c ...
</p>
<p>cc -o target file1.o ....
</p>
<p>repeatedly to compile a complicated program can be a real nuisance. One possibility
</p>
<p>would therefore be to keep all the commands in a script. This could waste a lot of time
</p>
<p>though. Suppose you are working on a big project which consists of many lines of source code
</p>
<p>{ but are editing only one &#12;le. You really only want to recompile the &#12;le you are working
</p>
<p>on and then relink the resulting object &#12;le with all of the other object &#12;les. Recompiling
</p>
<p>the other &#12;les which hadn't changed would be a waste of time. But that would mean that
</p>
<p>you would have to change the script each time you change what you need to compile.
</p>
<p>A better solution is to use the `make' command. `make' was designed for precisely this
</p>
<p>purpose. To use `make', we create a &#12;le called `Makefile' in the same directory as our
</p>
<p>program. `make' is a quite general program for building software. It is not speci&#12;cally tied
</p>
<p>to the C programming language| it can be used in any programming language.
</p>
<p>A `make' con&#12;guration &#12;le, called a `Makefile', contains rules which describe how to
</p>
<p>compile or build all of the pieces of a program. For example, even without telling it speci&#12;-
</p>
<p>cally, make knows that in order to go from `prog.c' to `prog.o' the command `cc -c prog.c'
</p>
<p>must be executed. A Make&#12;le works by making such associations. The Make&#12;le contains a
</p>
<p>list of all of the &#12;les which compose the program and rules as to how to get to the &#12;nished
</p>
<p>product from the source.
</p>
<p>The idea is that, to compile a program, we just have to type make. `make' then reads
</p>
<p>the Make&#12;le and compiles all of the parts which need compiling. It does not recompile &#12;les
</p>
<p>which have not changed since the last compilation! How does it do this? `make' works by
</p>
<p>comparing the time-stamp on the &#12;le it needs to create with the time-stamp on the &#12;le
</p>
<p>which is to be compiled. If the compiled version exists and is newer than its source then
</p>
<p>the source does not need to be recompiled.
</p>
<p>To make this idea work in practice, `make' has to know how to go through the steps of
</p>
<p>compiling a program. Some default rules are de&#12;ned in a global con&#12;guration &#12;le, e.g.
</p>
<p>/usr/include/make/default.mk
</p>
<p>Let's consider an example of what happens for the the three &#12;les `a.c', `b.c' and `c.c' in
</p>
<p>the example above { and let's not worry about what the Make&#12;le looks like yet.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 121
</p>
<p>The &#12;rst time we compile, only the `.c' &#12;les exist. When we type `make', the program
</p>
<p>looks at its rules and &#12;nds that it has to make a &#12;le called `myprog'. To make this it needs
</p>
<p>to execute the command
</p>
<p>gcc -o myprog a.o b.o c.o
</p>
<p>So it looks for `a.o' etc and doesn't &#12;nd them. It now goes to a kind of subroutine and looks
</p>
<p>to see if it has any rules for making &#12;les called `.o' and it discovers that these are made by
</p>
<p>compiling with the `gcc -c' option. Since the &#12;les do not exist, it does this. Now the &#12;les
</p>
<p>`a.o b.o c.o' exist and it jumps back to the original problem of trying to make `myprog'. All
</p>
<p>the &#12;les it needs now exist and so it executes the command and builds `myprog'.
</p>
<p>If we now edit `a.c', and type `make' once again { it goes through the same procedure as
</p>
<p>before but now it &#12;nds all of the &#12;les. So it compares the dates on the &#12;les { if the source
</p>
<p>is newer than the result, it recompiles.
</p>
<p>By using this recursive method, `make' only compiles those parts of a program which
</p>
<p>need compiling.
</p>
<p>9.5.2 Make&#12;les
</p>
<p>To write a Make&#12;le, we have to tell `make' about dependencies. The dependencies of a
</p>
<p>&#12;le are all of those &#12;les which are required to build it. Thus, the dependencies of `myprog'
</p>
<p>are `a.o', `b.o' and `c.o'. The dependencies of `a.o' are simply `a.c', the dependencies of `b.o'
</p>
<p>are `b.c' and so on.
</p>
<p>A Make&#12;le consists of rules of the form:
</p>
<p>target : dependencies
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>rule;
</p>
<p>The target is the thing we want to build, the dependenices are like subroutines to be executed
</p>
<p>&#12;rst if they do not exist. Finally the rule is to be executed if all if the dependenices exist;
</p>
<p>it takes the dependencies and turns them into the target. There are two important things
</p>
<p>to remember:
</p>
<p>&#15; The &#12;le names must start on the &#12;rst character of a line.
</p>
<p>&#15; There must be a
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>character at the beginning of every rule or action. If there are
</p>
<p>spaces instead of tabs, or no tab at all, `make' will signal an error. This bizarre feature
</p>
<p>can cause a lot of confusion.
</p>
<p>Let's look at an example Make&#12;le for a program which consists of two course &#12;les `main.c'
</p>
<p>and `other.c' and which makes use of a library called `libdb' which lies in the directory
</p>
<p>`/usr/local/lib'. Our aim is to build a program called database:
</p>
<p>#
</p>
<p># Simple Makefile for `database'
</p>
<p>#
</p>
<p># First define a macro</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>122 The unix programming environment
</p>
<p>OBJ = main.o other.o
</p>
<p>CC = gcc
</p>
<p>CFLAGS = -I/usr/local/include
</p>
<p>LDFLAGS = -L/usr/local/lib -ldb
</p>
<p>INSTALLDIR = /usr/local/bin
</p>
<p>#
</p>
<p># Rules start here. Note that the $@ variable becomes the name of the
</p>
<p># executable file. In this case it is taken from the ${OBJ} variable
</p>
<p>#
</p>
<p>database: ${OBJ}
</p>
<p>${CC} -o $@ ${OBJ} ${LDFLAGS}
</p>
<p>#
</p>
<p># If a header file changes, normally we need to recompile everything.
</p>
<p># There is no way that make can know this unless we write a rule which
</p>
<p># forces it to rebuild all .o files if the header file changes...
</p>
<p>#
</p>
<p>${OBJ}: ${HEADERS}
</p>
<p>#
</p>
<p># As well as special rules for special files we can also define a
</p>
<p># &quot;suffix rule&quot;. This is a rule which tells us how to build all files
</p>
<p># of a certain type. Here is a rule to get .o files from .c files.
</p>
<p># The $&lt; variable is like $? but is only used in suffix rules.
</p>
<p>#
</p>
<p>.c.o:
</p>
<p>${CC} -c ${CFLAGS} $&lt;
</p>
<p>#######################################################################
</p>
<p># Clean up
</p>
<p>#######################################################################
</p>
<p>#
</p>
<p># Make can also perform ordinary shell command jobs
</p>
<p># &quot;make tidy&quot; here performs a cleanup operation
</p>
<p>#
</p>
<p>clean:
</p>
<p>rm -f ${OBJ}
</p>
<p>rm -f y.tab.c lex.yy.c y.tab.h
</p>
<p>rm -f y.tab lex.yy
</p>
<p>rm -f *% *~ *.o
</p>
<p>rm -f mconfig.tab.c mconfig.tab.h a.out</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 123
</p>
<p>rm -f man.dvi man.aux man.log man.toc
</p>
<p>rm -f cfengine.tar.gz cfengine.tar cfengine.tar.Z
</p>
<p>make tidy
</p>
<p>rm -f cfengine
</p>
<p>install: ${INSTALLDIR}/database
</p>
<p>cp database ${INSTALLDIR}/database
</p>
<p>The Make&#12;le above can be invoked in several ways.
</p>
<p>make
</p>
<p>make database
</p>
<p>make clean
</p>
<p>make install
</p>
<p>If we simple type `make' i.e. the &#12;rst of these choices, `make' takes the &#12;rst of the rules it
</p>
<p>&#12;nds as the object to build. In this case the rule is `database', so the &#12;rst two forms above
</p>
<p>are equivalent.
</p>
<p>On the other hand, if we type
</p>
<p>make clean
</p>
<p>then execution starts at the rule for `clean', which is normally used to remove all &#12;les except
</p>
<p>the original source code. Make `install' causes the compiled program to be installed at its
</p>
<p>intended destination.
</p>
<p>`make' uses some special variables (which resemble the special variables used in Perl {
</p>
<p>but don't confuse them). The most useful one is `$@' which represents the current target {
</p>
<p>or the object which `make' would like to compile. i.e. as `make' checks each &#12;le it would like
</p>
<p>to compile, `$@' is set to the current &#12;lename.
</p>
<p>$@ This evaluates to the current target i.e. the name of the object you are currently
</p>
<p>trying to build. It is normal to use this as the &#12;nal name of the program when
</p>
<p>compiling
</p>
<p>$? This is used only outside of su&#14;x rules and means the name of all the &#12;les
</p>
<p>which must be compiled in order to build the current target.
</p>
<p>target: file1.o file2.o
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>cc -o $@ $?
</p>
<p>$&lt; This is only used in su&#14;x rules. It has the same meaning as `$?' but only in
</p>
<p>su&#14;x rules. It stands for the pre-requisite, or the &#12;le which must be compiled
</p>
<p>in order to make a given object.
</p>
<p>Note that, because `make' has some default rules de&#12;ned in its con&#12;guration &#12;le, a single-
</p>
<p>&#12;le C program can be compiled very easily by typing
</p>
<p>make filename.c
</p>
<p>This is equivalent to
</p>
<p>cc -c filename.c
</p>
<p>cc -o filename filename.o</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>124 The unix programming environment
</p>
<p>9.5.3 New su&#14;x rules for C++
</p>
<p>Standard rules for C++ are not often built into UNIX systems at the time of writing, but
</p>
<p>we can create them in our own Make&#12;les very easily. Here we shall use the GNU compiler
</p>
<p>g++'s conventions for C++ &#12;les. Here is a sample Make&#12;le for using C++. Note that the
</p>
<p>`.SUFFIXES' command must be used to declare new endings or &#12;le extensions.
</p>
<p>##################################################################
</p>
<p>#
</p>
<p># This is the Makefile for g++
</p>
<p>#
</p>
<p>##################################################################
</p>
<p>OBJ = cpp-prog.o X.o Y.o Z.o
</p>
<p>CCPLUS = g++
</p>
<p>.SUFFIXES: .C .o .h
</p>
<p>#
</p>
<p># Program Rules
</p>
<p>#
</p>
<p>filesys: ${OBJ}
</p>
<p>$(CCPLUS) -o filesys $(OBJ)
</p>
<p>#
</p>
<p># Extra dependencies on the header file
</p>
<p># (if the header file changes, we need to rebuild *.o)
</p>
<p>#
</p>
<p>cpp-prog.o: filesys.h
</p>
<p>X.o: filesys.h
</p>
<p>Y.o: filesys.h
</p>
<p>Z.o: filesys.h
</p>
<p>#
</p>
<p># Suffix rules
</p>
<p>#
</p>
<p>.C.o:
</p>
<p>$(CCPLUS) -c $&lt;
</p>
<p>The general rule here tells make that a `.o' &#12;le can be created from a `.C' &#12;le by executing
</p>
<p>the command `$(CCPLUS) -c'. (This is identical to the C case, exept for the name of the
</p>
<p>compiler). The extra dependencies tell make that, if we change the header &#12;le `filesys.h',
</p>
<p>then we must recompile all the &#12;les which read in `filesys.h', since this could a&#11;ect all</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 125
</p>
<p>of these. Finally, the highest level rule says that to make `filesys' from the `.o' &#12;les, we
</p>
<p>have to run `$(CCPLUS) -o filesys *.o'.
</p>
<p>9.6 The argv, argc and envp paramters
</p>
<p>When we write C programs which reads command line arguments, they are fed to us as
</p>
<p>an array of strings called the argument vector. The mechanisms for the C-shell and Perl
</p>
<p>are derived from the C argument vector. To read in the command line, we write
</p>
<p>main (argc,argv,envp)
</p>
<p>int argc;
</p>
<p>char *argv[], *envp[];
</p>
<p>{
</p>
<p>printf (&quot;The first argument was %s\n&quot;,argv[1]);
</p>
<p>}
</p>
<p>Argument zero is the name of the program itself and `argv[argc-1]' is the last argument.
</p>
<p>The above de&#12;nitions are in Kernighan and Ritchie C style. In ANSI C, the arguments can
</p>
<p>be declared using prototype:
</p>
<p>main (int argc, char **argv)
</p>
<p>{
</p>
<p>}
</p>
<p>The array of strings `envp[]' is a list of values of the environment variables of the system,
</p>
<p>formatted by
</p>
<p>NAME=value
</p>
<p>This gives C programmers access to the shell's global environment.
</p>
<p>9.7 Environment variables in C
</p>
<p>In addition to the `envp' vector, it is possible to access the environment variables through
</p>
<p>the call `getenv()'. This is used as follows; suppose we want to access the shell environment
</p>
<p>variable `$HOME'.
</p>
<p>char *string;
</p>
<p>string = getenv(&quot;HOME&quot;);
</p>
<p>`string' is now a pointer to static but public data. You should not use `string' as if it
</p>
<p>were you're own property because it will be used again by the system. Copy it's contents
</p>
<p>to another string before using the data.
</p>
<p>char buffer[500];
</p>
<p>strcpy (buffer,string);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>126 The unix programming environment
</p>
<p>9.8 Files and directories
</p>
<p>All of the regular C functions from the standard library are available to Unix program-
</p>
<p>mers. The standard functions only address the issue of reading and writing to &#12;les however,
</p>
<p>they do not deal with operating system speci&#12;c attributes such as &#12;le permissions and &#12;le
</p>
<p>types. Nor is there a mechanisms for obtaining lists of &#12;les within a directory. The reason
</p>
<p>for these omissions is that they are operating system dependent. To &#12;nd out about these
</p>
<p>other attributes POSIX describes some standard Unix system calls.
</p>
<p>9.8.1 opendir, readdir
</p>
<p>Files and directories are handled by functions de&#12;ned in the header &#12;le `dirent.h'. In
</p>
<p>earlier UNIX systems the &#12;le `dir.h' was used { and the de&#12;nitions were slightly di&#11;erent,
</p>
<p>but not much. To get a list of &#12;les in a directory we must open the directory and read
</p>
<p>from it { just like a &#12;le. (A directory is just a &#12;le which contains data on its entries). The
</p>
<p>commands are
</p>
<p>opendir
</p>
<p>closedir
</p>
<p>readdir
</p>
<p>See the manual pages for dirent. These functions return pointers to a dirent structure
</p>
<p>which is de&#12;ned in the &#12;le `/usr/include/dirent.h'. Here is an example ls command
</p>
<p>which lists the contents of the directory `/etc'. This header de&#12;nes a structure
</p>
<p>struct dirent
</p>
<p>{
</p>
<p>off_t d_off; /* offset of next disk dir entry */
</p>
<p>unsigned long d_fileno; /* file number of entry */
</p>
<p>unsigned short d_reclen; /* length of this record */
</p>
<p>unsigned short d_namlen; /* length of string in d_name */
</p>
<p>char d_name[255+1]; /* name (up to MAXNAMLEN + 1) */
</p>
<p>};
</p>
<p>which can be used to obtain information from the directory nodes.
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>#include &lt;dirent.h&gt;
</p>
<p>main ()
</p>
<p>{ DIR *dirh;
</p>
<p>struct dirent *dirp;
</p>
<p>static char mydir[20] = &quot;/etc&quot;;
</p>
<p>if ((dirh = opendir(mydir)) == NULL)
</p>
<p>{
</p>
<p>perror(&quot;opendir&quot;);
</p>
<p>return;
</p>
<p>}</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 127
</p>
<p>for (dirp = readdir(dirh); dirp != NULL; dirp = readdir(dirh))
</p>
<p>{
</p>
<p>printf(&quot;Got dir entry: %s\n&quot;,dirp-&gt;d_name);
</p>
<p>}
</p>
<p>closedir(dirh);
</p>
<p>}
</p>
<p>Notice that reading from a directory is like reading from a &#12;le with fgets(), but the entries
</p>
<p>are &#12;lenames rather than lines of text.
</p>
<p>9.8.2 stat()
</p>
<p>To determine the &#12;le properties or statistics we use the function call `stat()' or its
</p>
<p>corollory `lstat()'. Both these functions &#12;nd out information about &#12;les (permissions,
</p>
<p>owner, &#12;letype etc). The only di&#11;erence between them is the way in which they treat
</p>
<p>symbolic links. If `stat' is used on a symbolic link, it stats the &#12;le the link points to rather
</p>
<p>than the link itself. If `lstat' is used, the data refer to the link. Thus, to detect a link, we
</p>
<p>must use `lstat', See Section 9.8.3 [lstat and readlink], page 127.
</p>
<p>The data in the `stat' structure are de&#12;ned in the &#12;le `/usr/include/sys/stat.h'. Here
</p>
<p>are the most important structures.
</p>
<p>struct stat
</p>
<p>{
</p>
<p>dev_t st_dev; /* device number*/
</p>
<p>ino_t st_ino; /* file inode */
</p>
<p>mode_t st_mode; /* permission */
</p>
<p>short st_nlink; /* Number of hardlinks to file */
</p>
<p>uid_t st_uid; /* user id */
</p>
<p>gid_t st_gid; /* group id */
</p>
<p>dev_t st_rdev;
</p>
<p>off_t st_size; /* size in bytes */
</p>
<p>time_t st_atime; /* time file last accessed */
</p>
<p>time_t st_mtime; /* time file contents last modified */
</p>
<p>time_t st_ctime; /* time last attribute change */
</p>
<p>long st_blksize;
</p>
<p>long st_blocks;
</p>
<p>};
</p>
<p>9.8.3 lstat and readlink
</p>
<p>The function `stat()' treats symbolic links as though they were the &#12;les they point to.
</p>
<p>In other words, if we use `stat()' to read a symbolic link, we end up reading the &#12;le the
</p>
<p>link points to and not the link itself| we never see symbolic links. To avoid this problem,
</p>
<p>there is a di&#11;erent version of the stat function called `lstat()' which is identical to `stat()'</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>128 The unix programming environment
</p>
<p>except that it treats links as links and not as the &#12;les they point to. This means that we can
</p>
<p>test whether a &#12;le is a symbolic link, only if we use `lstat()'. (See the next paragraph.)
</p>
<p>Once we have identi&#12;ed a &#12;le to be a symbolic link, we use the `readlink()' function
</p>
<p>to obtain the name of the &#12;le the link points to.
</p>
<p>#define bufsize 512
</p>
<p>char buffer[bufsize];
</p>
<p>readlink(&quot;/path/to/file&quot;,buffer,bufsize);
</p>
<p>The result is returned in the string bu&#11;er.
</p>
<p>9.9 stat() test macros
</p>
<p>As we have already mentioned, the Unix mode bits contain not only information about
</p>
<p>what permissions a &#12;le has, but also bits describing the type of &#12;le { whether it is a
</p>
<p>directory or a link etc. There are macros de&#12;ned in UNIX to extract this information from
</p>
<p>the `st_mode' member of the `stat' structure. They are de&#12;ned in the `stat.h' header&#12;le.
</p>
<p>Here are some examples.
</p>
<p>#define S_ISBLK(m) /* is block device */
</p>
<p>#define S_ISCHR(m) /* is character device */
</p>
<p>#define S_ISDIR(m) /* is directory */
</p>
<p>#define S_ISFIFO(m) /* is fifo pipe/socket */
</p>
<p>#define S_ISREG(m) /* is regular (normal) file */
</p>
<p>#define S_ISLNK(m) /* is symbolic link */ /* Not POSIX */
</p>
<p>#define S_ISSOCK(m) /* is a lock */
</p>
<p>#define S_IRWXU /* rwx, owner */
</p>
<p>#define S_IRUSR /* read permission, owner */
</p>
<p>#define S_IWUSR /* write permission, owner */
</p>
<p>#define S_IXUSR /* execute/search permission, owner */
</p>
<p>#define S_IRWXG /* rwx, group */
</p>
<p>#define S_IRGRP /* read permission, group */
</p>
<p>#define S_IWGRP /* write permission, grougroup */
</p>
<p>#define S_IXGRP /* execute/search permission, group */
</p>
<p>#define S_IRWXO /* rwx, other */
</p>
<p>#define S_IROTH /* read permission, other */
</p>
<p>#define S_IWOTH /* write permission, other */
</p>
<p>#define S_IXOTH /* execute/search permission, other */
</p>
<p>These return true or false when acting on the mode member. Here is an example See
</p>
<p>Section 9.9.1 [readdir example], page 129.
</p>
<p>struct stat statvar;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 129
</p>
<p>stat(&quot;file&quot;,&amp;statvar);
</p>
<p>/* test return values */
</p>
<p>if (S_ISDIR(statvar.st_mode))
</p>
<p>{
</p>
<p>printf(&quot;Is a directory!&quot;);
</p>
<p>}
</p>
<p>9.9.1 Example &#12;ling program
</p>
<p>The following example program demonstrates the use of the directory functions in dirent
</p>
<p>and the stat function call.
</p>
<p>/********************************************************************/
</p>
<p>/* */
</p>
<p>/* Reading directories and `statting' files */
</p>
<p>/* */
</p>
<p>/********************************************************************/
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>#include &lt;dirent.h&gt;
</p>
<p>#include &lt;sys/types.h&gt;
</p>
<p>#include &lt;sys/stat.h&gt;
</p>
<p>#define DIRNAME &quot;/.&quot;
</p>
<p>#define bufsize 255
</p>
<p>/********************************************************************/
</p>
<p>main ()
</p>
<p>{ DIR *dirh;
</p>
<p>struct dirent *dirp;
</p>
<p>struct stat statbuf;
</p>
<p>char *pathname[bufsize];
</p>
<p>char *linkname[bufsize];
</p>
<p>if ((dirh = opendir(DIRNAME)) == NULL)
</p>
<p>{
</p>
<p>perror(&quot;opendir&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>for (dirp = readdir(dirh); dirp != NULL; dirp = readdir(dirh))
</p>
<p>{
</p>
<p>if (strcmp(&quot;.&quot;,dirp-&gt;d_name) == 0 || strcmp(&quot;..&quot;,dirp-&gt;d_name) == 0)</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>130 The unix programming environment
</p>
<p>{
</p>
<p>continue;
</p>
<p>}
</p>
<p>if (strcmp(&quot;lost+found&quot;,dirp-&gt;d_name) == 0)
</p>
<p>{
</p>
<p>continue;
</p>
<p>}
</p>
<p>sprintf(pathname,&quot;%s/%s&quot;,DIRNAME,dirp-&gt;d_name);
</p>
<p>if (lstat(pathname,&amp;statbuf) == -1) /* see man stat */
</p>
<p>{
</p>
<p>perror(&quot;stat&quot;);
</p>
<p>continue;
</p>
<p>}
</p>
<p>if (S_ISREG(statbuf.st_mode))
</p>
<p>{
</p>
<p>printf(&quot;%s is a regular file\n&quot;,pathname);
</p>
<p>};
</p>
<p>if (S_ISDIR(statbuf.st_mode))
</p>
<p>{
</p>
<p>printf(&quot;%s is a directory\n&quot;,pathname);
</p>
<p>}
</p>
<p>if (S_ISLNK(statbuf.st_mode))
</p>
<p>{
</p>
<p>bzero(linkname,bufsize); /* clear string */
</p>
<p>readlink(pathname,linkname,bufsize);
</p>
<p>printf(&quot;%s is a link to %s\n&quot;,pathname,linkname);
</p>
<p>}
</p>
<p>printf(&quot;The mode of %s is %o\n\n&quot;,pathname,statbuf.st_mode &amp; 07777);
</p>
<p>}
</p>
<p>closedir(dirh);
</p>
<p>}
</p>
<p>9.10 Process control, fork(), exec(), popen() and system
</p>
<p>There is a number of ways in which processes can interact with one another and in which
</p>
<p>we can control their behaviour. We shall not go into great detail in this course, only provide
</p>
<p>examples for reference.
</p>
<p>The UNIX `fork()' function is used to create child processes. This is the basis of all
</p>
<p>`heavyweight' multitasking under unix. Here is a simple example of fork in which we start
</p>
<p>a child process from within a program and wait for it to &#12;nish. Note that the code for the</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 131
</p>
<p>parent and the child is is the same &#12;le. The only thing that distinguishes parent from child
</p>
<p>is the value returned by the fork function.
</p>
<p>When `fork()' is called, it duplicates the entire current process so that two parallel
</p>
<p>processes are then running. The only di&#11;erence between these is that the child process (the
</p>
<p>copy) gets a return value of zero from `fork()', whereas the parent gets a return value equal
</p>
<p>to the process identi&#12;er (pid) of the child. This value can be used by the parent to send
</p>
<p>messages or to wait for the child. Here we show a simple example in which the `wait(NULL)'
</p>
<p>command is used to wait for the last child spawned by the parent.
</p>
<p>/**************************************************************/
</p>
<p>/* */
</p>
<p>/* A brief demo of the UNIX process duplicator fork(). */
</p>
<p>/* */
</p>
<p>/**************************************************************/
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>/***************************************************************/
</p>
<p>main ()
</p>
<p>{ int pid, cid;
</p>
<p>pid = getpid();
</p>
<p>printf (&quot;Fork demo! I am the parent (pid = %d)\n&quot;,pid);
</p>
<p>if (! fork())
</p>
<p>{
</p>
<p>cid = getpid();
</p>
<p>printf (&quot;I am the child (cid = %d) of (pid=%d)\n&quot;,cid,pid);
</p>
<p>ChildProcess();
</p>
<p>exit(0);
</p>
<p>}
</p>
<p>printf(&quot;Parent waiting here for the child...\n&quot;);
</p>
<p>wait(NULL);
</p>
<p>printf(&quot;Child finished, parent quitting too!\n&quot;);
</p>
<p>}
</p>
<p>/**************************************************************/
</p>
<p>ChildProcess()
</p>
<p>{ int i;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>132 The unix programming environment
</p>
<p>for (i = 0; i &lt; 10; i++)
</p>
<p>{
</p>
<p>printf (&quot;%d...\n&quot;,i);
</p>
<p>sleep(1);
</p>
<p>}
</p>
<p>}
</p>
<p>Another possibility is that we might want to execute a program and wait to &#12;nd out
</p>
<p>what the result of the program is before continuing. There are two ways to do this. The
</p>
<p>&#12;rst is a variation on the theme above and uses fork().
</p>
<p>Let's create a function which runs a shell command from within a C program, and
</p>
<p>determines its return value. We make the result a boolean (integer) value, so that the
</p>
<p>function returns `true' if the shell command exits normally, See Section 6.6 [Return codes],
</p>
<p>page 66.
</p>
<p>if (ShellCommandReturnsZero(shell-command))
</p>
<p>{
</p>
<p>printf (&quot;Command %s went ok\n&quot;,shell-command);
</p>
<p>}
</p>
<p>To do this we &#12;rst have to fork a new process and then use one of the exec commands to
</p>
<p>load a new code image on top of the new process. shell commands from C This sounds
</p>
<p>complicated, but it is necessary because of the way unix handles processes. If we had no use
</p>
<p>for the return value, we could simply execute a shell command using the system(&quot;shell
</p>
<p>command&quot;) function, (which does all this for us) but when system() exits, we can only tell
</p>
<p>if the command was executed successfully or unsuccessfully|we learn nothing about what
</p>
<p>actually failed (the shell or command which was executed under the shell?) If we require
</p>
<p>detailed information about what happened to the child process then we need to do the
</p>
<p>following.
</p>
<p>#include &lt;sys/types.h&gt;
</p>
<p>#include &lt;sys/wait.h&gt;
</p>
<p>/* Send complete command as a string */
</p>
<p>/* including all arguments */
</p>
<p>ShellCommandReturnsZero(comm)
</p>
<p>char *comm;
</p>
<p>{ int status, i, argc;
</p>
<p>pid_t pid;
</p>
<p>char arg[maxshellargs][bufsize];
</p>
<p>char **argv;
</p>
<p>/* Build argument array for execv call*/
</p>
<p>for (i = 0; i &lt; maxshellargs; i++)</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 133
</p>
<p>{
</p>
<p>bzero (arg[i],bufsize);
</p>
<p>}
</p>
<p>argc = SplitCommand(comm,arg);
</p>
<p>if ((pid = fork()) &lt; 0)
</p>
<p>{
</p>
<p>FatalError(&quot;Failed to fork new process&quot;);
</p>
<p>}
</p>
<p>else if (pid == 0) /* child */
</p>
<p>{
</p>
<p>argv = malloc((argc+1)*sizeof(char *));
</p>
<p>for (i = 0; i &lt; argc; i++)
</p>
<p>{
</p>
<p>argv[i] = arg[i];
</p>
<p>}
</p>
<p>argv[i] = (char *) NULL;
</p>
<p>if (execv(arg[0],argv) == -1)
</p>
<p>{
</p>
<p>yyerror(&quot;script failed&quot;);
</p>
<p>perror(&quot;execvp&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>}
</p>
<p>else /* parent */
</p>
<p>{
</p>
<p>if (wait(&amp;status) != pid)
</p>
<p>{
</p>
<p>printf(&quot;Wait for child failed\n&quot;);
</p>
<p>perror(&quot;wait&quot;);
</p>
<p>return false;
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>if (WIFSIGNALED(status))
</p>
<p>{
</p>
<p>printf(&quot;Script %s returned: %s\n&quot;,comm,WTERMSIG(status));
</p>
<p>return false;
</p>
<p>}
</p>
<p>if (! WIFEXITED(status))
</p>
<p>{
</p>
<p>return false;
</p>
<p>}</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>134 The unix programming environment
</p>
<p>if (WEXITSTATUS(status) == 0)
</p>
<p>{
</p>
<p>return true;
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>return false;
</p>
<p>}
</p>
<p>}
</p>
<p>}
</p>
<p>}
</p>
<p>/*******************************************************************/
</p>
<p>SplitCommand(comm,arg)
</p>
<p>char *comm, arg[maxshellargs][bufsize];
</p>
<p>{ char *sp;
</p>
<p>int i = 0, j;
</p>
<p>char buff[bufsize];
</p>
<p>for (sp = comm; *sp != NULL; sp++)
</p>
<p>{
</p>
<p>bzero(buff,bufsize);
</p>
<p>if (i &gt;= maxshellargs-1)
</p>
<p>{
</p>
<p>yyerror(&quot;Too many arguments in embedded script&quot;);
</p>
<p>FatalError(&quot;Use a wrapper&quot;);
</p>
<p>}
</p>
<p>while (*sp == ' ' || *sp == '\t')
</p>
<p>{
</p>
<p>sp++;
</p>
<p>}
</p>
<p>switch (*sp)
</p>
<p>{
</p>
<p>case '\&quot;': sscanf (++sp,&quot;%[^\&quot;]&quot;,buff);
</p>
<p>break;
</p>
<p>case '\'': sscanf (++sp,&quot;%[^\']&quot;,buff);
</p>
<p>break;
</p>
<p>default: sscanf (sp,&quot;%s&quot;,buff);
</p>
<p>break;
</p>
<p>}
</p>
<p>for (j = 0; j &lt; bufsize; j++)</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 135
</p>
<p>{
</p>
<p>arg[i][j] = buff[j];
</p>
<p>}
</p>
<p>sp += strlen(arg[i]);
</p>
<p>i++;
</p>
<p>}
</p>
<p>return (i);
</p>
<p>}
</p>
<p>In this example, the script waits for the exit signal from the child process before continuing.
</p>
<p>The return value from the child is available from the wait function with the help of a set of
</p>
<p>macros de&#12;ned in `/usr/include/sys/wait.h'. The value is given by WTERMSIG(status).
</p>
<p>In the &#12;nal example, we can open a pipe to a process directly in a C program as though it
</p>
<p>were a &#12;le, by using the function popen(). Pipes may be opened for reading or for writing,
</p>
<p>in exactly the same way as a &#12;le is opened. The child process is automatically synchronized
</p>
<p>with the parent using this method. Here is a program which opens a unix command for
</p>
<p>reading (both stdout and stderr) from the child process are piped into the program. Notice
</p>
<p>that the syntax used in this call is that used by the Bourne shell, since this is build deeply
</p>
<p>into the unix execution design.
</p>
<p>#define bufsize 1024
</p>
<p>FILE *pp;
</p>
<p>char VBUFF[bufsize];
</p>
<p>...
</p>
<p>if ((pp = popen( &quot;/sbin/mount -va 2&lt;&amp;1&quot;,&quot;r&quot;)) == NULL)
</p>
<p>{
</p>
<p>printf(&quot;Failed to open pipe\n&quot;);
</p>
<p>return errorcode;
</p>
<p>}
</p>
<p>while (!feof(pp))
</p>
<p>{
</p>
<p>fgets(VBUFF,bufsize,pp);
</p>
<p>/* Just write the output to stdout */
</p>
<p>printf (&quot;Pipe read: %s\n&quot;,VBUFF);
</p>
<p>}
</p>
<p>pclose(pp);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>136 The unix programming environment
</p>
<p>9.11 A more secure popen()
</p>
<p>One problem with the popen() system call is that it uses a shell to execute the command
</p>
<p>it obtains a pipe to. In the past this has been used to allow Unix security breaches, using
</p>
<p>a so-called IFS attack which can trick the shell into executing a program with the name of
</p>
<p>the &#12;rst node in the directory of the executable. For instance,if the pipe was to open the
</p>
<p>program `/bin/ps', this coudl be tricked into executing a program in the current working
</p>
<p>directory of the process called `bin' with argument `ps'.
</p>
<p>The solution is not to use a shell at all, but to replace popen() with a version which
</p>
<p>calls exec() directly. Here is a safe version from the source code of cfengine:
</p>
<p>#define bufsize 4096
</p>
<p>#define maxshellargs 20
</p>
<p>pid_t *CHILD;
</p>
<p>int MAXFD = 20; /* Max number of simultaneous pipes */
</p>
<p>/***************************************************************/
</p>
<p>FILE *cfpopen(command, type)
</p>
<p>char *command, *type;
</p>
<p>{ char arg[maxshellargs][bufsize];
</p>
<p>int i, argc, pd[2];
</p>
<p>char **argv;
</p>
<p>pid_t pid;
</p>
<p>FILE *pp = NULL;
</p>
<p>if ((*type != 'r' &amp;&amp; *type != 'w') || (type[1] != '\0'))
</p>
<p>{
</p>
<p>errno = EINVAL;
</p>
<p>return NULL;
</p>
<p>}
</p>
<p>if (CHILD == NULL) /* first time */
</p>
<p>{
</p>
<p>if ((CHILD = calloc(MAXFD,sizeof(pid_t))) == NULL)
</p>
<p>{
</p>
<p>return NULL;
</p>
<p>}
</p>
<p>}
</p>
<p>if (pipe(pd) &lt; 0) /* Create a pair of descriptors to this process */
</p>
<p>{
</p>
<p>return NULL;
</p>
<p>}
</p>
<p>if ((pid = fork()) == -1)</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 137
</p>
<p>{
</p>
<p>return NULL;
</p>
<p>}
</p>
<p>if (pid == 0)
</p>
<p>{
</p>
<p>switch (*type)
</p>
<p>{
</p>
<p>case 'r':
</p>
<p>close(pd[0]); /* Don't need output from parent */
</p>
<p>if (pd[1] != 1)
</p>
<p>{
</p>
<p>dup2(pd[1],1); /* Attach pp=pd[1] to our stdout */
</p>
<p>dup2(pd[1],2); /* Merge stdout/stderr */
</p>
<p>close(pd[1]);
</p>
<p>}
</p>
<p>break;
</p>
<p>case 'w':
</p>
<p>close(pd[1]);
</p>
<p>if (pd[0] != 0)
</p>
<p>{
</p>
<p>dup2(pd[0],0);
</p>
<p>close(pd[0]);
</p>
<p>}
</p>
<p>}
</p>
<p>for (i = 0; i &lt; MAXFD; i++)
</p>
<p>{
</p>
<p>if (CHILD[i] &gt; 0)
</p>
<p>{
</p>
<p>close(CHILD[i]);
</p>
<p>}
</p>
<p>argc = SplitCommand(command,arg);
</p>
<p>argv = (char **) malloc((argc+1)*sizeof(char *));
</p>
<p>if (argv == NULL)
</p>
<p>{
</p>
<p>FatalError(&quot;Out of memory&quot;);
</p>
<p>}
</p>
<p>for (i = 0; i &lt; argc; i++)
</p>
<p>{</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>138 The unix programming environment
</p>
<p>argv[i] = arg[i];
</p>
<p>}
</p>
<p>argv[i] = (char *) NULL;
</p>
<p>if (execv(arg[0],argv) == -1)
</p>
<p>{
</p>
<p>sprintf(OUTPUT,&quot;Couldn't run %s&quot;,arg[0]);
</p>
<p>CfLog(cferror,OUTPUT,&quot;execv&quot;);
</p>
<p>}
</p>
<p>_exit(1);
</p>
<p>}
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>switch (*type)
</p>
<p>{
</p>
<p>case 'r':
</p>
<p>close(pd[1]);
</p>
<p>if ((pp = fdopen(pd[0],type)) == NULL)
</p>
<p>{
</p>
<p>return NULL;
</p>
<p>}
</p>
<p>break;
</p>
<p>case 'w':
</p>
<p>close(pd[0]);
</p>
<p>if ((pp = fdopen(pd[1],type)) == NULL)
</p>
<p>{
</p>
<p>return NULL;
</p>
<p>}
</p>
<p>}
</p>
<p>CHILD[fileno(pp)] = pid;
</p>
<p>return pp;
</p>
<p>}
</p>
<p>}
</p>
<p>/***************************************************************/
</p>
<p>cfpclose(pp)
</p>
<p>FILE *pp;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 139
</p>
<p>{ int fd, status;
</p>
<p>pid_t pid;
</p>
<p>Debug(&quot;cfpclose(pp)\n&quot;);
</p>
<p>if (CHILD == NULL) /* popen hasn't been called */
</p>
<p>{
</p>
<p>return -1;
</p>
<p>}
</p>
<p>fd = fileno(pp);
</p>
<p>if ((pid = CHILD[fd]) == 0)
</p>
<p>{
</p>
<p>return -1;
</p>
<p>}
</p>
<p>CHILD[fd] = 0;
</p>
<p>if (fclose(pp) == EOF)
</p>
<p>{
</p>
<p>return -1;
</p>
<p>}
</p>
<p>Debug(&quot;cfpopen - Waiting for process %d\n&quot;,pid);
</p>
<p>#ifdef HAVE_WAITPID
</p>
<p>while(waitpid(pid,&amp;status,0) &lt; 0)
</p>
<p>{
</p>
<p>if (errno != EINTR)
</p>
<p>{
</p>
<p>return -1;
</p>
<p>}
</p>
<p>}
</p>
<p>return status;
</p>
<p>#else
</p>
<p>if (wait(&amp;status) != pid)
</p>
<p>{
</p>
<p>return -1;
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>if (WIFSIGNALED(status))
</p>
<p>{</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>140 The unix programming environment
</p>
<p>return -1;
</p>
<p>}
</p>
<p>if (! WIFEXITED(status))
</p>
<p>{
</p>
<p>return -1;
</p>
<p>}
</p>
<p>return (WEXITSTATUS(status));
</p>
<p>}
</p>
<p>#endif
</p>
<p>}
</p>
<p>/*******************************************************************/
</p>
<p>/* Command exec aids */
</p>
<p>/*******************************************************************/
</p>
<p>SplitCommand(comm,arg)
</p>
<p>char *comm, arg[maxshellargs][bufsize];
</p>
<p>{ char *sp;
</p>
<p>int i = 0, j;
</p>
<p>char buff[bufsize];
</p>
<p>for (sp = comm; sp &lt; comm+strlen(comm); sp++)
</p>
<p>{
</p>
<p>bzero(buff,bufsize);
</p>
<p>if (i &gt;= maxshellargs-1)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;Too many arguments in embedded script&quot;,&quot;&quot;);
</p>
<p>FatalError(&quot;Use a wrapper&quot;);
</p>
<p>}
</p>
<p>while (*sp == ' ' || *sp == '\t')
</p>
<p>{
</p>
<p>sp++;
</p>
<p>}
</p>
<p>switch (*sp)
</p>
<p>{
</p>
<p>case '\0': return(i-1);
</p>
<p>case '\&quot;': sscanf (++sp,&quot;%[^\&quot;]&quot;,arg[i]);
</p>
<p>break;
</p>
<p>case '\'': sscanf (++sp,&quot;%[^\']&quot;,arg[i]);
</p>
<p>break;
</p>
<p>case '`': sscanf (++sp,&quot;%[^`]&quot;,arg[i]);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 141
</p>
<p>break;
</p>
<p>default: sscanf (sp,&quot;%s&quot;,arg[i]);
</p>
<p>break;
</p>
<p>}
</p>
<p>sp += strlen(arg[i]);
</p>
<p>i++;
</p>
<p>}
</p>
<p>return (i);
</p>
<p>}
</p>
<p>9.12 Traps and signals
</p>
<p>Processes can receive signals from the UNIX kernel at any time. Some of these signals
</p>
<p>terminate the execution of the program. This can cause problems if the program is in the
</p>
<p>middle of critical activity such as writing to a &#12;le. For that reason we can trap signals and
</p>
<p>provide our own routine for handling them in a special way.
</p>
<p>A signal handler is made by calling the function `signal()' for each signal and by
</p>
<p>specifying a pointer to a function which will be called in the event of a signal. For example:
</p>
<p>main ()
</p>
<p>{ int HandleSignal();
</p>
<p>signal(SIGTERM,HandleSignal);
</p>
<p>}
</p>
<p>HandleSignal()
</p>
<p>{
</p>
<p>/* Tidy up and exit cleanly */
</p>
<p>exit(0);
</p>
<p>}
</p>
<p>`SIGTERM' is the usual signal sent by the command `kill'. There are many other signals
</p>
<p>which can be sent to programs. Here is list. You have to decide for yourself whether or not
</p>
<p>you want to provide your own signal handling function. To ignore a signal, you write
</p>
<p>signal(SIGtype,SIG_IGN);
</p>
<p>To remove a signal handler and re-activate a signal, you write
</p>
<p>signal(SIGtype,SIG_DFL);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>142 The unix programming environment
</p>
<p>9.13 Regular expressions
</p>
<p>A regular expression is a pattern for matching strings of text. We have met regular
</p>
<p>expressions earlier in connection with the shell and Perl. Naturally these earlier encounters
</p>
<p>have their roots in C functions for handling expressions. A regular expression is used by
</p>
<p>&#12;rst `compiling' it into a convenient data structure. Then a matching function is used to
</p>
<p>compare the expression with a test string. In this example program we show how a regular
</p>
<p>expression typed in as an argument to the program is found within strings of input entered
</p>
<p>on the keyboard.
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>#include &lt;regex.h&gt;
</p>
<p>main (argc,argv)
</p>
<p>int argc;
</p>
<p>char **argv;
</p>
<p>{
</p>
<p>char buffer[1024];
</p>
<p>regex_t rx;
</p>
<p>regmatch_t match;
</p>
<p>size_t nmatch = 1;
</p>
<p>if (regcomp(&amp;rx, argv[1], REG_EXTENDED) != 0)
</p>
<p>{
</p>
<p>perror(&quot;regcomp&quot;);
</p>
<p>return;
</p>
<p>}
</p>
<p>while (!feof(stdin))
</p>
<p>{
</p>
<p>fgets(buffer,1024,stdin);
</p>
<p>if (regexec(&amp;rx,buffer,1,&amp;match,0) == 0)
</p>
<p>{
</p>
<p>printf(&quot;Matched:(%s) at %d to %d&quot;,buffer,match.rm_so,match.rm_eo);
</p>
<p>}
</p>
<p>}
</p>
<p>regfree(&amp;rx);
</p>
<p>}
</p>
<p>Here is an example of its use. The output of the program is in italics
</p>
<p>% a.out xyz
</p>
<p>this is a string</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 143
</p>
<p>another string
</p>
<p>an xyz string
</p>
<p>Matched: (an xyz string
</p>
<p>) at 3 to 6
</p>
<p>another xyz zyxxyz string
</p>
<p>Matched: (another xyz xyz string
</p>
<p>) at 8 to 11
</p>
<p>% a.out 'xyz|abc'
</p>
<p>This is a string
</p>
<p>An abc string
</p>
<p>Matched: (An abc string
</p>
<p>) at 3 to 6
</p>
<p>Or an xyz string
</p>
<p>Matched: (Or an xyz string
</p>
<p>) at 6 to 9
</p>
<p>If you don't want the match data set &amp;pm to NULL. To get an exact match rather than a
</p>
<p>substring check that the bounds are 0 and strlen(argv[1])-1.
</p>
<p>9.14 DES encryption
</p>
<p>Encryption with the SSLeay library, compile with command
</p>
<p>gcc crypto.c -I/usr/local/ssl/include -L/usr/local/ssl/lib -lcrypto
</p>
<p>Example of normal triple DES encryption which works only on an 8-byte bu&#11;er:
</p>
<p>/*****************************************************************************/
</p>
<p>/* */
</p>
<p>/* File: crypto.c */
</p>
<p>/* */
</p>
<p>/* Compile with: gcc program.c -lcrypto (SSLeay) */
</p>
<p>/* */
</p>
<p>/*****************************************************************************/
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>#include &lt;des.h&gt;
</p>
<p>#define bufsize 1024
</p>
<p>/* Note how this truncates to 8 characters */
</p>
<p>main ()
</p>
<p>{ char in[bufsize],out[bufsize],back[bufsize];
</p>
<p>des_cblock key1,key2,key3,seed = {0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10};
</p>
<p>des_key_schedule ks1,ks2,ks3;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>144 The unix programming environment
</p>
<p>strcpy(in,&quot;1 2 3 4 5 6 7 8 9 a b c d e f g h i j k&quot;);
</p>
<p>des_random_seed(seed);
</p>
<p>des_random_key(key1);
</p>
<p>des_random_key(key2);
</p>
<p>des_random_key(key3);
</p>
<p>des_set_key((C_Block *)key1,ks1);
</p>
<p>des_set_key((C_Block *)key2,ks2);
</p>
<p>des_set_key((C_Block *)key3,ks3);
</p>
<p>des_ecb3_encrypt((C_Block *)in,(C_Block *)out,ks1,ks2,ks3,DES_ENCRYPT);
</p>
<p>printf(&quot;Encrypted [%s] into [%s]\n&quot;,in,out);
</p>
<p>des_ecb3_encrypt((C_Block *)out,(C_Block *)back,ks1,ks2,ks3,DES_DECRYPT);
</p>
<p>printf(&quot;and back to.. [%s]\n&quot;,back);
</p>
<p>}
</p>
<p>Triple DES, chaining mode, for longer strings (which must be a multiple of 8 bytes):
</p>
<p>/*****************************************************************************/
</p>
<p>/* */
</p>
<p>/* File: crypto.c */
</p>
<p>/* */
</p>
<p>/* Compile with: gcc program.c -lcrypto (SSLeay) */
</p>
<p>/* */
</p>
<p>/*****************************************************************************/
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>#include &lt;des.h&gt;
</p>
<p>#define bufsize 1024
</p>
<p>/* This can be used on arbitrary length buffers */
</p>
<p>main ()
</p>
<p>{ char in[bufsize],out[bufsize],back[bufsize],workvec[bufsize];
</p>
<p>des_cblock key1,key2,key3,seed = {0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10};
</p>
<p>des_key_schedule ks1,ks2,ks3;
</p>
<p>strcpy(in,&quot;1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z&quot;);
</p>
<p>des_random_seed(seed);
</p>
<p>des_random_key(key1);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 145
</p>
<p>des_random_key(key2);
</p>
<p>des_random_key(key3);
</p>
<p>des_set_key((C_Block *)key1,ks1);
</p>
<p>des_set_key((C_Block *)key2,ks2);
</p>
<p>des_set_key((C_Block *)key3,ks3);
</p>
<p>/* This work vector can be intialized t anything ...*/
</p>
<p>memset(workvec,0,bufsize);
</p>
<p>des_ede3_cbc_encrypt((C_Block *)in,(C_Block *)out,(long)strlen(in),
</p>
<p>ks1,ks2,ks3,(C_Block *)workvec,DES_ENCRYPT);
</p>
<p>printf(&quot;Encypted [%s] into [something]\n&quot;,in);
</p>
<p>/* .. but this must be initialized the same as above */
</p>
<p>memset(workvec,0,bufsize);
</p>
<p>/* Note that the length is the original length, not strlen(out) */
</p>
<p>des_ede3_cbc_encrypt((C_Block *)out,(C_Block *)back,(long)strlen(in),
</p>
<p>ks1,ks2,ks3,(C_Block *)workvec,DES_DECRYPT);
</p>
<p>printf(&quot;and back to.. [%s]\n&quot;,back);
</p>
<p>}
</p>
<p>9.15 Device control: ioctl
</p>
<p>The C function `ioctl' (I/O control) is used to send special control commands to devices
</p>
<p>like the disk and the network interface. The syntax of the function is
</p>
<p>int ioctl(fd, request, arg)
</p>
<p>int fd, request;
</p>
<p>long arg;
</p>
<p>The &#12;rst parameter is normally as device handle or socket descriptor. The second is a
</p>
<p>control parameter. Lists of valid control parameters are normally de&#12;ned in the system
</p>
<p>`include' &#12;les for a particular device. They are device and system dependent so you need a
</p>
<p>local manual and som detective work to &#12;nd out what they are. The &#12;nal parameter is a
</p>
<p>pointer to a variable which receives return data from the device.
</p>
<p>`ioctl' commands are device speci&#12;c, by their nature. The commands for the ethernet
</p>
<p>interface device are only partially standardized, for example. We could read the ethernet
</p>
<p>device (which is called `le0' on a Sun workstation), using the following command:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>146 The unix programming environment
</p>
<p># include &lt;sys/socket.h&gt; /* Typical includes for internet */
</p>
<p># include &lt;sys/ioctl.h&gt;
</p>
<p># include &lt;net/if.h&gt;
</p>
<p># include &lt;netinet/in.h&gt;
</p>
<p># include &lt;arpa/inet.h&gt;
</p>
<p># include &lt;netdb.h&gt;
</p>
<p># include &lt;sys/protosw.h&gt;
</p>
<p># include &lt;net/route.h&gt;
</p>
<p>struct ifreq IFR;
</p>
<p>int sk;
</p>
<p>struct sockaddr_in sin;
</p>
<p>strcpy(IFR.ifr_name,&quot;le0&quot;);
</p>
<p>IFR.ifr_addr.sa_family = AF_INET;
</p>
<p>if ((sk = socket(AF_INET,SOCK_DGRAM,IPPROTO_IP)) == -1)
</p>
<p>{
</p>
<p>perror(&quot;socket&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>if (ioctl(sk,SIOCGIFFLAGS, (caddr_t) &amp;IFR) == -1)
</p>
<p>{
</p>
<p>perror (&quot;ioctl&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>We shall not go into the further details of `ioctl', but simply note its role in system
</p>
<p>programming.
</p>
<p>9.16 Database example (Berkeley db)
</p>
<p>DBT key,value;
</p>
<p>DB *dbp;
</p>
<p>DBC *dbcp;
</p>
<p>db_recno_t recno;
</p>
<p>if ((errno = db_open(CHECKSUMDB,DB_BTREE, DB_CREATE, 0664, NULL, NULL, &amp;dbp)) != 0)
</p>
<p>{
</p>
<p>sprintf(OUTPUT,&quot;cfd: couldn't open checksum database %s\n&quot;,CHECKSUMDB);
</p>
<p>CfLog(cferror,OUTPUT,&quot;db_open&quot;);
</p>
<p>return false;
</p>
<p>}
</p>
<p>bzero(&amp;value,sizeof(value));
</p>
<p>bzero(&amp;key,sizeof(key));</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 147
</p>
<p>key.data = filename;
</p>
<p>key.size = strlen(filename)+1;
</p>
<p>value.data = dbvalue;
</p>
<p>value.size = sizeof(dbvalue);
</p>
<p>if ((errno = dbp-&gt;del(dbp,NULL,&amp;key,0)) != 0)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;&quot;,&quot;db_store&quot;);
</p>
<p>}
</p>
<p>key.data = filename;
</p>
<p>key.size = strlen(filename)+1;
</p>
<p>if ((errno = dbp-&gt;put(dbp,NULL,&amp;key,&amp;value,0)) != 0)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;put failed&quot;,&quot;db-&gt;put&quot;);
</p>
<p>}
</p>
<p>if ((errno = dbp-&gt;get(dbp,NULL,&amp;key,&amp;value,0)) == 0)
</p>
<p>{
</p>
<p>/* Not found ... */
</p>
<p>return;
</p>
<p>}
</p>
<p>dbp-&gt;close(dbp,0);
</p>
<p>9.17 Text parsing tools: `lex' and `yacc'
</p>
<p>This section is a taster only. You only need to know what lex and yacc are, not how they
</p>
<p>work.
</p>
<p>`lex' and `yacc' are two tools for the C programmer who wishes to make a text parser.
</p>
<p>A text parser is a program which reads a text &#12;le and interprets the symbols in it. Every
</p>
<p>programming language must include a text parser, for instance.
</p>
<p>The `yacc' (yet another compiler compiler) program generates C code which parses a
</p>
<p>text&#12;le, given a description of the syntax rules for the &#12;le. In other words, we de&#12;ne the
</p>
<p>logical structure of the text &#12;le, according to the way we wish to interpret it and give the
</p>
<p>rules to `yacc'. `yacc' produces C code from this which does the job.
</p>
<p>`lex' is a `lexer'. It is normally used together with `yacc'. `lex' tokenizes or identi&#12;es
</p>
<p>symbols in a &#12;le. What that means is that it reads in a &#12;le and matches types of string in
</p>
<p>the &#12;le which are de&#12;ned in terms of regular expressions by the programmer, and returns
</p>
<p>symbolic values for those strings.
</p>
<p>Although `lex' can be used by independently of `yacc', it is normally used to identify
</p>
<p>the di&#11;erent types of string which de&#12;ne the syntax of a &#12;le. For example, suppose `yacc'
</p>
<p>was parsing a C program. On the beginning of a line, it might expect to &#12;nd either a
</p>
<p>variable name or a preprocessor symbol. A variable name is just a string consisting of
</p>
<p>characters from the set `0-9a-Z_', whereas a preprocessor command always starts with the</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>148 The unix programming environment
</p>
<p>character `#'. `yacc' passes control to `lex' which reads the &#12;le and matches the &#12;rst object
</p>
<p>on the line. If it &#12;nds a variable, it returns to `yacc' a token which is a number or value
</p>
<p>corresponding to `variable'. Similarly, if it &#12;nds a preprocessor command, it returns a token
</p>
<p>for that. If it doesn't match either type it returns something else and `yacc' signals a syntax
</p>
<p>error.
</p>
<p>Here is a `yacc' &#12;le which parses a &#12;le consisting of lines of the form a+b, where $a$
</p>
<p>and $b$ are numbers { any other syntax is incorrect. We could have used this later in the
</p>
<p>example program for the client-server example, See Section 10.1 [Sockets], page 151.
</p>
<p>You can learn more about lex and yacc in &quot;Lex and Yacc&quot;, J. Levine, T. Mason and D.
</p>
<p>Brown, O'Reilly and Assoc.
</p>
<p>%{
</p>
<p>/*******************************************************************/
</p>
<p>/* */
</p>
<p>/* PARSER for a + b protocol */
</p>
<p>/* */
</p>
<p>/* The section between the single %'s gets copied verbatim into */
</p>
<p>/* the resulting C code yacc generates -- including this comment! */
</p>
<p>/* */
</p>
<p>/*******************************************************************/
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>extern char *yytext;
</p>
<p>%}
</p>
<p>%token NUMBER PLUS
</p>
<p>%%
</p>
<p>specification: { yyerror(&quot;Warning: invalid statement&quot;);}
</p>
<p>| statement;
</p>
<p>statement: NUMBER PLUS NUMBER;
</p>
<p>The lexer to go with this parser generates the tokens NUMBER and PLUS used by `yacc':
</p>
<p>%{
</p>
<p>/*******************************************************************/
</p>
<p>/* */
</p>
<p>/* LEXER for a + b protocol */
</p>
<p>/* */
</p>
<p>/* Returns token types NUMBER and PLUS to yacc, one at a time */
</p>
<p>/* */
</p>
<p>/*******************************************************************/
</p>
<p>#include &quot;y.tab.h&quot; /* yacc produces this -- need this line! */</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 9: C programming 149
</p>
<p>%}
</p>
<p>number [0-9]+
</p>
<p>plus [+]
</p>
<p>%%
</p>
<p>number {
</p>
<p>return NUMBER;
</p>
<p>}
</p>
<p>plus {
</p>
<p>return PLUS;
</p>
<p>}
</p>
<p>. {
</p>
<p>return yytext[0];
</p>
<p>}
</p>
<p>%%
</p>
<p>/* EOF */
</p>
<p>The main program which uses `yacc' and `lex' looks like this:
</p>
<p>extern FILE *yyin;
</p>
<p>main ()
</p>
<p>{
</p>
<p>if ((yyin = fopen(&quot;My_Input_File&quot;,&quot;r&quot;)) == NULL) /* Open file */
</p>
<p>{
</p>
<p>printf(&quot;Can't open file\n&quot;);
</p>
<p>exit (1);
</p>
<p>}
</p>
<p>while (!feof(yyin))
</p>
<p>{
</p>
<p>yyparse();
</p>
<p>}
</p>
<p>fclose (yyin);
</p>
<p>}</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>150 The unix programming environment
</p>
<p>9.18 Exercises
</p>
<p>1. Write a daemon program with a signal handler which makes a log of the heaviest
</p>
<p>(maximum cpu) process running, every &#12;ve minutes. The program should exit if the
</p>
<p>log &#12;le becomes greater than 5-kbytes.
</p>
<p>2. Rewrite in C the perl program which lists all the &#12;les in the current directory containing
</p>
<p>a certain string.
</p>
<p>3. Write a version of `more' which prints control characters safely. See the `cat -e' com-
</p>
<p>mand.
</p>
<p>4. Write a Make&#12;le to create a shared library from a number of object &#12;les.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 10: Network Programming 151
</p>
<p>10 Network Programming
</p>
<p>Client-server communication is the basis of modern operating system technology. The
</p>
<p>Unix socket mechanism makes stream-based communication virtually transparent.
</p>
<p>10.1 Socket streams
</p>
<p>Analogous to &#12;lestreams are sockets or TCP/IP network connections. A socket is a two-
</p>
<p>way (read/write) pseudo-&#12;le node. An open socket stream is like an open &#12;le-descriptor.
</p>
<p>Berkeley sockets are part of the standard C library.
</p>
<p>There are two main kinds of socket: TCP/IP sockets and Unix domain sockets. Unix
</p>
<p>sockets can be used to provide local interprocess communication using a &#12;lestream com-
</p>
<p>munication protocol. TCP/IP sockets open &#12;le descriptors across the network. A TCP/IP
</p>
<p>socket is a &#12;le stream associated with an IP address and a port number. We write to a
</p>
<p>socket descriptor just as with a &#12;le descriptor, either with write() or using send().
</p>
<p>When sending binary data over a network we have to be careful about machine level
</p>
<p>representations of data. Operating systems (actually the hardware they run on) fall into
</p>
<p>two categories known as big endian and little endian. The names refer to the byte-order
</p>
<p>of numerical representations. The names indicate how large integers (which require say
</p>
<p>32 bits or more) are stored in memory. Little endian systems store the least signi&#12;cant
</p>
<p>byte &#12;rst, while big endian systems store the most signi&#12;cant byte &#12;rst. For example, the
</p>
<p>representation of the number 34,677,374 has either of these forms.
</p>
<p>-----------------------------------
</p>
<p>Big | 2 | 17 | 34 | 126 |
</p>
<p>-----------------------------------
</p>
<p>-----------------------------------
</p>
<p>Little | 126 | 34 | 17 | 2 |
</p>
<p>-----------------------------------
</p>
<p>Obviously if we are transferring data from one host to another, both hosts have to
</p>
<p>agree on the data representation otherwise there would be disastrous consequences. This
</p>
<p>means that there has to be a common standard of network byte ordering. For example,
</p>
<p>Solaris (SPARC hardware) uses network byte ordering (big endian), while GNU/Linux
</p>
<p>(Intel hardware) uses the opposite (little endian). This means that Intel systems have to
</p>
<p>convert the format every time something is transmitted over the network. Unix systems
</p>
<p>provide generic functions for converting between host-byteorder and network-byteorder for
</p>
<p>small and long integer data:
</p>
<p>htonl, htons, ntohl, ntohs
</p>
<p>Here we list two example programs which show how to make a client-server pair. The server
</p>
<p>enters a loop, and listens for connections from any clients (the generic address `INADDR_ANY'
</p>
<p>is a wildcard for any address on the current local network segment). The client program
</p>
<p>sends requests to the server as a protocol in the form of a string of the type `a + b'. Normally</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>152 The unix programming environment
</p>
<p>`a' and `b' are numbers, in which case the server returns their sum to the client. If the
</p>
<p>message has the special form `halt + *', where the star is arbitrary, then the server shuts
</p>
<p>down. Any other form of message results in an error, which the server signals to the client.
</p>
<p>The basic structure of the client-server components in terms of system calls is this:
</p>
<p>Client:
</p>
<p>socket() Create a socket
</p>
<p>connect() Contact a server socket (IP + port)
</p>
<p>while (?)
</p>
<p>{
</p>
<p>send() Send to server
</p>
<p>recv() Receive from server
</p>
<p>}
</p>
<p>Server:
</p>
<p>socket() Create a socket
</p>
<p>bind() Associates the socket with a &#12;xed address
</p>
<p>listen() Create a listen queue
</p>
<p>while()
</p>
<p>{
</p>
<p>reply=accept() Accept a connection request
</p>
<p>recv() Receive from client
</p>
<p>send() Send to client
</p>
<p>}
</p>
<p>/**********************************************************************/
</p>
<p>/* */
</p>
<p>/* The client part of a client-server pair. This simply takes two */
</p>
<p>/* numbers and adds them together, returning the result to the client */
</p>
<p>/* */
</p>
<p>/* Compiled with: */
</p>
<p>/* cc server.c */
</p>
<p>/* */
</p>
<p>/* User types: */
</p>
<p>/* 3 + 5 */
</p>
<p>/* a + b */
</p>
<p>/* halt + server */
</p>
<p>/**********************************************************************/
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>#include &lt;sys/types.h&gt;
</p>
<p>#include &lt;sys/socket.h&gt;
</p>
<p>#include &lt;netinet/in.h&gt;
</p>
<p>#include &lt;netdb.h&gt;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 10: Network Programming 153
</p>
<p>#define PORT 9000 /* Arbitrary non-reserved port */
</p>
<p>#define HOST &quot;nexus.iu.hioslo.no&quot;
</p>
<p>#define bufsize 20
</p>
<p>/**********************************************************************/
</p>
<p>/* Main */
</p>
<p>/**********************************************************************/
</p>
<p>main (argc,argv)
</p>
<p>int argc;
</p>
<p>char *argv[];
</p>
<p>{ struct sockaddr_in cin;
</p>
<p>struct hostent *hp;
</p>
<p>char buffer[bufsize];
</p>
<p>int sd;
</p>
<p>if (argc != 4)
</p>
<p>{
</p>
<p>printf(&quot;syntax: client a + b\n&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>if ((hp = gethostbyname(HOST)) == NULL)
</p>
<p>{
</p>
<p>perror(&quot;gethostbyname: &quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>memset(&amp;cin,0,sizeof(cin)); /* Another way to zero memory */
</p>
<p>cin.sin_family = AF_INET;
</p>
<p>cin.sin_addr.s_addr = ((struct in_addr *)(hp-&gt;h_addr))-&gt;s_addr;
</p>
<p>cin.sin_port = htons(PORT);
</p>
<p>printf(&quot;Trying to connect to %s = %s\n&quot;,HOST,inet_ntoa(cin.sin_addr));
</p>
<p>if ((sd = socket(AF_INET,SOCK_STREAM,0)) == -1)
</p>
<p>{
</p>
<p>perror(&quot;socket&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>if (connect(sd,&amp;cin,sizeof(cin)) == -1)
</p>
<p>{
</p>
<p>perror(&quot;connect&quot;);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>154 The unix programming environment
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>sprintf(buffer,&quot;%s + %s&quot;,argv[1],argv[3]);
</p>
<p>if (send(sd,buffer,strlen(buffer),0) == -1)
</p>
<p>{
</p>
<p>perror (&quot;send&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>if (recv(sd,buffer,bufsize,0) == -1)
</p>
<p>{
</p>
<p>perror(&quot;recv&quot;);
</p>
<p>exit (1);
</p>
<p>}
</p>
<p>printf (&quot;Server responded with %s\n&quot;,buffer);
</p>
<p>close (sd);
</p>
<p>unlink(&quot;./socket&quot;);
</p>
<p>}
</p>
<p>/**********************************************************************/
</p>
<p>/* */
</p>
<p>/* The server part of a client-server pair. This simply takes two */
</p>
<p>/* numbers and adds them together, returning the result to the client */
</p>
<p>/* */
</p>
<p>/* Compiled with: */
</p>
<p>/* cc server.c */
</p>
<p>/* */
</p>
<p>/**********************************************************************/
</p>
<p>#include &lt;stdio.h&gt;
</p>
<p>#include &lt;sys/types.h&gt;
</p>
<p>#include &lt;sys/socket.h&gt;
</p>
<p>#include &lt;netinet/in.h&gt;
</p>
<p>#include &lt;netdb.h&gt;
</p>
<p>#define PORT 9000
</p>
<p>#define bufsize 20
</p>
<p>#define queuesize 5
</p>
<p>#define true 1
</p>
<p>#define false 0
</p>
<p>/**********************************************************************/
</p>
<p>/* Main */
</p>
<p>/**********************************************************************/</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 10: Network Programming 155
</p>
<p>main ()
</p>
<p>{ struct sockaddr_in cin;
</p>
<p>struct sockaddr_in sin;
</p>
<p>struct hostent *hp;
</p>
<p>char buffer[bufsize];
</p>
<p>int sd, sd_client, addrlen;
</p>
<p>memset(&amp;sin,0,sizeof(sin)); /* Another way to zero memory */
</p>
<p>sin.sin_family = AF_INET;
</p>
<p>sin.sin_addr.s_addr = INADDR_ANY; /* Broadcast address */
</p>
<p>sin.sin_port = htons(PORT);
</p>
<p>if ((sd = socket(AF_INET,SOCK_STREAM,0)) == -1)
</p>
<p>{
</p>
<p>perror(&quot;socket&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>if (bind(sd,&amp;sin,sizeof(sin)) == -1) /* Must have this on server */
</p>
<p>{
</p>
<p>perror(&quot;bind&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>if (listen(sd,queuesize) == -1)
</p>
<p>{
</p>
<p>perror(&quot;listen&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>while (true)
</p>
<p>{
</p>
<p>if ((sd_client = accept(sd,&amp;cin,&amp;addrlen)) == -1)
</p>
<p>{
</p>
<p>perror(&quot;accept&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>if (recv(sd_client,buffer,sizeof(buffer),0) == -1)
</p>
<p>{
</p>
<p>perror(&quot;recv&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>if (!DoService(buffer))</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>156 The unix programming environment
</p>
<p>{
</p>
<p>break;
</p>
<p>}
</p>
<p>if (send(sd_client,buffer,strlen(buffer),0) == -1)
</p>
<p>{
</p>
<p>perror(&quot;send&quot;);
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>close (sd_client);
</p>
<p>}
</p>
<p>close (sd);
</p>
<p>printf(&quot;Server closing down...\n&quot;);
</p>
<p>}
</p>
<p>/**************************************************************/
</p>
<p>DoService(buffer)
</p>
<p>char *buffer;
</p>
<p>/* This is the protocol section. Here we must */
</p>
<p>/* check that the incoming data are sensible */
</p>
<p>{ int a=0,b=0;
</p>
<p>printf(&quot;Received: %s\n&quot;,buffer);
</p>
<p>sscanf(buffer,&quot;%d + %d\n&quot;,&amp;a,&amp;b);
</p>
<p>if (a &gt; 0 &amp;&amp; b&gt; 0)
</p>
<p>{
</p>
<p>sprintf(buffer,&quot;%d + %d = %d&quot;,a,b,a+b);
</p>
<p>return true;
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>if (strncmp(&quot;halt&quot;,buffer,4) == 0)
</p>
<p>{
</p>
<p>sprintf(buffer,&quot;Server closing down!&quot;);
</p>
<p>return false;
</p>
<p>}
</p>
<p>else
</p>
<p>{
</p>
<p>sprintf(buffer,&quot;Invalid protocol&quot;);
</p>
<p>return true;
</p>
<p>}</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 10: Network Programming 157
</p>
<p>}
</p>
<p>}
</p>
<p>In the example we use `streams' to implement a typical input/output behaviour for C.
</p>
<p>A stream interface is a so-called reliable protocol. There are other kinds of sockets too,
</p>
<p>called unrealiable, or UDP sockets. Features to notice on the server are that we must
</p>
<p>bind to a speci&#12;c address. The client is always implicitly bound to an address since a socket
</p>
<p>connection always originates from the machine on which the client is running. On the server
</p>
<p>however we want to know which addresses we shall be receiving requests from. In the above
</p>
<p>example we use the generic wildcard address `INADDR_ANY' which means that any host can
</p>
<p>connect to the server. Had we been more speci&#12;c, we could have limited communication to
</p>
<p>two machines only.
</p>
<p>By calling `listen()' we set up a queue for incoming connections. Rather than forking
</p>
<p>a separate process to handle each request we set up a queue of a certain depth. If we exceed
</p>
<p>this depth then new clients rtying to connect will be refused connection.
</p>
<p>The `accept' call is the mechanism which extracts a `reply handle' from the socket.
</p>
<p>Using the handle obtained from this call we can reply to the client without having to open
</p>
<p>a special socket explicitly.
</p>
<p>An improved server side connection can be setup, reading the service name from
</p>
<p>`/etc/services' and setting reusable socket options to avoid busy signals, like this:
</p>
<p>struct sockaddr_in cin, sin;
</p>
<p>struct servent *server;
</p>
<p>int sd, addrlen = sizeof(cin);
</p>
<p>int portnumber, yes=1;
</p>
<p>if ((server = getservbyname(service-name,&quot;tcp&quot;)) == NULL)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;Couldn't get cfengine service&quot;,&quot;getservbyname&quot;);
</p>
<p>exit (1);
</p>
<p>}
</p>
<p>bzero(&amp;cin,sizeof(cin));
</p>
<p>/* Service returns network byte order */
</p>
<p>sin.sin_port = (unsigned short)(server-&gt;s_port);
</p>
<p>sin.sin_addr.s_addr = INADDR_ANY;
</p>
<p>sin.sin_family = AF_INET;
</p>
<p>if ((sd = socket(AF_INET,SOCK_STREAM,0)) == -1)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;Couldn't open socket&quot;,&quot;socket&quot;);
</p>
<p>exit (1);
</p>
<p>}
</p>
<p>if (setsockopt (sd, SOL_SOCKET, SO_REUSEADDR,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>158 The unix programming environment
</p>
<p>(char *) &amp;yes, sizeof (int)) == -1)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;Couldn't set socket options&quot;,&quot;sockopt&quot;);
</p>
<p>exit (1);
</p>
<p>}
</p>
<p>if (bind(sd,(struct sockaddr *)&amp;sin,sizeof(sin)) == -1)
</p>
<p>{
</p>
<p>}
</p>
<p>/* etc */
</p>
<p>10.2 Multithreading a server
</p>
<p>All the arguments must be collected into a struct, since only one argument pointer can
</p>
<p>be sent to the pthread functions.
</p>
<p>#include &lt;pthread.h&gt;
</p>
<p>SpawnCfGetFile(args)
</p>
<p>struct cfd_thread_arg *args;
</p>
<p>{ pthread_t tid;
</p>
<p>void *CfGetFile();
</p>
<p>pthread_attr_init(&amp;PTHREADDEFAULTS);
</p>
<p>pthread_attr_setdetachstate(&amp;PTHREADDEFAULTS,PTHREAD_CREATE_DETACHED);
</p>
<p>if (pthread_create(&amp;tid,&amp;PTHREADDEFAULTS,CfGetFile,args) != 0)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;pthread_create failed&quot;,&quot;create&quot;);
</p>
<p>CfGetFile(args);
</p>
<p>}
</p>
<p>pthread_attr_destroy(&amp;PTHREADDEFAULTS);
</p>
<p>}
</p>
<p>/***************************************************************/
</p>
<p>void *CfGetFile(args)
</p>
<p>struct cfd_thread_arg *args;
</p>
<p>{ pthread_mutex_t mutex;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 10: Network Programming 159
</p>
<p>if (pthread_mutex_lock(&amp;mutex) != 0)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;pthread_mutex_lock failed&quot;,&quot;pthread_mutex_lock&quot;);
</p>
<p>free(args-&gt;replyfile); /* from strdup in each thread */
</p>
<p>DeleteConn(args-&gt;connect);
</p>
<p>free((char *)args);
</p>
<p>return NULL;
</p>
<p>}
</p>
<p>ACTIVE_THREADS++; /* Global variable */
</p>
<p>if (pthread_mutex_unlock(&amp;mutex) != 0)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;pthread_mutex_unlock failed&quot;,&quot;unlock&quot;);
</p>
<p>}
</p>
<p>/* send data */
</p>
<p>if (pthread_mutex_lock(&amp;mutex) != 0)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;pthread_mutex_lock failed&quot;,&quot;pthread_mutex_lock&quot;);
</p>
<p>return;
</p>
<p>}
</p>
<p>ACTIVE_THREADS--;
</p>
<p>if (pthread_mutex_unlock(&amp;mutex) != 0)
</p>
<p>{
</p>
<p>CfLog(cferror,&quot;pthread_mutex_unlock failed&quot;,&quot;unlock&quot;);
</p>
<p>}
</p>
<p>#endif
</p>
<p>return NULL;
</p>
<p>}
</p>
<p>10.3 System databases
</p>
<p>The C library calls which query the databases are, amongst others,
</p>
<p>getpwnam get password data by name
</p>
<p>getpwuid get password data by uid
</p>
<p>getgrnam get group data by name
</p>
<p>gethostent get entry in hosts database
</p>
<p>getnetgrent get entry in netgroups database
</p>
<p>getservbyname get servive by name
</p>
<p>getservbyport get service by port</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>160 The unix programming environment
</p>
<p>get protobyname get protocol by name
</p>
<p>For a complete list and how to use these, see the UNIX manual.
</p>
<p>The following example shows how to read the password &#12;le of the system. The functions
</p>
<p>used here can be used regardless of whether the network information service (NIS) is in use.
</p>
<p>The data are returned in a structure which is de&#12;ned in `/usr/include/pwd.h'.
</p>
<p>/******************************************************************/
</p>
<p>/* */
</p>
<p>/* Read the passwd file by name and sequentially */
</p>
<p>/* */
</p>
<p>/******************************************************************/
</p>
<p>#include &lt;unistd.h&gt;
</p>
<p>#include &lt;pwd.h&gt;
</p>
<p>main ()
</p>
<p>{ uid_t uid;
</p>
<p>struct passwd *pw;
</p>
<p>uid = getuid();
</p>
<p>pw = getpwuid(uid);
</p>
<p>printf (&quot;Your login name is %s\n&quot;,pw-&gt;pw_name);
</p>
<p>printf (&quot;Now here comes the whole file!\n\n&quot;);
</p>
<p>setpwent();
</p>
<p>while (getpwent())
</p>
<p>{
</p>
<p>printf (&quot;%s:%s:%s\n&quot;,pw-&gt;pw_name,pw-&gt;pw_gecos,pw-&gt;pw_dir);
</p>
<p>}
</p>
<p>endpwent();
</p>
<p>}
</p>
<p>10.4 DNS - The Domain Name Service
</p>
<p>The second network database service is that which converts host and domain names into
</p>
<p>IP numbers and vice versa. This is the domain name service, usually implemented by the
</p>
<p>BIND (Berkeley Internet Name Domain) software. The information here concerns version
</p>
<p>4.9 of this software.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Chapter 10: Network Programming 161
</p>
<p>10.4.1 gethostbyname()
</p>
<p>This is perhaps the most important function form hostname lookup. `gethostbyname()'
</p>
<p>gets its information either from &#12;les, NIS or DNS. Its behaviour is con&#12;gured by the &#12;les
</p>
<p>mentioned above, See Section 10.4 [DNS], page 160. It is used to look up the IP address of a
</p>
<p>named host (including domain name if DNS is used). On the con&#12;gurable systems described
</p>
<p>above, the full list of servers is queried until a reply is obtained. The order in which the
</p>
<p>di&#11;erent services are queried is important here since DNS returns a fully quali&#12;ed name
</p>
<p>(host name plus domain name) whereas NIS and the `/etc/hosts' &#12;le database return only
</p>
<p>a hostname.
</p>
<p>gethostbyname returns data in the form of a pointer to a static data structure. The
</p>
<p>syntax is
</p>
<p>#include &lt;netdb.h&gt;
</p>
<p>struct hostent *hp;
</p>
<p>hp = gethostbyname(&quot;myhost.domain.country&quot;)
</p>
<p>The resulting structure varies on di&#11;erent implementations of UNIX, but the `old BSD
</p>
<p>standard' is of the form:
</p>
<p>struct hostent
</p>
<p>{
</p>
<p>char *h_name; /* official name of host */
</p>
<p>char **h_aliases; /* alias list */
</p>
<p>int h_addrtype; /* host address type */
</p>
<p>int h_length; /* length of address */
</p>
<p>char **h_addr_list; /* list of addresses from name server */
</p>
<p>};
</p>
<p>#define h_addr h_addr_list[0] /* address, for backward compatiblity */
</p>
<p>The structure contains a list of addresses and or aliases from the nameserver. The interesting
</p>
<p>quantity is usually extracted by means of the macro `h_addr' whcih gives the &#12;rst value in
</p>
<p>the address list, though o&#14;cially one should examine the whole list now.
</p>
<p>This value is a pointer which can be converted into a text form by the following hideous
</p>
<p>type transformation:
</p>
<p>#include &lt;sys/types.h&gt;
</p>
<p>#include &lt;sys/socket.h&gt;
</p>
<p>#include &lt;netinet/in.h&gt;
</p>
<p>struct sockaddr_in sin;
</p>
<p>cin.sin_addr.s_addr = ((struct in_addr *)(hp-&gt;h_addr))-&gt;s_addr;
</p>
<p>printf(&quot;IP address = %s\n&quot;,inet_ntoa(cin.sin_addr));</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>162 The unix programming environment
</p>
<p>See the client program in the &#12;rst section of this chapter for an example of its use.
</p>
<p>10.5 C support for NFS
</p>
<p>The support for NFS mounting in the standard C library is through two sources. NFS
</p>
<p>is based on the Sun's RPC system, so the basic calls are only instances of standard RPC
</p>
<p>protocols.
</p>
<p>The C functions in the standard input/output library can be used to access NFS &#12;lesys-
</p>
<p>tems. Since NFS imitates the UNIX &#12;lesystem as closely as possible, NFS &#12;lesystems can
</p>
<p>be mounted in exactly the same way as ordinary &#12;lesystems. Unfortunately, the C functions
</p>
<p>which perform the mount operation in UNIX and depressingly non-standard. They di&#11;er
</p>
<p>on almost every implementation of UNIX.
</p>
<p>The basic function which mounts a &#12;lesystem, in `mount' (see man (2) mount). The
</p>
<p>mount table is stored in a &#12;le /etc/mtab on BSD systems (again the name varies wildly
</p>
<p>from UNIX to UNIX, mnttab on HPUX for instance). The &#12;le /etc/rmtab on an NFS
</p>
<p>server contains a list of remote-mounted &#12;lesystems which are mounted by remote clients.
</p>
<p>C functions exist which can read the &#12;lesystem tables and place the resulting data in C
</p>
<p>struct types. Alas, these struct de&#12;ntions are also quite di&#11;erent on di&#11;erent systems.
</p>
<p>See `/usr/include/sys/mount.h', so the user wishing to write system-independent code is
</p>
<p>confounded at the lowest level.
</p>
<p>10.6 Exercises
</p>
<p>1. Use `gethostbyname()' to make a simple program like `nslookup' which gives the
</p>
<p>internet address of a named host.
</p>
<p>2. Modify the client server example above to make a `remote ls' command called `rls'.
</p>
<p>You should be able to use the syntax
</p>
<p>rls (options) hostname:/path/to/file</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Appendix A: Summary of programming idioms. 163
</p>
<p>Appendix A Summary of programming idioms.
</p>
<p>True and false
</p>
<p># C shell
</p>
<p>True - non-zero/non-empty value
</p>
<p>False - zero or null string
</p>
<p># Bourne shell
</p>
<p>True - 0 returned by shell command
</p>
<p>False - non-zero returned by shell command
</p>
<p>( Note that &quot;test&quot; converts from C shell style to Bourne shell)
</p>
<p># Perl
</p>
<p>True - non-zero/non-empty value
</p>
<p>False - zero or null string
</p>
<p>/* C */
</p>
<p>True - non zero integer
</p>
<p>False - zero integer
</p>
<p>Input from tty
</p>
<p># C shell
</p>
<p>$&lt;
</p>
<p># Bourne shell
</p>
<p>line
</p>
<p>read
</p>
<p># Perl
</p>
<p>&lt;STDIN&gt;
</p>
<p>/* C */
</p>
<p>scanf
</p>
<p>Redirection of I/O
</p>
<p># C shell
</p>
<p>command &gt; file</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>164 The unix programming environment
</p>
<p>command &gt;&amp; file
</p>
<p>command &gt;&gt; file
</p>
<p>command1 | command2
</p>
<p># Bourne shell
</p>
<p>command &gt; file
</p>
<p>command &gt; file 2&gt;&amp;1
</p>
<p>command &gt;&gt; file
</p>
<p>command1 | command2
</p>
<p># Perl
</p>
<p>open (HANDLE,&quot;&gt;file&quot;)
</p>
<p>open (HANDLE,&quot;&gt;file 2&gt;&amp;1&quot;)
</p>
<p>open (HANDLE,&quot;&gt;&gt;file&quot;)
</p>
<p>open (HANDLE,&quot;command1 |&quot;)
</p>
<p>open (HANDLE,&quot;| command2&quot;)
</p>
<p>/* C */
</p>
<p>fopen (&quot;file&quot;,&quot;w&quot;); printf(..)
</p>
<p>fopen (&quot;file&quot;,&quot;w&quot;); printf(..); fprintf(stderr,..)
</p>
<p>fopen (&quot;file&quot;,&quot;a&quot;); printf(..)
</p>
<p>popen (&quot;command1&quot;,&quot;r&quot;)
</p>
<p>popen (&quot;command2&quot;,&quot;w&quot;)
</p>
<p>Loops and tests
</p>
<p>/* C */ Shell
</p>
<p>foreach end if then else endif
</p>
<p>while end switch case breaksw endsw
</p>
<p>repeat
</p>
<p># Bourne shell
</p>
<p>while do done if then else fi
</p>
<p>until do done case in esac
</p>
<p>for in do done
</p>
<p># Perl
</p>
<p>while if then else
</p>
<p>for unless else
</p>
<p>foreach
</p>
<p>until
</p>
<p>do while
</p>
<p>do until</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Appendix A: Summary of programming idioms. 165
</p>
<p>/* C */
</p>
<p>while if then else
</p>
<p>do while switch case
</p>
<p>for
</p>
<p>Arguments from command line
</p>
<p># C shell
</p>
<p>$argv[]
</p>
<p>$#argv
</p>
<p># Bourne Shell
</p>
<p>$1, $2, $3... $*
</p>
<p>$#
</p>
<p># Perl
</p>
<p>$ARGV[]
</p>
<p>$#ARGV
</p>
<p>/* C */
</p>
<p>char argv[][]
</p>
<p>int argc
</p>
<p>Arithmetic
</p>
<p># C shell
</p>
<p>a = $b + $c
</p>
<p># Bourne shell
</p>
<p>a = `expr $b + $c`
</p>
<p># Perl
</p>
<p>$a = $b + $c;
</p>
<p>/* C */
</p>
<p>a = b + c;
</p>
<p>Numerical comparison
</p>
<p># C shell
</p>
<p>if ( $x == $y ) then
</p>
<p>endif</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>166 The unix programming environment
</p>
<p># Bourne shell
</p>
<p>if [ $x -eq $y ]; then
</p>
<p>fi
</p>
<p># Perl
</p>
<p>if ( $x == $y )
</p>
<p>{
</p>
<p>}
</p>
<p>/* C */
</p>
<p>if ( x == y )
</p>
<p>{
</p>
<p>}
</p>
<p>String comparison
</p>
<p># C shell
</p>
<p>if ( $x == $y ) then
</p>
<p>endif
</p>
<p># Bourne shell
</p>
<p>if [ $x = $y ]; then
</p>
<p>fi
</p>
<p># Perl
</p>
<p>if ( $x eq $y ) then
</p>
<p>{
</p>
<p>}
</p>
<p>/* C */
</p>
<p>if (strcmp(x,y) == 0)
</p>
<p>{
</p>
<p>}
</p>
<p>Opening a &#12;le
</p>
<p># C shell, Bourne shell - cannot be done (pipes only)
</p>
<p># Perl
</p>
<p>open (READ_HANDLE,&quot;filename&quot;);</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Appendix A: Summary of programming idioms. 167
</p>
<p>open (WRITE_HANDLE,&quot;&gt; filename&quot;);
</p>
<p>open (APPEND_HANDLE,&quot;&gt;&gt; filename&quot;);
</p>
<p>/* C */
</p>
<p>FILE *fp;
</p>
<p>fp = fopen (&quot;file&quot;,&quot;r&quot;);
</p>
<p>fp = fopen (&quot;file&quot;,&quot;w&quot;);
</p>
<p>fp = fopen (&quot;file&quot;,&quot;a&quot;);
</p>
<p>Opening a directory
</p>
<p># C shell
</p>
<p>foreach dir ( directory/* )
</p>
<p>...
</p>
<p>end
</p>
<p># Bourne shell
</p>
<p>for dir in directory/* ;
</p>
<p>do
</p>
<p>...
</p>
<p>done
</p>
<p># Perl
</p>
<p>opendir (HANDLE,&quot;directory&quot;) || die;
</p>
<p>while ($entry = readdir(HANDLE))
</p>
<p>{
</p>
<p>}
</p>
<p>closedir(HANDLE);
</p>
<p># C
</p>
<p>#include &lt;dirent.h&gt;
</p>
<p>DIR *dirh;
</p>
<p>struct dirent *dirp;
</p>
<p>if ((dirh = opendir(name)) == NULL)
</p>
<p>{
</p>
<p>perror(&quot;opendir&quot;)
</p>
<p>exit(1);
</p>
<p>}
</p>
<p>for (dirp = readdir(dirh); dirp != NULL; dirp = readdir(dirh))</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>168 The unix programming environment
</p>
<p>{
</p>
<p>... /* dirp-&gt;d_name points to child */
</p>
<p>}
</p>
<p>closedir(dirh);
</p>
<p>Testing &#12;le types
</p>
<p># C shell
</p>
<p>if ( -f file ) # plain file
</p>
<p>if ( -d file ) # directory
</p>
<p># Bourne shell
</p>
<p>if [ -f file ] # plain file
</p>
<p>if [ -d file ] # directory
</p>
<p># Perl
</p>
<p>if ( -f file ) # plain file
</p>
<p>if ( -d file ) # directory
</p>
<p>if ( -l file ) # symbolic link
</p>
<p>/* C */
</p>
<p>#include &lt;sys/stat.h&gt;
</p>
<p>struct stat statvar;
</p>
<p>stat(&quot;file&quot;, &amp;statvar);
</p>
<p>if (S_ISREG(statvar.mode)) /* plain file */
</p>
<p>if (S_ISDIR(statvar.mode)) /* directory */
</p>
<p>lstat(&quot;file&quot;, &amp;statvar);
</p>
<p>if (S_ISLNK(statvar.mode)) /* symbolic link */</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Command and Variable Index 169
</p>
<p>Command and Variable Index
</p>
<p>!
</p>
<p>`!' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`!' not . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>`!=' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
</p>
<p>`!=' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`!~' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
</p>
<p>$
</p>
<p>$ in regular expressions . . . . . . . . . . . . . . . . . . . 24
</p>
<p>$? in make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
</p>
<p>$@ in make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
</p>
<p>$&lt; in make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
</p>
<p>&amp;
</p>
<p>&amp; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>`&amp;' AND . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>'
</p>
<p>' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>(
</p>
<p>() in csh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>*
</p>
<p>* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>* in regular expressions . . . . . . . . . . . . . . . . . . . 24
</p>
<p>-
</p>
<p>`-' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>`--' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>--help . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>`-=' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>`-a' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>-d &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>`-d' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>-e &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>`-eq' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>-f &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>`-f' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`-g' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`-ge' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`-gt' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>-h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>`-le' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`-lt' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`-ne' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`-o' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>-r &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>`-r' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`-s' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`-u' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>-w &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>`-w' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`-x' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>-z &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>-z in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
</p>
<p>.
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>. in regular expressions . . . . . . . . . . . . . . . . . . . 24
</p>
<p>.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>.cshrc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>.profile. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>.xsession . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
</p>
<p>/
</p>
<p>`/bin' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>`/bin/csh' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>`/bin/sh' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>`/dev' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/devices' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/etc' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>`/export' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/home' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/sbin' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/sys' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/users'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/usr' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>`/usr/bin' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>`/usr/local' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/var' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/var/adm' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>`/vr/spool' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>170 The unix programming environment
</p>
<p>:
</p>
<p>:e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
</p>
<p>:h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
</p>
<p>:r . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
</p>
<p>:t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
</p>
<p>=
</p>
<p>`=' assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>`=' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`==' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54, 77
</p>
<p>`==' equal to (compare) . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>`=~' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
</p>
<p>?
</p>
<p>? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>? in regular expressions . . . . . . . . . . . . . . . . . . . 24
</p>
<p>[
</p>
<p>[] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>[] in regular expressions . . . . . . . . . . . . . . . . . . 24
</p>
<p>`
</p>
<p>` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>`...` . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>`` shell construction . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>|
</p>
<p>| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>`|' OR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>`||' logical OR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>&quot;
</p>
<p>&quot; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>+
</p>
<p>`+' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>+ in regular expressions . . . . . . . . . . . . . . . . . . . 24
</p>
<p>`+=' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>`++' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>&gt;
</p>
<p>&gt; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>`&gt;' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
</p>
<p>`&gt;' greater than . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>`&gt;=' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
</p>
<p>&gt;&gt; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>`&gt;&gt;' shift . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>^
</p>
<p>^ in regular expressions . . . . . . . . . . . . . . . . . . . 24
</p>
<p>`^' XOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>&lt;
</p>
<p>&lt; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>`&lt;' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
</p>
<p>`&lt;' less than . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>`&lt;=' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
</p>
<p>&lt;&lt; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43, 45
</p>
<p>`&lt;&lt;' shift . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>A
</p>
<p>apropos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>`ar' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`archie'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>argc in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
</p>
<p>argv in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
</p>
<p>`awk' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>B
</p>
<p>breaksw . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
</p>
<p>C
</p>
<p>`cat' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`cc' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`CC' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`chgrp' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`chmod' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`chown' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`cmdtool' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>continue. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
</p>
<p>`cp' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>crypt() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
</p>
<p>h
</p>
<p>CTRL-A
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Command and Variable Index 171
</p>
<p>h
</p>
<p>CTRL-C
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>h
</p>
<p>CTRL-E
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>h
</p>
<p>CTRL-L
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>h
</p>
<p>CTRL-Z
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>`cut' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>D
</p>
<p>`date' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`dbx' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`dc' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>ddd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`df' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>DISPLAY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>`domainname' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`du' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`dvips' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>E
</p>
<p>`ed' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`elm' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`emacs' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>env . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>`eq' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
</p>
<p>F
</p>
<p>`find' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`finger'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`fmgr' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`fnews' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>foreach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
</p>
<p>`ftp' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>G
</p>
<p>`g++' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`gcc' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`gdb' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>getenv() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
</p>
<p>`ghostscript' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`ghostview' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>H
</p>
<p>HOME . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>HOST . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>`hostname' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>I
</p>
<p>ioctl(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
</p>
<p>`irc' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`ispell'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>K
</p>
<p>keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
</p>
<p>L
</p>
<p>`latex' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`ld' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>LD_LIBRARY_PATH . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>`LD_LIBRARY_PATH' . . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>`less' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>ln . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>ln -s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>`locate'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`lp' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`lpq' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`lpstat'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`ls' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>M
</p>
<p>man -k . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>`mesg' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>mkdir . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>`mkdir' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`more' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`mv' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>N
</p>
<p>`ncftp' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`netstat' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`nslookup' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>172 The unix programming environment
</p>
<p>P
</p>
<p>`paste' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>PATH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>`pico' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`pine' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`ping' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>PRINTER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>`PRINTER' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`ps' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>R
</p>
<p>rand() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
</p>
<p>`rcpinfo' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`rename' in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
</p>
<p>repeat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>`rlogin'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`rmail' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`rmdir' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`rsh' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>S
</p>
<p>`screen'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`sed' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>`setroot' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`shelltool' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`showmount' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>stderr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>stdin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>stdout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>T
</p>
<p>`talk' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`tcl' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`telnet'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>TERM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>`tex' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`texinfo' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`textedit' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`touch' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>U
</p>
<p>`uname' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`unlink'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>unset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>`users' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>V
</p>
<p>`vi' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`vmstat'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`vmunix'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>W
</p>
<p>`w' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`whereis' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>which . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>`who' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`write' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>X
</p>
<p>`xarchie' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xcalc' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xdvi' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xedit' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`xemacs'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`xfig' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xmosaic' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xpaint'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xrn' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xterm' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`xv' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xxgdb' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Z
</p>
<p>`zmail' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Concept Index 173
</p>
<p>Concept Index
</p>
<p>#
</p>
<p>`#!program' sequence . . . . . . . . . . . . . . . . . . . . . 51, 65
</p>
<p>$
</p>
<p>$ in regular expressions . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>`$&lt;' operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
</p>
<p>'
</p>
<p>h
</p>
<p>'
</p>
<p>i
</p>
<p>and
</p>
<p>h
</p>
<p>&quot;
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>(
</p>
<p>() and subshells. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
</p>
<p>() operators to make array in csh . . . . . . . . . . . . . 43
</p>
<p>*
</p>
<p>* in regular expressions . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>-
</p>
<p>`-I' option to cc . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
</p>
<p>`-L' option to cc . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>.
</p>
<p>. directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11, 12
</p>
<p>. in regular expressions . . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>.. directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11, 12
</p>
<p>`.cshrc' &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>`.login' &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>`.profile' set up in sh . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>.xsession &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
</p>
<p>/
</p>
<p>`/etc/group' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>?
</p>
<p>? in regular expressions . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>[
</p>
<p>`[]' for test in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
</p>
<p>[] in regular expressions . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>`
</p>
<p>h
</p>
<p>`
</p>
<p>i
</p>
<p>symbol and embedded shells . . . . . . . . . . . . . . . 47
</p>
<p>``..`' in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
</p>
<p>|
</p>
<p>`|' symbol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43, 45
</p>
<p>+
</p>
<p>+ in regular expressions . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>^
</p>
<p>^ in regular expressions . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>&lt;
</p>
<p>`&lt;&gt;' &#12;lehandle in perl. . . . . . . . . . . . . . . . . . . . . . . . . 84
</p>
<p>1
</p>
<p>`1&gt;' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
</p>
<p>2
</p>
<p>`2&gt;' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
</p>
<p>`2&gt;&amp;1' in sh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
</p>
<p>A
</p>
<p>`a.out'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>accept() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
</p>
<p>Access bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>Access bits, octal form . . . . . . . . . . . . . . . . . . . . . . . 38
</p>
<p>Access bits, text form . . . . . . . . . . . . . . . . . . . . . . . . 38
</p>
<p>Access control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>Access control lists . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>Access rights . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>Access to &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>ACLs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>ANSI C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>174 The unix programming environment
</p>
<p>Appending to a &#12;le with `&gt;&gt;' . . . . . . . . . . . . . . . . . 44
</p>
<p>apropos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>`ar' archiver . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`archie' program . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Argument vector in csh . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>Argument vector in perl . . . . . . . . . . . . . . . . . . 76, 78
</p>
<p>Arguments, command line . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>`argv' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>Arithemtic in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
</p>
<p>Arithemtic operations in csh . . . . . . . . . . . . . . . . . . 59
</p>
<p>Arrays (associated) in perl. . . . . . . . . . . . . . . . . . . . 79
</p>
<p>Arrays (normal) in perl . . . . . . . . . . . . . . . . . . . . . . 78
</p>
<p>Arrays and `split' . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
</p>
<p>Arrays in csh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>Arrays in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
</p>
<p>Associated arrays, iteration . . . . . . . . . . . . . . . . . . . 83
</p>
<p>`at' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
</p>
<p>AT&amp;T . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
</p>
<p>`awk' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`awk' pattern extractor . . . . . . . . . . . . . . . . . . . . . . . 75
</p>
<p>B
</p>
<p>`Background picture' . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Background process . . . . . . . . . . . . . . . . . . . . . . 47, 48
</p>
<p>Backwards quotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>bash. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10, 25
</p>
<p>`batch' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
</p>
<p>Berkeley Internet Name Domain (BIND) . . . . . 160
</p>
<p>`bg' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>Big endian . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
</p>
<p>BIND . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>bind() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
</p>
<p>Bourne shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10, 63
</p>
<p>Break key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>`breaksw' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
</p>
<p>Browsing through a &#12;le. . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>BSD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
</p>
<p>Build software script . . . . . . . . . . . . . . . . . . . . . . . . . 55
</p>
<p>Built in commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>Byte order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
</p>
<p>C
</p>
<p>C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
</p>
<p>C library calls and shell commands . . . . . . . . . . . . 10
</p>
<p>C programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>C shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>C shell setup &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>C, role in unix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>C++ su&#14;x rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
</p>
<p>Calculator, shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Calculator, X windows . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`cat' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`cc' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`CC' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>CGI protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
</p>
<p>Changing &#12;le mode . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`chgrp' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>chgrp command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>`chmod' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>chmod command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
</p>
<p>`chop' command in perl . . . . . . . . . . . . . . . . . . . . . . 86
</p>
<p>`chown' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>chown command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>`close' command in perl . . . . . . . . . . . . . . . . . . . . . 84
</p>
<p>closedir command . . . . . . . . . . . . . . . . . . . . . . . . . 126
</p>
<p>`cmdtool' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Command completion . . . . . . . . . . . . . . . . . . . . . . . . 46
</p>
<p>Command history. . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
</p>
<p>Command interpreter . . . . . . . . . . . . . . . . . . . . . . . . 19
</p>
<p>Command line arguments . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>Command line arguments in C . . . . . . . . . . . . . . . 125
</p>
<p>Command line arguments in perl . . . . . . . . . . 76, 78
</p>
<p>Command line arguments in sh . . . . . . . . . . . . . . . 65
</p>
<p>Command path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>Command window . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Commands as &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>Commands path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>Comparison operators in csh . . . . . . . . . . . . . . . . . . 54
</p>
<p>Compiler script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
</p>
<p>Compilers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Compiling huge programs . . . . . . . . . . . . . . . . . . . 120
</p>
<p>Compiling programs . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>connect() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
</p>
<p>`continue' in csh . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
</p>
<p>Continuing long lines. . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>Copy of output to &#12;le . . . . . . . . . . . . . . . . . . . . . . . . 45
</p>
<p>core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>`cp' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Creating directories . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Creating &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`csh' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>csh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>h
</p>
<p>CTRL-A
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>h
</p>
<p>CTRL-C
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Concept Index 175
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>and EOF . . . . . . . . . . . . . . . . . . . . . . . . . . 70
</p>
<p>h
</p>
<p>CTRL-E
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>h
</p>
<p>CTRL-L
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>h
</p>
<p>CTRL-Z
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>Curses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>`cut' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
</p>
<p>Cut as a perl script . . . . . . . . . . . . . . . . . . . . . . . . . . 84
</p>
<p>`cut' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>D
</p>
<p>Database maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
</p>
<p>Database support . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
</p>
<p>`date' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Date stamp, updating . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`dbx' debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Debugger for C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>Debugger GUI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Decisions and return codes in sh . . . . . . . . . . . . . . 66
</p>
<p>delete . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>Dependencies in Make&#12;les . . . . . . . . . . . . . . . . . . . 121
</p>
<p>`df' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`die' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
</p>
<p>Directories, creating. . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Directories, deleting . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>dirent directory interface . . . . . . . . . . . . . . . . . . . . 126
</p>
<p>Disk usage. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>DISPLAY variable . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
</p>
<p>Display, X. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
</p>
<p>DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>`do..while' in perl. . . . . . . . . . . . . . . . . . . . . . . . . . . 81
</p>
<p>Domainname . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`domainname' command. . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>DOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
</p>
<p>Drawing program . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`du' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>dvi to postscript . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>E
</p>
<p>`ed' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>egrep command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
</p>
<p>`elm' mailer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`emacs' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Embedded shell. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
</p>
<p>End of &#12;le
</p>
<p>h
</p>
<p>CTRL-D
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . 70
</p>
<p>env command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>Environment variables . . . . . . . . . . . . . . . . . . . . 19, 21
</p>
<p>Environment variables in C . . . . . . . . . . . . . . . . . . 125
</p>
<p>Environment variables in perl . . . . . . . . . . . . . 76, 79
</p>
<p>Environment, unix user . . . . . . . . . . . . . . . . . . . . . . 19
</p>
<p>envp in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
</p>
<p>`eq' and `==' in perl . . . . . . . . . . . . . . . . . . . . . . . . . . 77
</p>
<p>Error messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>Errors in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
</p>
<p>Executable, making programs . . . . . . . . . . . . . . . . . 39
</p>
<p>Exiting on errors in perl . . . . . . . . . . . . . . . . . . . . . . 87
</p>
<p>`EXPORT' command in sh . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>Expressions, regular . . . . . . . . . . . . . . . . . . . . . . . . . . 23
</p>
<p>extern variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>Extracting &#12;lename components . . . . . . . . . . . . . . 58
</p>
<p>F
</p>
<p>`fg' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>File access permission . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>File handles in perl . . . . . . . . . . . . . . . . . . . . . . . . . . 84
</p>
<p>File hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>File mode, changing. . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>File protection bits . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>File transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>File type, determining in C . . . . . . . . . . . . . . . . . . 128
</p>
<p>Filename completion . . . . . . . . . . . . . . . . . . . . . . . . . 46
</p>
<p>Files in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
</p>
<p>Files, iterating over lines . . . . . . . . . . . . . . . . . . . . . 83
</p>
<p>`find' command . . . . . . . . . . . . . . . . . . . . . . . . . . 27, 48
</p>
<p>Finding commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>Finding FTP &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`finger' service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`fmgr' &#12;le manager . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`fnews' news reader . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>For loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
</p>
<p>for loop in perl. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
</p>
<p>for loop in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
</p>
<p>For loops in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
</p>
<p>foreach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>foreach example . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
</p>
<p>Foreach loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
</p>
<p>foreach loop in perl . . . . . . . . . . . . . . . . . . . . . . . . . 81
</p>
<p>Foreground process . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>Forking new processes . . . . . . . . . . . . . . . . . . . . . . . . 89
</p>
<p>Formatting text in a &#12;le . . . . . . . . . . . . . . . . . . . . . . 45
</p>
<p>Forms in HTML . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>176 The unix programming environment
</p>
<p>`ftp' program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>FTP resources, &#12;nding . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Fully quali&#12;ed name . . . . . . . . . . . . . . . . . . . . . . . . 161
</p>
<p>G
</p>
<p>`g++' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`gcc' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`gdb' debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>getenv() function . . . . . . . . . . . . . . . . . . . . . . . . . 125
</p>
<p>getgrnam() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>gethostbyname() . . . . . . . . . . . . . . . . . . . . . . 153, 161
</p>
<p>gethostent() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>getnetgrent() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>getpwnam() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>getpwuid() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>getservbyname() . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>getservbyport() . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>Getting command output into a string . . . . . . . . 25
</p>
<p>`ghostscript' &quot;GNU postscript&quot; interpreter . . . 30
</p>
<p>`ghostview' postscript previewer . . . . . . . . . . . . . . 30
</p>
<p>gif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Global variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>Global variables in csh . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>Global variables in sh . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>Granting permission . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>H
</p>
<p>Hard links . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12, 13
</p>
<p>Help function for commands . . . . . . . . . . . . . . . . . . . 8
</p>
<p>Hierarchy, &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>`hostname' command . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Hypertext . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>I
</p>
<p>I/O streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>`if' in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
</p>
<p>if..then..else in csh . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>if..then..else..fi in sh. . . . . . . . . . . . . . . . . . . . 67
</p>
<p>`IFS' variable in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
</p>
<p>INADDR_ANY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
</p>
<p>Include &#12;le search path . . . . . . . . . . . . . . . . . . . . . . 118
</p>
<p>Include &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
</p>
<p>Index nodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>Information about &#12;le properties . . . . . . . . . . . . . 127
</p>
<p>init . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
</p>
<p>inodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>Input in csh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
</p>
<p>Input in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
</p>
<p>Input over many lines . . . . . . . . . . . . . . . . . . . . . . . . 45
</p>
<p>Inserting a command into a string. . . . . . . . . . . . . 25
</p>
<p>Internet relay chat . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>Internet resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Interpretation of values in perl . . . . . . . . . . . . . . . . 77
</p>
<p>Interrupt handler in sh . . . . . . . . . . . . . . . . . . . . . . . 71
</p>
<p>ioctl(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
</p>
<p>`IRC' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>Iterating over &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
</p>
<p>Iteration over arrays . . . . . . . . . . . . . . . . . . . . . . . . . 82
</p>
<p>J
</p>
<p>Job control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>Job numbers in csh . . . . . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>Job, moving to background . . . . . . . . . . . . . . . . . . . 50
</p>
<p>Joker notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>jpg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>jsh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>K
</p>
<p>kernel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>Kernel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>Kernighan and Ritchie C . . . . . . . . . . . . . . . . . . . . 116
</p>
<p>`kill' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>ksh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10, 25
</p>
<p>L
</p>
<p>`latex' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`ld' loader/linker . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`ld.so.cache' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
</p>
<p>`ldconfig' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
</p>
<p>`less' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>lex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>`lex' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>Lexer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
</p>
<p>libc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>libcurses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>libm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>Library path for C loader . . . . . . . . . . . . . . . . . . . 117
</p>
<p>Limitations of shell programs . . . . . . . . . . . . . . . . . 73
</p>
<p>Links in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Concept Index 177
</p>
<p>Links, where do they point? . . . . . . . . . . . . . . . . . 127
</p>
<p>listen() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
</p>
<p>Little endian . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
</p>
<p>ln -s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>Local variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>Local variables in csh . . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>Local variables in perl . . . . . . . . . . . . . . . . . . . . . . . . 87
</p>
<p>Local variables in sh . . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>`locate' command . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>Logging on . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
</p>
<p>Login environment . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
</p>
<p>Login evironment . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>Long &#12;le listing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>Long lines, continuing . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>Loops and list separators . . . . . . . . . . . . . . . . . . . . . 70
</p>
<p>Loops in csh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>Loops in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
</p>
<p>`lp' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`lpq' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`lpr' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`lpstat'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>ls -l . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>`ls command'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>lstat(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
</p>
<p>M
</p>
<p>MacIntosh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
</p>
<p>Macros for stat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
</p>
<p>Mail clients . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>Make rules for C++ . . . . . . . . . . . . . . . . . . . . . . . . . 124
</p>
<p>Make software script . . . . . . . . . . . . . . . . . . . . . . . . . 55
</p>
<p>Making a script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>Making directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>Making scripts in sh . . . . . . . . . . . . . . . . . . . . . . . . . 65
</p>
<p>Masking programs executable . . . . . . . . . . . . . . . . . 39
</p>
<p>Matching &#12;lenames . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>Matching strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
</p>
<p>mc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>Mercury . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`mesg' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>Mime types in W3 . . . . . . . . . . . . . . . . . . . . . . . . . . 103
</p>
<p>mkdir . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>`mkdir' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`more' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`mosaic'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Mounted &#12;le systems . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Moving a job to the background . . . . . . . . . . . . . . 50
</p>
<p>Moving &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Multiple C &#12;les, compiling . . . . . . . . . . . . . . . . . . . 117
</p>
<p>Multiple screens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
</p>
<p>`mv' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>N
</p>
<p>nc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`ncftp' program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`netstat' network statistics. . . . . . . . . . . . . . . . . . . 29
</p>
<p>Network byte order . . . . . . . . . . . . . . . . . . . . . . . . . 151
</p>
<p>Network databases . . . . . . . . . . . . . . . . . . . . . . . . . . 159
</p>
<p>Network information service . . . . . . . . . . . . . . . . . 159
</p>
<p>Never do in unix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>NFS and C support . . . . . . . . . . . . . . . . . . . . . . . . . 162
</p>
<p>NIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
</p>
<p>nobody . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>noclobber overwrite protection . . . . . . . . . . . . . . . 44
</p>
<p>noclobber variable. . . . . . . . . . . . . . . . . . . . . . . . . . . 44
</p>
<p>`nslookup' command . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>O
</p>
<p>`open' command in perl . . . . . . . . . . . . . . . . . . . . . . 84
</p>
<p>opendir command . . . . . . . . . . . . . . . . . . . . . . . . . . 126
</p>
<p>Opening a pipe in C . . . . . . . . . . . . . . . . . . . . . . . . 135
</p>
<p>Operating system name . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Operators in csh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
</p>
<p>Output to &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
</p>
<p>Output, sending to a &#12;le . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>P
</p>
<p>Painting program . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Panic button . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>Parameters in perl functions . . . . . . . . . . . . . . . . . . 87
</p>
<p>Parser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
</p>
<p>Parts of a &#12;lename . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
</p>
<p>`passwd' &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
</p>
<p>`paste' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
</p>
<p>Paste as a perl script . . . . . . . . . . . . . . . . . . . . . . . . . 84
</p>
<p>`paste' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>PATH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>Pattern matching in perl . . . . . . . . . . . . . . . . . . 93, 95</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>178 The unix programming environment
</p>
<p>Pattern replacement in perl . . . . . . . . . . . . . . . . . . . 93
</p>
<p>PC windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
</p>
<p>perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
</p>
<p>Perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
</p>
<p>Perl variables and types . . . . . . . . . . . . . . . . . . . . . . 76
</p>
<p>Perl, strings and scalar . . . . . . . . . . . . . . . . . . . . . . . 77
</p>
<p>Perl, truncating strings . . . . . . . . . . . . . . . . . . . . . . . 86
</p>
<p>Permissions on &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>Permissions, determining in C . . . . . . . . . . . . . . . 128
</p>
<p>`pico' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Picture processing . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`pine' mailer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>Pipe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
</p>
<p>Pipes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>Pipes in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
</p>
<p>Piping to more to prevent scrolling . . . . . . . . . . . . 45
</p>
<p>popen(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
</p>
<p>POSIX standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>Postscript viewers . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Printer queue. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>Printer status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`PRINTER' variable. . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>Printing a &#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>Printing multiple lines . . . . . . . . . . . . . . . . . . . . . . . 45
</p>
<p>Procedures and subroutines in sh . . . . . . . . . . . . . 71
</p>
<p>Process. moving to background . . . . . . . . . . . . . . . 50
</p>
<p>Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
</p>
<p>Prompt, rede&#12;ning . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>Protecting &#12;les from overwrite with `&gt;' . . . . . . . . 44
</p>
<p>Protection bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>`ps' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>R
</p>
<p>readdir command . . . . . . . . . . . . . . . . . . . . . . . . . . 126
</p>
<p>readlink() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
</p>
<p>recv() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
</p>
<p>Rede&#12;ning list separator in sh . . . . . . . . . . . . . . . . 70
</p>
<p>Redirecting stdio in sh . . . . . . . . . . . . . . . . . . . . . . . 64
</p>
<p>Redirection of stdio . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>Regular expressions . . . . . . . . . . . . . . . . . . . . . . . . . . 23
</p>
<p>Reliable socket protocol . . . . . . . . . . . . . . . . . . . . . 157
</p>
<p>Renaming &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>repeat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>Result of a command into a string . . . . . . . . . . . . 25
</p>
<p>Return codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`rlogin'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>rlogin program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
</p>
<p>`rm' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`rmail' in emacs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`rmdir' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Role of C in unix . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>Root privileges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
</p>
<p>root user . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>rpcgen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>`rpcinfo' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`rsh' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>S
</p>
<p>s-bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39, 40
</p>
<p>Scalar variables in perl . . . . . . . . . . . . . . . . . . . . . . . 77
</p>
<p>scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>`screen'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Screens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
</p>
<p>Script aliases in W3 . . . . . . . . . . . . . . . . . . . . . . . . . 104
</p>
<p>Script, making . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>Scripts in sh, making . . . . . . . . . . . . . . . . . . . . . . . . . 65
</p>
<p>Searching and replacing in perl (example) . . . . . 94
</p>
<p>`sed' as a perl script . . . . . . . . . . . . . . . . . . . . . . . . . 93
</p>
<p>`sed' batch editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
</p>
<p>`sed' editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`sed', search and replace . . . . . . . . . . . . . . . . . . . . . 55
</p>
<p>send() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
</p>
<p>Sending messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>set command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>setenv command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>setgid bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>Setting the prompt . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>Setting up the C shell . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>Setting up the x environment . . . . . . . . . . . . . . . . . 32
</p>
<p>setuid bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>SetUID scripts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
</p>
<p>`sh' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>sh5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>Shared libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
</p>
<p>shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6, 9
</p>
<p>Shell commands and C library calls . . . . . . . . . . . 10
</p>
<p>h
</p>
<p>Shells, various
</p>
<p>i
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>`shelltool' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`shift' and arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
</p>
<p>`shift' and arrays in perl . . . . . . . . . . . . . . . . . . . . 79
</p>
<p>shift operator on strings . . . . . . . . . . . . . . . . . . . . 65
</p>
<p>`showmount' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Signal handler in sh . . . . . . . . . . . . . . . . . . . . . . . . . . 71</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Concept Index 179
</p>
<p>Single and double quotes . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>`sleep' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
</p>
<p>socket() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
</p>
<p>Sockets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
</p>
<p>Soft links . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>`Sonar' ping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Spelling checker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`split' and arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
</p>
<p>`split' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
</p>
<p>Splitting C into many &#12;les. . . . . . . . . . . . . . . . . . . 117
</p>
<p>Splitting output to several &#12;les . . . . . . . . . . . . . . . 45
</p>
<p>Standard error. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>Standard I/O in perl . . . . . . . . . . . . . . . . . . . . . . . . . 84
</p>
<p>Standard I/O in sh . . . . . . . . . . . . . . . . . . . . . . . . . . 64
</p>
<p>Standard I/O, redirection . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>Standard input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>Standard output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>Starting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
</p>
<p>Starting shell jobs . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>stat() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
</p>
<p>Static linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
</p>
<p>Statistics about a &#12;le . . . . . . . . . . . . . . . . . . . . . . . 127
</p>
<p>Sticky bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
</p>
<p>Strings in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
</p>
<p>`stty' and switching o&#11; term echo . . . . . . . . . . . . 88
</p>
<p>Subroutines in perl . . . . . . . . . . . . . . . . . . . . . . . . . . 86
</p>
<p>Subshells and () . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
</p>
<p>Su&#14;x rules in Make&#12;les . . . . . . . . . . . . . . . . . . . . . 121
</p>
<p>superuser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>Suspending a job . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>Swapping text strings . . . . . . . . . . . . . . . . . . . . . . . . 55
</p>
<p>switch..case in csh . . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>Symbolic links . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>System 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
</p>
<p>`System details' . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>System identity and `uname' . . . . . . . . . . . . . . . . . . 55
</p>
<p>System name . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>System V . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
</p>
<p>T
</p>
<p>t-bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
</p>
<p>h
</p>
<p>TAB
</p>
<p>i
</p>
<p>completion key . . . . . . . . . . . . . . . . . . . . . . . . 46
</p>
<p>`talk' service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`TCL' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>TCP/IP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
</p>
<p>tcsh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10, 25
</p>
<p>`tee' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
</p>
<p>Teletype terminal . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
</p>
<p>telnet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
</p>
<p>`telnet'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Terminal echo and `stty' . . . . . . . . . . . . . . . . . . . . . 88
</p>
<p>Terminals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`test' in sh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
</p>
<p>test programs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>test, don't call your program this . . . . . . . . . . . . . . 9
</p>
<p>Testing &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>Testing reponse from other hosts. . . . . . . . . . . . . . 30
</p>
<p>Tests and conditions in csh . . . . . . . . . . . . . . . . . . . 53
</p>
<p>Tests in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>`tex' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`texinfo' system . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Text form of access bits . . . . . . . . . . . . . . . . . . . . . . 38
</p>
<p>Text formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`textedit' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>The arguement vector in C . . . . . . . . . . . . . . . . . . 125
</p>
<p>The domain name service . . . . . . . . . . . . . . . . . . . 160
</p>
<p>ti&#11;. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Time and date. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Time stamp, updating . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Tk library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>`touch' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Traps in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
</p>
<p>Truncating strings in perl . . . . . . . . . . . . . . . . . . . . 86
</p>
<p>tty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
</p>
<p>`type' in DOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>Types in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
</p>
<p>U
</p>
<p>umask variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>`uname' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
</p>
<p>Unde&#12;ning variables . . . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>undelete . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>UNIX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
</p>
<p>UNIX history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
</p>
<p>`unless' in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
</p>
<p>`unlink' command . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>unset command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>`until' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
</p>
<p>Up arrow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
</p>
<p>Updating &#12;le time stamp . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>User database support . . . . . . . . . . . . . . . . . . . . . . . 90
</p>
<p>User environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
</p>
<p>`users' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>180 The unix programming environment
</p>
<p>V
</p>
<p>Variables, global . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>Variables, local . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>`vi' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>Viewing a &#12;le. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>`vmstat' virtual memory stats . . . . . . . . . . . . . . . . 29
</p>
<p>W
</p>
<p>`w' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`wait.h' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
</p>
<p>Waiting for child processes . . . . . . . . . . . . . . . . . . 135
</p>
<p>`whereis' command . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>which command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>`while' in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
</p>
<p>`while' in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
</p>
<p>while loop in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
</p>
<p>`who' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>`whoami' command . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
</p>
<p>Wildcards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19, 22
</p>
<p>Windows on PC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
</p>
<p>Wrapper functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>Wrappers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>`write' command . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>write example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
</p>
<p>Writing a script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>WTERMSIG(status) . . . . . . . . . . . . . . . . . . . . . . . . . . 135
</p>
<p>X
</p>
<p>X access control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
</p>
<p>X display . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32, 33
</p>
<p>X protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
</p>
<p>X window system . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
</p>
<p>X windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>X windows access . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
</p>
<p>X windows authenti&#12;cation . . . . . . . . . . . . . . . . . . . 33
</p>
<p>X-windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
</p>
<p>`xarchie' client . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>Xauthority mechanism . . . . . . . . . . . . . . . . . . . . . . . 34
</p>
<p>`xedit' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`xemacs'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>`xfig' drawing program . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>xhost mechanism . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
</p>
<p>`xpaint' program . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xrn' news reader . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xterm' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>xterm program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
</p>
<p>`xv' picture processor . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>`xxgdb' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>Y
</p>
<p>yacc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>`yacc' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115, 147
</p>
<p>Z
</p>
<p>`zmail' client . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>zsh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>i<p>Table of Contents
</p>
<p>Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
</p>
<p>Welcome . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
</p>
<p>1 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
</p>
<p>1.1 What is unix? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
</p>
<p>1.2 Flavours of unix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
</p>
<p>1.3 How to use this reference guide . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
</p>
<p>1.4 NEVER-DO's in UNIX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>1.5 What you should know before starting . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>1.5.1 One library: several interfaces . . . . . . . . . . . . . . . . . . . 9
</p>
<p>1.5.2 Unix commands are &#12;les . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>1.5.3 Kernel and Shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>1.5.4 The role of C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>1.5.5 Stdin, stdout, stderr . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>1.6 The superuser (root) and nobody . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>1.7 The &#12;le hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>1.8 Symbolic links . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>1.9 Hard links . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>2 Getting started . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
</p>
<p>2.1 Logging in . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
</p>
<p>2.2 Mouse buttons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
</p>
<p>2.3 E-mail. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
</p>
<p>2.4 Simple commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
</p>
<p>2.5 Text editing and word processing . . . . . . . . . . . . . . . . . . . . . . . . 17
</p>
<p>3 The login environment . . . . . . . . . . . . . . . . . . . . 19
</p>
<p>3.1 Shells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
</p>
<p>3.1.1 Shell commands generally . . . . . . . . . . . . . . . . . . . . . . 20
</p>
<p>3.1.2 Environment and shell variables . . . . . . . . . . . . . . . . 21
</p>
<p>3.1.3 Wildcards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>3.1.4 Regular expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
</p>
<p>3.1.5 Nested shell commands and \ . . . . . . . . . . . . . . . . . . . 24
</p>
<p>3.2 UNIX command overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>3.2.1 Important keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>3.2.2 Alternative shells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>3.2.3 Window based terminal emulators . . . . . . . . . . . . . . 26
</p>
<p>3.2.4 Remote shells and logins . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>3.2.5 Text editors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>3.2.6 File handling commands . . . . . . . . . . . . . . . . . . . . . . . 26
</p>
<p>3.2.7 File browsing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>ii The unix programming environment
</p>
<p>3.2.8 Ownership and granting access permission . . . . . . . 27
</p>
<p>3.2.9 Extracting from and rebuilding &#12;les . . . . . . . . . . . . . 27
</p>
<p>3.2.10 Locating &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>3.2.11 Disk usage. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>3.2.12 Show other users logged on . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>3.2.13 Contacting other users . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>3.2.14 Mail senders/readers . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>3.2.15 File transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>3.2.16 Compilers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>3.2.17 Other interpreted languages . . . . . . . . . . . . . . . . . . . 29
</p>
<p>3.2.18 Processes and system statistics . . . . . . . . . . . . . . . . 29
</p>
<p>3.2.19 System identity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>3.2.20 Internet resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>3.2.21 Text formatting and postscript . . . . . . . . . . . . . . . . 30
</p>
<p>3.2.22 Picture editors and processors . . . . . . . . . . . . . . . . . 30
</p>
<p>3.2.23 Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
</p>
<p>3.3 Terminals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
</p>
<p>3.4 The X window system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
</p>
<p>3.4.1 The components of the X-window system . . . . . . . . 31
</p>
<p>3.4.2 How to set up X windows . . . . . . . . . . . . . . . . . . . . . . 32
</p>
<p>3.4.3 X displays and authority . . . . . . . . . . . . . . . . . . . . . . . 33
</p>
<p>3.5 Multiple screens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
</p>
<p>4 Files and access. . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>4.1 Protection bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>4.2 chmod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
</p>
<p>4.3 Umask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>4.3.1 Making programs executable . . . . . . . . . . . . . . . . . . . 39
</p>
<p>4.3.2 chown and chgrp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>4.3.3 Making a group . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>4.4 s-bit and t-bit (sticky bit) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
</p>
<p>5 C shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>5.1 .cshrc and .login &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>5.2 De&#12;ning variables with set, setenv . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>5.3 Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>5.4 Pipes and redirection in csh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>5.5 `tee' and `script'. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
</p>
<p>5.6 Command history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
</p>
<p>5.7 Command/&#12;lename completion . . . . . . . . . . . . . . . . . . . . . . . . . . 46
</p>
<p>5.8 Single and double quotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>5.9 Job control, break key, `fg', `bg' . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>5.9.1 Unix Processes and BSD signals . . . . . . . . . . . . . . . . 48
</p>
<p>5.9.2 Child Processes and zombies . . . . . . . . . . . . . . . . . . . . 49
</p>
<p>5.9.3 C-shell builtins: `jobs', `kill', `fg',`bg', break key
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>5.10 Scripts with arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>5.11 Sub-shells () . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>iii
</p>
<p>5.12 Tests and conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
</p>
<p>5.12.1 Switch example: con&#12;gure script . . . . . . . . . . . . . . . 55
</p>
<p>5.13 Loops in csh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>5.14 Input from the user . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
</p>
<p>5.15 Extracting parts of a pathname . . . . . . . . . . . . . . . . . . . . . . . . 58
</p>
<p>5.16 Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>5.17 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>6 Bourne shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>6.1 .pro&#12;le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>6.2 Variables and export . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>6.3 Stdin, stdout and stderr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
</p>
<p>6.4 Arithmetic in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
</p>
<p>6.5 Scripts and arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
</p>
<p>6.6 Return codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>6.7 Tests and conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
</p>
<p>6.8 Input from the user in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
</p>
<p>6.9 Loops in sh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
</p>
<p>6.10 Procedures and traps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
</p>
<p>6.11 setuid and setgid scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
</p>
<p>6.12 Summary: Limitations of shell programming . . . . . . . . . . . . 73
</p>
<p>6.13 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
</p>
<p>7 Perl. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
</p>
<p>7.1 Sed and awk, cut and paste . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
</p>
<p>7.2 Program structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
</p>
<p>7.3 Perl variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
</p>
<p>7.3.1 Scalar variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
</p>
<p>7.3.2 The default scalar variable. . . . . . . . . . . . . . . . . . . . . . 78
</p>
<p>7.3.3 Array (vector) variables . . . . . . . . . . . . . . . . . . . . . . . . 78
</p>
<p>7.3.4 Special array commands . . . . . . . . . . . . . . . . . . . . . . . . 78
</p>
<p>7.3.5 Associated arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
</p>
<p>7.3.6 Array example program . . . . . . . . . . . . . . . . . . . . . . . . 80
</p>
<p>7.4 Loops and conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
</p>
<p>7.4.1 The for loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
</p>
<p>7.4.2 The foreach loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
</p>
<p>7.4.3 Iterating over elements in arrays . . . . . . . . . . . . . . . . 82
</p>
<p>7.4.4 Iterating over lines in a &#12;le . . . . . . . . . . . . . . . . . . . . . 83
</p>
<p>7.5 Files in perl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
</p>
<p>7.5.1 A simple perl program . . . . . . . . . . . . . . . . . . . . . . . . . 85
</p>
<p>7.5.2 == and `eq' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
</p>
<p>7.5.3 chop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
</p>
<p>7.6 Perl subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
</p>
<p>7.7 die - exit on error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
</p>
<p>7.8 The stat() idiom . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
</p>
<p>7.9 Perl example programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
</p>
<p>7.9.1 The passwd program and `crypt()' function . . . . . 88
</p>
<p>7.9.2 Example with `fork()' . . . . . . . . . . . . . . . . . . . . . . . . . 89</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>iv The unix programming environment
</p>
<p>7.9.3 Example reading databases . . . . . . . . . . . . . . . . . . . . . 90
</p>
<p>7.10 Pattern matching and extraction . . . . . . . . . . . . . . . . . . . . . . . 92
</p>
<p>7.11 Searching and replacing text . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
</p>
<p>7.12 Example: convert mail to WWW pages . . . . . . . . . . . . . . . . . 97
</p>
<p>7.13 Generate WWW pages automagically . . . . . . . . . . . . . . . . . . . 98
</p>
<p>7.14 Other supported functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
</p>
<p>7.15 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
</p>
<p>7.16 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
</p>
<p>7.17 Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
</p>
<p>8 WWW and CGI programming . . . . . . . . . . . 103
</p>
<p>8.1 Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
</p>
<p>8.2 Protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
</p>
<p>8.3 HTML coding of forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
</p>
<p>8.4 Perl and the web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
</p>
<p>8.4.1 Interpreting data from forms . . . . . . . . . . . . . . . . . . 105
</p>
<p>8.4.2 A complete guestbook example in perl . . . . . . . . . 109
</p>
<p>8.5 PHP and the web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
</p>
<p>8.5.1 Embedded PHP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
</p>
<p>8.5.2 PHP and forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
</p>
<p>9 C programming . . . . . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>9.1 Shell or C? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>9.2 C program structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>9.2.1 The form of a C program. . . . . . . . . . . . . . . . . . . . . . 115
</p>
<p>9.2.2 Macros and declarations . . . . . . . . . . . . . . . . . . . . . . 116
</p>
<p>9.2.3 Several &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
</p>
<p>9.3 A note about UNIX system calls and standards . . . . . . . . . . 117
</p>
<p>9.4 Compiling: `cc', `ld' and `a.out' . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>9.4.1 Libraries and `LD_LIBRARY_PATH' . . . . . . . . . . . . . . 117
</p>
<p>9.4.2 Include &#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
</p>
<p>9.4.3 Shared and static libraries . . . . . . . . . . . . . . . . . . . . . 118
</p>
<p>9.4.4 Knowing about important paths: directory structure
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
</p>
<p>9.5 Make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
</p>
<p>9.5.1 Compiling large projects . . . . . . . . . . . . . . . . . . . . . . 120
</p>
<p>9.5.2 Make&#12;les . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
</p>
<p>9.5.3 New su&#14;x rules for C++ . . . . . . . . . . . . . . . . . . . . . . . 124
</p>
<p>9.6 The argv, argc and envp paramters . . . . . . . . . . . . . . . . . . . . 125
</p>
<p>9.7 Environment variables in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
</p>
<p>9.8 Files and directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
</p>
<p>9.8.1 opendir, readdir . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
</p>
<p>9.8.2 stat() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
</p>
<p>9.8.3 lstat and readlink . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
</p>
<p>9.9 stat() test macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
</p>
<p>9.9.1 Example &#12;ling program . . . . . . . . . . . . . . . . . . . . . . . 129
</p>
<p>9.10 Process control, fork(), exec(), popen() and system . . 130
</p>
<p>9.11 A more secure popen() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>v<p>9.12 Traps and signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
</p>
<p>9.13 Regular expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
</p>
<p>9.14 DES encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
</p>
<p>9.15 Device control: ioctl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
</p>
<p>9.16 Database example (Berkeley db) . . . . . . . . . . . . . . . . . . . . . . 146
</p>
<p>9.17 Text parsing tools: `lex' and `yacc' . . . . . . . . . . . . . . . . . . . 147
</p>
<p>9.18 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
</p>
<p>10 Network Programming . . . . . . . . . . . . . . . . . . 151
</p>
<p>10.1 Socket streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
</p>
<p>10.2 Multithreading a server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
</p>
<p>10.3 System databases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
</p>
<p>10.4 DNS - The Domain Name Service . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>10.4.1 gethostbyname() . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
</p>
<p>10.5 C support for NFS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
</p>
<p>10.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
</p>
<p>Appendix A Summary of programming idioms.
</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
</p>
<p>Command and Variable Index . . . . . . . . . . . . . . . 169
</p>
<p>Concept Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>vi The unix programming environment</p>

</div></div>
</body></html>